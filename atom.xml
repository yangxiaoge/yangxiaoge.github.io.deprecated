<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>珠珠のBlog</title>
  <icon>https://www.gravatar.com/avatar/4ec65d784d203bac0fd2da7375835dff</icon>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangxiaoge.github.io/"/>
  <updated>2019-03-21T08:44:17.578Z</updated>
  <id>https://yangxiaoge.github.io/</id>
  
  <author>
    <name>Bruce Yang</name>
    <email>yang.jianan0926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart 如何优雅的避空</title>
    <link href="https://yangxiaoge.github.io/2019/03/20/2019-3-20-Dart%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%81%BF%E7%A9%BA/"/>
    <id>https://yangxiaoge.github.io/2019/03/20/2019-3-20-Dart如何优雅的避空/</id>
    <published>2019-03-20T15:27:24.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>对于每一个程序员来说，空指针异常应该是基本都会遇到过的异常，而且这个异常出现的概率还比较大。<br>但是，空指针异常又是最容易解决的异常，因为只要加个非空判断就可以避免了。<br>本篇通过对比一般非空判断和 dart 特有的语法糖告诉你如何使用 dart 进行优雅的避空。</p><h2 id="dart"><a href="#dart" class="headerlink" title="dart ?."></a>dart ?.</h2><p>dart 语法糖 <code>?.</code></p><p>它的意思是左边如果为空返回 null，否则返回右边的值。</p><pre><code>A?.B如果 A 等于 null，那么 A?.B 为 null如果 A 不等于 null，那么 A?.B 等价于 A.B</code></pre><h2 id="dart-1"><a href="#dart-1" class="headerlink" title="dart ??"></a>dart ??</h2><p>dart 语法糖 <code>??</code></p><p>它的意思是左边如果为空返回右边的值，否则不处理。</p><pre><code>A??B如果 A 等于 null，那么 A??B 为 B如果 A 不等于 null，那么 A??B 为 A</code></pre><h2 id="dart-优雅所在"><a href="#dart-优雅所在" class="headerlink" title="dart ?. ?? 优雅所在"></a>dart ?. ?? 优雅所在</h2><p>这边举例说明下使用 ?. ?? 语法糖和不使用的对比。</p><pre><code>void main() {  C c = new C(&#39;Case 1&#39;);  B b = new B(c);  A a = new A(b);//   C c = new C(null);//   B b = new B(c);//   A a = new A(b);//   C c = new C(&#39;Case 2&#39;);//   B b = null;//   A a = new A(b);  //直接使用.来最终获取 c 的变量 value  if (a != null &amp;&amp; a.bMember != null &amp;&amp; a.bMember.cMember != null) {    print(a.bMember.cMember.value);  } else {    print(null);  }  //直接使用.来最终获取 c 的变量 value，为空时返回 unknown  if (a != null &amp;&amp; a.bMember != null &amp;&amp; a.bMember.cMember != null) {    String value = a.bMember.cMember.value;    if (value == null) {      value = &#39;unknown&#39;;    }    print(value);  } else {    print(&#39;unknown&#39;);  }  //dart 使用?.来最终获取 c 的变量 value  print(a?.bMember?.cMember?.value);  //dart 使用?.来最终获取 c 的变量 value，为空时使用 ?? 返回 unknown  print(a?.bMember?.cMember?.value??&#39;unknown&#39;);}class A {  final B bMember;  A(this.bMember);}class B {  final C cMember;  B(this.cMember);}class C {  final String value;  C(this.value);}</code></pre><p>这里面有三个 case，另外两个 case 暂时注释掉。</p><p>这三个 case 的结果分别为：</p><pre><code>Case 1Case 1Case 1Case 1</code></pre><pre><code>nullunknownnullunknown</code></pre><pre><code>nullunknownnullunknown</code></pre><p>可以看到 dart 的语法糖很优雅，一行全搞定。</p><blockquote><p>作者：AndroidTraveler<br>链接：<a href="https://juejin.im/post/5c70fc666fb9a049cd54d206" target="_blank" rel="noopener">https://juejin.im/post/5c70fc666fb9a049cd54d206</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于每一个程序员来说，空指针异常应该是基本都会遇到过的异常，而且这个异常出现的概率还比较大。&lt;br&gt;但是，空指针异常又是最容易解决的异常，因为只要加个非空判断就可以避免了。&lt;br&gt;本篇通过对比一般非空判断和 dart 特有的语法糖告诉你如何使用 dart 进行优雅的避空。&lt;
      
    
    </summary>
    
      <category term="Dart" scheme="https://yangxiaoge.github.io/categories/Dart/"/>
    
    
      <category term="Dart" scheme="https://yangxiaoge.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 状态管理 - Provide（Google 亲儿子）</title>
    <link href="https://yangxiaoge.github.io/2019/03/18/2019-3-18-Flutter-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Provide/"/>
    <id>https://yangxiaoge.github.io/2019/03/18/2019-3-18-Flutter-状态管理-Provide/</id>
    <published>2019-03-18T10:05:00.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p><code>flutter-provide</code> 是 Google 的亲儿子，<a href="https://github.com/google/flutter-provide" target="_blank" rel="noopener">flutter-provide</a>允许我们更加灵活地处理数据类型和数据。允许在小部件树中传递数据的类。它被设计为替代品 <a href="https://github.com/brianegan/scoped_model" target="_blank" rel="noopener">Scoped_model</a>，允许更灵活地处理数据类型和数据。</p><h2 id="什么是-Provide"><a href="#什么是-Provide" class="headerlink" title="什么是 Provide"></a>什么是 Provide</h2><p>和 Scoped_model 一样，Provide 也是借助了 <code>InheritWidget</code>，将共享状态放到顶层 MaterialApp 之上。底层部件通过 Provide 获取该状态，并通过混合 <code>ChangeNotifier</code> 通知依赖于该状态的组件刷新。</p><h2 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h2><p>在 <code>pubspec.yaml</code> 中添加 <code>provide: ^1.0.2</code></p><h2 id="第二步：创建-Model"><a href="#第二步：创建-Model" class="headerlink" title="第二步：创建 Model"></a>第二步：创建 Model</h2><pre><code>///Counterclass Counter extends ChangeNotifier {  int value = 0;  String hahh = &#39;&#39;;  void increment() {    value += 1;    hahh = &#39;haha $value&#39;;    notifyListeners();  }}///Switcherclass Switcher extends ChangeNotifier {  bool checked = false;  void check() {    checked = !checked;    notifyListeners();  }}</code></pre><h2 id="第三步：将状态放入顶层"><a href="#第三步：将状态放入顶层" class="headerlink" title="第三步：将状态放入顶层"></a>第三步：将状态放入顶层</h2><pre><code>void main() {  // Initialize the model. Can be done outside a widget, like here.  var counter = Counter();  var switcher = Switcher();  // Set up a Providers instance.  var providers = Providers();  providers    ..provide(Provider&lt;Counter&gt;.value(counter))    ..provide(Provider&lt;Switcher&gt;.value(switcher));  // Now we&#39;re ready to run the app...  runApp(    // ... and provide the model to all widgets within.    ProviderNode(      providers: providers,      child: MyApp(),    ),  );}</code></pre><h2 id="第四步：获取状态"><a href="#第四步：获取状态" class="headerlink" title="第四步：获取状态"></a>第四步：获取状态</h2><pre><code>Provide&lt;Counter&gt;(    builder: (context, child, counter) =&gt; Text(        &#39;${counter.value}&#39;,        style: Theme.of(context).textTheme.display1,        ),),Provide&lt;Counter&gt;(    builder: (context, child, counter) {    print(&#39;改变啦，哈哈哈 ${counter.hahh}&#39;);    return Text(&#39;${counter.hahh}&#39;);    },),</code></pre><h2 id="第五步：更新状态"><a href="#第五步：更新状态" class="headerlink" title="第五步：更新状态"></a>第五步：更新状态</h2><pre><code>///可以点击按钮手动触发状态更新，或者后台数据返回后触发更新等Provide.value&lt;Counter&gt;(context).increment()Provide.value&lt;Switcher&gt;(context).check()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;flutter-provide&lt;/code&gt; 是 Google 的亲儿子，&lt;a href=&quot;https://github.com/google/flutter-provide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flutter-pro
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 笔记</title>
    <link href="https://yangxiaoge.github.io/2019/03/14/2019-3-14-flutter%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangxiaoge.github.io/2019/03/14/2019-3-14-flutter笔记/</id>
    <published>2019-03-14T09:20:49.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>记录 <code>Flutter</code> 开发学习过程中的工具，错误，解决思路等。</p><ol><li><p>渐变色AppBar</p><pre><code>     //渐变色AppBar     //https://github.com/loosaSH/flutter-appbar     appBar: PreferredSize(       child: Container(         padding: EdgeInsets.only(top: MediaQuery.of(context).padding.top),         child: Padding(           padding:               const EdgeInsets.only(left: 15.0, top: 15.0, bottom: 15.0),           child: Text(             Constants.appName,             style: TextStyle(                 fontSize: 20.0,                 fontWeight: FontWeight.w500,                 color: Colors.white),           ),         ),         decoration: BoxDecoration(             gradient: LinearGradient(                 colors: [Colors.red, Theme.of(context).primaryColor]),             boxShadow: [               BoxShadow(                 color: Colors.grey[500],                 blurRadius: 20.0,                 spreadRadius: 1.0,               )             ]),       ),       preferredSize: Size(MediaQuery.of(context).size.width, 150.0),     ),</code></pre></li><li><p><a href="https://github.com/xuelongqy/flutter_easyrefresh/blob/master/example/lib/widget/list_item.dart" target="_blank" rel="noopener">ListItem</a><br><code>`</code><br>import ‘package:flutter/material.dart’;</p></li></ol><p>/// 列表项<br> class ListItem extends StatefulWidget {<br>  // 点击事件<br>   final VoidCallback onPressed;<br>  // 图标<br>   final Widget icon;<br>  // 标题<br>   final String title;<br>  final Color titleColor;<br>  // 描述<br>   final String describe;<br>  final Color describeColor;<br>  // 右侧控件<br>   final Widget rightWidget;</p><p>  // 构造函数<br>   ListItem({<br>    Key key,<br>    this.onPressed,<br>    this.icon,<br>    this.title,<br>    this.titleColor: Colors.black,<br>    this.describe,<br>    this.describeColor: Colors.grey,<br>    this.rightWidget,<br>  }) : super(key: key);</p><p>  @override<br>  _ListItemState createState() =&gt; _ListItemState();<br>}</p><p>class _ListItemState extends State<listitem> {<br>  @override<br>  Widget build(BuildContext context) {<br>    return FlatButton(<br>      onPressed: widget.onPressed,<br>      padding: EdgeInsets.all(0.0),<br>      shape: Border.all(<br>        color: Colors.transparent,<br>        width: 0.0,<br>        style: BorderStyle.none,<br>      ),<br>      child: Container(<br>          height: 60.0,<br>          width: double.infinity,<br>          child: Row(<br>            children: <widget>[<br>              widget.icon != null<br>                  ? Container(<br>                      padding: EdgeInsets.all(14.0),<br>                      child: SizedBox(<br>                        height: 32.0,<br>                        width: 32.0,<br>                        child: widget.icon,<br>                      ),<br>                    )<br>                  : Container(<br>                      width: 14.0,<br>                    ),<br>              Expanded(<br>                flex: 1,<br>                child: Column(<br>                  mainAxisAlignment: MainAxisAlignment.center,<br>                  crossAxisAlignment: CrossAxisAlignment.start,<br>                  children: <widget>[<br>                    widget.title != null<br>                        ? Text(<br>                            widget.title,<br>                            style: TextStyle(<br>                              color: widget.titleColor,<br>                              fontSize: 14.0,<br>                              fontWeight: FontWeight.bold,<br>                            ),<br>                          )<br>                        : Container(),<br>                    widget.describe != null<br>                        ? Text(<br>                            widget.describe,<br>                            maxLines: 2,<br>                            style: TextStyle(<br>                                color: widget.describeColor, fontSize: 12.0),<br>                          )<br>                        : Container(),<br>                  ],<br>                ),<br>              ),<br>              widget.rightWidget == null ? Container() : widget.rightWidget,<br>              Container(<br>                width: 14.0,<br>              ),<br>            ],<br>          )),<br>    );<br>  }<br>}</widget></widget></listitem></p><p>/// 空图标<br> class EmptyIcon extends Icon {<br>  EmptyIcon() : super(Icons.hourglass_empty);<br>  @override<br>  Widget build(BuildContext context) {<br>    return Container();<br>  }<br>}</p><pre><code>3. 加载资源文件中的mock数据（比方说模拟后台json数据）</code></pre><pre><code>var responseStr = await rootBundle.loadString(&#39;mock.json&#39;);var responseJson = json.decode(responseStr);return responseJson[&#39;data&#39;];</code></pre><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录 &lt;code&gt;Flutter&lt;/code&gt; 开发学习过程中的工具，错误，解决思路等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;渐变色AppBar&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     //渐变色AppBar
     //https://github.com/loosaSH/
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 状态管理 - BLoC</title>
    <link href="https://yangxiaoge.github.io/2019/03/14/2019-3-14-Flutter-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Bloc/"/>
    <id>https://yangxiaoge.github.io/2019/03/14/2019-3-14-Flutter-状态管理-Bloc/</id>
    <published>2019-03-14T09:20:49.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p><code>BLoC</code> 是 Google 提出的一种全新的<code>状态管理</code>方案。<a href="https://juejin.im/post/5b97fa0d5188255c5546dcf8" target="_blank" rel="noopener">Scoped Model</a>，<a href="https://juejin.im/post/5c6d4b52f265da2dc675b407" target="_blank" rel="noopener">Provide</a>等也是目前比较流行的状态管理方案。</p><h2 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h2><p>Flutter 自身已经为我们提供了状态管理 <code>Stateful widget</code>，在 stateful widget 中，我们 widget 的描述信息被放进了 State，<br>而 stateful widget 只是持有一些 immutable 的数据以及创建它的状态而已。它的所有成员变量都应该是 final 的，当状态发生变化的时候，<br>我们需要通知视图重新绘制，这个过程就是 setState。这看上去很不错，我们改变状态的时候 <code>setState</code> 一下就可以了。<br>在我们一开始构建应用的时候，也许很简单，我们这时候可能并不需要状态管理。<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/setState%E7%AE%80%E5%8D%95%E5%9E%8B.png" alt><br>但是随着功能的增加，你的应用程序将会有几十个甚至上百个状态。这个时候你的应用应该会是这样！<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/setState%E5%A4%8D%E6%9D%82%E5%9E%8B.png" alt><br>一旦当 app 的交互变得复杂，setState 出现的次数便会显著增加，每次 setState 都会重新调用 build 方法，这势必对于性能以及代码的可阅读性带来一定的影响。<br>能不能不使用 setState 就能刷新页面呢？如何在多个页面中共享状态？我们希望有一种更加强大的方式，来管理我们的状态。</p><h2 id="BLoC-是什么"><a href="#BLoC-是什么" class="headerlink" title="BLoC 是什么"></a>BLoC 是什么</h2><p><code>BLoC</code> 是一种利用 <code>Reactive Programming（响应式编程）</code> 方式构建应用的方法，这是一个由流构成的完全异步的世界。<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/bloc.png" alt></p><ol><li>用 StreamBuilder 包裹有状态的部件，streambuilder 将会监听一个流</li><li>这个流来自于 BLoC</li><li>有状态小部件中的数据来自于监听的流。</li><li>用户交互手势被检测到，产生了事件。例如按了一下按钮。</li><li>调用 bloc 的功能来处理这个事件</li><li>在 bloc 中处理完毕后将会吧最新的数据 add 进流的 sink 中</li><li>StreamBuilder 监听到新的数据，产生一个新的 snapshot，并重新调用 build 方法</li><li>Widget 被重新构建</li></ol><p>BLoC 能够允许我们完美的分离业务逻辑！再也不用考虑什么时候需要刷新屏幕了，一切交给 StreamBuilder 和 BLoC! 和 StatefulWidget 说拜拜！！</p><p>BLoC 代表业务逻辑组件（<code>Business Logic Component</code>），由来自 Google 的两位工程师 Paolo Soares 和 Cong Hui 设计，并在 2018 年 DartConf 期间（2018 年 1 月 23 日至 24 日）首次展示。<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DPLHln7wHgPE" target="_blank" rel="noopener">点击观看 Youtube 视频。</a></p><blockquote><p>作者：Vadaski<br>链接：<a href="https://juejin.im/post/5bb6f344f265da0aa664d68a" target="_blank" rel="noopener">https://juejin.im/post/5bb6f344f265da0aa664d68a</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;BLoC&lt;/code&gt; 是 Google 提出的一种全新的&lt;code&gt;状态管理&lt;/code&gt;方案。&lt;a href=&quot;https://juejin.im/post/5b97fa0d5188255c5546dcf8&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>AndServer - Android平台的Web服务器和Web开发框架</title>
    <link href="https://yangxiaoge.github.io/2019/03/08/2019-3-8-AndServer-Android%E5%B9%B3%E5%8F%B0%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CWeb%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>https://yangxiaoge.github.io/2019/03/08/2019-3-8-AndServer-Android平台的Web服务器和Web开发框架/</id>
    <published>2019-03-08T12:25:15.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndServer"><a href="#AndServer" class="headerlink" title="AndServer"></a>AndServer</h1><p>Android平台的Web服务器和Web开发框架。<a href="https://github.com/yanzhenjie/AndServer" target="_blank" rel="noopener">AndServer</a>像SpringMVC一样提供了注解方式，不同的是<a href="https://github.com/yanzhenjie/AndServer" target="_blank" rel="noopener">AndServer</a>基于编译时注解，如果你使用过SpringMVC，那么你将很快的掌握它。</p><blockquote><p>本文转载：<a href="https://github.com/yanzhenjie/AndServer/blob/master/README-CN.md" target="_blank" rel="noopener">https://github.com/yanzhenjie/AndServer/blob/master/README-CN.md</a></p></blockquote><ul><li>静态网站部署</li><li>动态Http Api部署</li></ul><pre><code class="java">@RestController@RequestMapping(path = &quot;/user&quot;)public class UserController {    @PostMapping(&quot;/login&quot;)    public String login(@RequestParam(&quot;account&quot;) String account,         @RequestParam(&quot;password&quot;) String password) {        if (...) {            return &quot;Successful.&quot;;        }        return &quot;Failed.&quot;;    }    @GetMapping(path = &quot;/info/{userId}&quot;)    public User detail(@PathVariable(&quot;userId&quot;) String userId) {        User user = findUserById(userId);        ...        return user;    }}</code></pre><p>上面的代码将会生成下面的两个Http Api：</p><pre><code class="text">POST http://.../user/loginGET http://.../user/info/uid_001</code></pre><p>文档和更多的附加信息请看<a href="https://www.yanzhenjie.com/AndServer" target="_blank" rel="noopener">网站</a>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre><code class="groovy">dependencies {    implementation &#39;com.yanzhenjie.andserver:api:2.0.4&#39;    annotationProcessor &#39;com.yanzhenjie.andserver:processor:2.0.4&#39;}</code></pre><p>如果你正在使用Kotlin，请使用<code>kapt</code>代替<code>annotationProcessor</code>。</p><p><a href="https://github.com/yanzhenjie/AndServer" target="_blank" rel="noopener">AndServer</a>最低支持Android 2.3(Api level 9)。</p><h2 id="接口定制"><a href="#接口定制" class="headerlink" title="接口定制"></a>接口定制</h2><p>基于smaple，我写了部分post，get，图片预览，等接口，postman测试正常访问，详细代码见代码：<a href="https://github.com/yangxiaoge/AndServer" target="_blank" rel="noopener">https://github.com/yangxiaoge/AndServer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndServer&quot;&gt;&lt;a href=&quot;#AndServer&quot; class=&quot;headerlink&quot; title=&quot;AndServer&quot;&gt;&lt;/a&gt;AndServer&lt;/h1&gt;&lt;p&gt;Android平台的Web服务器和Web开发框架。&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="AndServer" scheme="https://yangxiaoge.github.io/tags/AndServer/"/>
    
  </entry>
  
  <entry>
    <title>Flutter_Go 代码开发规范 - alibaba</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go 代码开发规范/</id>
    <published>2019-02-28T10:27:22.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">Flutter Go 开发规范第一版</a></li><li>原文作者：<a href="https://github.com/alibaba" target="_blank" rel="noopener">alibaba</a></li></ul></blockquote><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="标识符三种类型"><a href="#标识符三种类型" class="headerlink" title="标识符三种类型"></a>标识符三种类型</h3><h4 id="大驼峰"><a href="#大驼峰" class="headerlink" title="大驼峰"></a>大驼峰</h4><p>类、枚举、typedef和类型参数</p><pre><code>  class SliderMenu { ... }  class HttpRequest { ... }  typedef Predicate = bool Function&lt;T&gt;(T value);</code></pre><p>包括用于元数据注释的类</p><pre><code>  class Foo {    const Foo([arg]);  }  @Foo(anArg)  class A { ... }  @Foo()  class B { ... }</code></pre><h4 id="使用小写加下划线来命名库和源文件"><a href="#使用小写加下划线来命名库和源文件" class="headerlink" title="使用小写加下划线来命名库和源文件"></a>使用小写加下划线来命名库和源文件</h4><pre><code>  library peg_parser.source_scanner;  import &#39;file_system.dart&#39;;  import &#39;slider_menu.dart&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  library pegparser.SourceScanner;  import &#39;file-system.dart&#39;;  import &#39;SliderMenu.dart&#39;;</code></pre><h4 id="使用小写加下划线来命名导入前缀"><a href="#使用小写加下划线来命名导入前缀" class="headerlink" title="使用小写加下划线来命名导入前缀"></a>使用小写加下划线来命名导入前缀</h4><pre><code>  import &#39;dart:math&#39; as math;  import &#39;package:angular_components/angular_components&#39;      as angular_components;  import &#39;package:js/js.dart&#39; as js;</code></pre><p>不推荐如下写法：</p><pre><code>  import &#39;dart:math&#39; as Math;  import &#39;package:angular_components/angular_components&#39;      as angularComponents;  import &#39;package:js/js.dart&#39; as JS;</code></pre><h4 id="使用小驼峰法命名其他标识符"><a href="#使用小驼峰法命名其他标识符" class="headerlink" title="使用小驼峰法命名其他标识符"></a>使用小驼峰法命名其他标识符</h4><pre><code>  var item;  HttpRequest httpRequest;  void align(bool clearItems) {    // ...  }</code></pre><h4 id="优先使用小驼峰法作为常量命名"><a href="#优先使用小驼峰法作为常量命名" class="headerlink" title="优先使用小驼峰法作为常量命名"></a>优先使用小驼峰法作为常量命名</h4><pre><code>  const pi = 3.14;  const defaultTimeout = 1000;  final urlScheme = RegExp(&#39;^([a-z]+):&#39;);  class Dice {    static final numberGenerator = Random();  }</code></pre><p>不推荐如下写法：</p><pre><code>  const PI = 3.14;  const DefaultTimeout = 1000;  final URL_SCHEME = RegExp(&#39;^([a-z]+):&#39;);  class Dice {    static final NUMBER_GENERATOR = Random();  }</code></pre><h4 id="不使用前缀字母"><a href="#不使用前缀字母" class="headerlink" title="不使用前缀字母"></a>不使用前缀字母</h4><p>因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。</p><pre><code>  defaultTimeout</code></pre><p>不推荐如下写法：</p><pre><code>  kDefaultTimeout</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p><h4 id="在其他引入之前引入所需的dart库"><a href="#在其他引入之前引入所需的dart库" class="headerlink" title="在其他引入之前引入所需的dart库"></a>在其他引入之前引入所需的dart库</h4><pre><code>  import &#39;dart:async&#39;;  import &#39;dart:html&#39;;  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;</code></pre><h4 id="在相对引入之前先引入在包中的库"><a href="#在相对引入之前先引入在包中的库" class="headerlink" title="在相对引入之前先引入在包中的库"></a>在相对引入之前先引入在包中的库</h4><pre><code>  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;  import &#39;util.dart&#39;;</code></pre><h4 id="第三方包的导入先于其他包"><a href="#第三方包的导入先于其他包" class="headerlink" title="第三方包的导入先于其他包"></a>第三方包的导入先于其他包</h4><pre><code>  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;  import &#39;package:my_package/util.dart&#39;;</code></pre><h4 id="在所有导入之后，在单独的部分中指定导出"><a href="#在所有导入之后，在单独的部分中指定导出" class="headerlink" title="在所有导入之后，在单独的部分中指定导出"></a>在所有导入之后，在单独的部分中指定导出</h4><pre><code>  import &#39;src/error.dart&#39;;  import &#39;src/foo_bar.dart&#39;;  export &#39;src/error.dart&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  import &#39;src/error.dart&#39;;  export &#39;src/error.dart&#39;;  import &#39;src/foo_bar.dart&#39;;</code></pre><h3 id="所有流控制结构，请使用大括号"><a href="#所有流控制结构，请使用大括号" class="headerlink" title="所有流控制结构，请使用大括号"></a>所有流控制结构，请使用大括号</h3><p>这样做可以避免悬浮的else问题</p><pre><code>  if (isWeekDay) {    print(&#39;Bike to work!&#39;);  } else {    print(&#39;Go dancing or read a book!&#39;);  }</code></pre><h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号</p><pre><code>  if (arg == null) return defaultValue;</code></pre><p>如果流程体超出了一行需要分划请使用大括号：</p><pre><code>  if (overflowChars != other.overflowChars) {    return overflowChars &lt; other.overflowChars;  }</code></pre><p>不推荐如下写法：</p><pre><code>  if (overflowChars != other.overflowChars)    return overflowChars &lt; other.overflowChars;</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="要像句子一样格式化"><a href="#要像句子一样格式化" class="headerlink" title="要像句子一样格式化"></a>要像句子一样格式化</h3><p>除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。</p><pre><code>  greet(name) {    // Assume we have a valid name.    print(&#39;Hi, $name!&#39;);  }</code></pre><p>不推荐如下写法：</p><pre><code>  greet(name) {    /* Assume we have a valid name. */    print(&#39;Hi, $name!&#39;);  }</code></pre><p>可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用//</p><h3 id="Doc注释"><a href="#Doc注释" class="headerlink" title="Doc注释"></a>Doc注释</h3><p>使用///文档注释来记录成员和类型。</p><p>使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。</p><pre><code>  /// The number of characters in this chunk when unsplit.  int get length =&gt; ...</code></pre><blockquote><p>由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/<strong>…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/</strong>和<em>/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用</em>标记列表项的项目符号列表。</p></blockquote><h3 id="考虑为私有api编写文档注释"><a href="#考虑为私有api编写文档注释" class="headerlink" title="考虑为私有api编写文档注释"></a>考虑为私有api编写文档注释</h3><p>Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员</p><h4 id="用一句话总结开始doc注释"><a href="#用一句话总结开始doc注释" class="headerlink" title="用一句话总结开始doc注释"></a>用一句话总结开始doc注释</h4><p>以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。</p><pre><code>/// Deletes the file at [path] from the file system.void delete(String path) {  ...}</code></pre><p>不推荐如下写法：</p><pre><code>  /// Depending on the state of the file system and the user&#39;s permissions,  /// certain operations may or may not be possible. If there is no file at  /// [path] or it can&#39;t be accessed, this function throws either [IOError]  /// or [PermissionError], respectively. Otherwise, this deletes the file.  void delete(String path) {    ...  }</code></pre><h4 id="“doc注释”的第一句话分隔成自己的段落"><a href="#“doc注释”的第一句话分隔成自己的段落" class="headerlink" title="“doc注释”的第一句话分隔成自己的段落"></a>“doc注释”的第一句话分隔成自己的段落</h4><p>在第一个句子之后添加一个空行，把它分成自己的段落</p><pre><code>  /// Deletes the file at [path].  ///  /// Throws an [IOError] if the file could not be found. Throws a  /// [PermissionError] if the file is present but could not be deleted.  void delete(String path) {    ...  }</code></pre><h2 id="Flutter-Go-使用参考"><a href="#Flutter-Go-使用参考" class="headerlink" title="Flutter_Go 使用参考"></a>Flutter_Go 使用参考</h2><h3 id="库的引用"><a href="#库的引用" class="headerlink" title="库的引用"></a>库的引用</h3><p>flutter go 中，导入lib下文件库，统一指定包名，避免过多的<code>../../</code></p><pre><code>package:flutter_go/</code></pre><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="使用相邻字符串连接字符串文字"><a href="#使用相邻字符串连接字符串文字" class="headerlink" title="使用相邻字符串连接字符串文字"></a>使用相邻字符串连接字符串文字</h4><p>如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。</p><pre><code>raiseAlarm(    &#39;ERROR: Parts of the spaceship are on fire. Other &#39;    &#39;parts are overrun by martians. Unclear which are which.&#39;);</code></pre><p>不推荐如下写法:</p><pre><code>raiseAlarm(&#39;ERROR: Parts of the spaceship are on fire. Other &#39; +    &#39;parts are overrun by martians. Unclear which are which.&#39;);</code></pre><h4 id="优先使用模板字符串"><a href="#优先使用模板字符串" class="headerlink" title="优先使用模板字符串"></a>优先使用模板字符串</h4><pre><code>&#39;Hello, $name! You are ${year - birth} years old.&#39;;</code></pre><h4 id="在不需要的时候，避免使用花括号"><a href="#在不需要的时候，避免使用花括号" class="headerlink" title="在不需要的时候，避免使用花括号"></a>在不需要的时候，避免使用花括号</h4><pre><code>  &#39;Hi, $name!&#39;  &quot;Wear your wildest $decade&#39;s outfit.&quot;</code></pre><p>不推荐如下写法：</p><pre><code>  &#39;Hello, &#39; + name + &#39;! You are &#39; + (year - birth).toString() + &#39; y...&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  &#39;Hi, ${name}!&#39;  &quot;Wear your wildest ${decade}&#39;s outfit.&quot;</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="尽可能使用集合字面量"><a href="#尽可能使用集合字面量" class="headerlink" title="尽可能使用集合字面量"></a>尽可能使用集合字面量</h4><p>如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。</p><pre><code>  var points = [];  var addresses = {};  var lines = &lt;Lines&gt;[];</code></pre><p>不推荐如下写法：</p><pre><code>  var points = List();  var addresses = Map();</code></pre><h4 id="不要使用-length查看集合是否为空"><a href="#不要使用-length查看集合是否为空" class="headerlink" title="不要使用.length查看集合是否为空"></a>不要使用.length查看集合是否为空</h4><pre><code>if (lunchBox.isEmpty) return &#39;so hungry...&#39;;if (words.isNotEmpty) return words.join(&#39; &#39;);</code></pre><p>不推荐如下写法：</p><pre><code>  if (lunchBox.length == 0) return &#39;so hungry...&#39;;  if (!words.isEmpty) return words.join(&#39; &#39;);</code></pre><h4 id="考虑使用高阶方法转换序列"><a href="#考虑使用高阶方法转换序列" class="headerlink" title="考虑使用高阶方法转换序列"></a>考虑使用高阶方法转换序列</h4><p>如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性</p><pre><code>  var aquaticNames = animals      .where((animal) =&gt; animal.isAquatic)      .map((animal) =&gt; animal.name);</code></pre><h4 id="避免使用带有函数字面量的Iterable-forEach"><a href="#避免使用带有函数字面量的Iterable-forEach" class="headerlink" title="避免使用带有函数字面量的Iterable.forEach()"></a>避免使用带有函数字面量的Iterable.forEach()</h4><p>在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。</p><pre><code>for (var person in people) {  ...}</code></pre><p>不推荐如下写法：</p><pre><code>  people.forEach((person) {    ...  });</code></pre><h4 id="不要使用List-from-，除非打算更改结果的类型"><a href="#不要使用List-from-，除非打算更改结果的类型" class="headerlink" title="不要使用List.from()，除非打算更改结果的类型"></a>不要使用List.from()，除非打算更改结果的类型</h4><p>给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表</p><pre><code>var copy1 = iterable.toList();var copy2 = List.from(iterable);</code></pre><p>明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数</p><pre><code>// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;int&gt;&quot;:print(iterable.toList().runtimeType);</code></pre><pre><code>// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;dynamic&gt;&quot;:print(List.from(iterable).runtimeType);</code></pre><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><h4 id="使用-将命名参数与其默认值分割开"><a href="#使用-将命名参数与其默认值分割开" class="headerlink" title="使用=将命名参数与其默认值分割开"></a>使用=将命名参数与其默认值分割开</h4><p>由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。</p><pre><code>  void insert(Object item, {int at = 0}) { ... }</code></pre><p>不推荐如下写法：</p><pre><code>  void insert(Object item, {int at: 0}) { ... }</code></pre><h4 id="不要使用显式默认值null"><a href="#不要使用显式默认值null" class="headerlink" title="不要使用显式默认值null"></a>不要使用显式默认值null</h4><p>如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它</p><pre><code>void error([String message]) {  stderr.write(message ?? &#39;\n&#39;);}</code></pre><p>不推荐如下写法:</p><pre><code>void error([String message = null]) {  stderr.write(message ?? &#39;\n&#39;);}</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="不要显式地将变量初始化为空"><a href="#不要显式地将变量初始化为空" class="headerlink" title="不要显式地将变量初始化为空"></a>不要显式地将变量初始化为空</h4><p>在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null</p><pre><code>  int _nextId;  class LazyId {    int _id;    int get id {      if (_nextId == null) _nextId = 0;      if (_id == null) _id = _nextId++;      return _id;    }  }</code></pre><p>不推荐如下写法：</p><pre><code>  int _nextId = null;  class LazyId {    int _id = null;    int get id {      if (_nextId == null) _nextId = 0;      if (_id == null) _id = _nextId++;      return _id;    }  }</code></pre><h4 id="避免储存你能计算的东西"><a href="#避免储存你能计算的东西" class="headerlink" title="避免储存你能计算的东西"></a>避免储存你能计算的东西</h4><p>在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们:</p><p>应该避免的写法：</p><pre><code>  class Circle {    num radius;    num area;    num circumference;    Circle(num radius)        : radius = radius,          area = pi * radius * radius,          circumference = pi * 2.0 * radius;  }</code></pre><p>如上代码问题：</p><ul><li>浪费内存</li><li>缓存的问题是无效——如何知道何时缓存过期需要重新计算？</li></ul><p>推荐的写法如下：</p><pre><code>  class Circle {    num radius;    Circle(this.radius);    num get area =&gt; pi * radius * radius;    num get circumference =&gt; pi * 2.0 * radius;  }</code></pre><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="不要把不必要地将字段包装在getter和setter中"><a href="#不要把不必要地将字段包装在getter和setter中" class="headerlink" title="不要把不必要地将字段包装在getter和setter中"></a>不要把不必要地将字段包装在getter和setter中</h4><p>不推荐如下写法：</p><pre><code>  class Box {    var _contents;    get contents =&gt; _contents;    set contents(value) {      _contents = value;    }  }</code></pre><h4 id="优先使用final字段来创建只读属性"><a href="#优先使用final字段来创建只读属性" class="headerlink" title="优先使用final字段来创建只读属性"></a>优先使用final字段来创建只读属性</h4><p>尤其对于 <code>StatelessWidget</code></p><h4 id="在不需要的时候不要用this"><a href="#在不需要的时候不要用this" class="headerlink" title="在不需要的时候不要用this"></a>在不需要的时候不要用this</h4><p>不推荐如下写法：</p><pre><code>  class Box {    var value;    void clear() {      this.update(null);    }    void update(value) {      this.value = value;    }  }</code></pre><p>推荐如下写法：</p><pre><code>  class Box {    var value;    void clear() {      update(null);    }    void update(value) {      this.value = value;    }  }</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="尽可能使用初始化的形式"><a href="#尽可能使用初始化的形式" class="headerlink" title="尽可能使用初始化的形式"></a>尽可能使用初始化的形式</h4><p>不推荐如下写法：</p><pre><code>  class Point {    num x, y;    Point(num x, num y) {      this.x = x;      this.y = y;    }  }</code></pre><p>推荐如下写法：</p><pre><code>class Point {  num x, y;  Point(this.x, this.y);}</code></pre><h4 id="不要使用new"><a href="#不要使用new" class="headerlink" title="不要使用new"></a>不要使用new</h4><p>Dart2使new 关键字可选</p><p>推荐写法：</p><pre><code>  Widget build(BuildContext context) {    return Row(      children: [        RaisedButton(          child: Text(&#39;Increment&#39;),        ),        Text(&#39;Click!&#39;),      ],    );  }</code></pre><p>不推荐如下写法：</p><pre><code>  Widget build(BuildContext context) {    return new Row(      children: [        new RaisedButton(          child: new Text(&#39;Increment&#39;),        ),        new Text(&#39;Click!&#39;),      ],    );  }</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="优先使用async-await代替原始的futures"><a href="#优先使用async-await代替原始的futures" class="headerlink" title="优先使用async/await代替原始的futures"></a>优先使用async/await代替原始的futures</h4><p>async/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。</p><pre><code>  Future&lt;int&gt; countActivePlayers(String teamName) async {    try {      var team = await downloadTeam(teamName);      if (team == null) return 0;      var players = await team.roster;      return players.where((player) =&gt; player.isActive).length;    } catch (e) {      log.error(e);      return 0;    }  }</code></pre><h4 id="当异步没有任何用处时，不要使用它"><a href="#当异步没有任何用处时，不要使用它" class="headerlink" title="当异步没有任何用处时，不要使用它"></a>当异步没有任何用处时，不要使用它</h4><p>如果可以在不改变函数行为的情况下省略异步，那么就这样做。、</p><pre><code>  Future afterTwoThings(Future first, Future second) {    return Future.wait([first, second]);  }</code></pre><p>不推荐写法：</p><pre><code>  Future afterTwoThings(Future first, Future second) async {    return Future.wait([first, second]);  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android 原生项目集成 Flutter 混合开发</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android%20%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Flutter%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android 原生项目集成 Flutter 混合开发/</id>
    <published>2019-02-28T09:09:06.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 <a href="https://github.com/yangxiaoge/wanandroid_flutter" target="_blank" rel="noopener">MuMuxi-Flutter</a> 版本，<br>但是现在想要把 Flutter 使用在现有的项目中，改如何操作呢？哈哈，Google 官方已经考虑到了这个问题，并且给出了集成方案 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">Add-Flutter-to-existing-apps</a>。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>新建一个 <code>Flutter module</code>，使用命令：<code>flutter create -t module {moduleName}</code>，其中 <code>moduleName</code> 我这里取名 <code>xinhua_media_flutter_module</code></li><li>随后将 <code>Flutter module</code> 推送至<code>git</code> 仓库，git 推送我就不累赘了，拿到仓库地址 <a href="https://gitee.com/xxx/xinhua_media_flutter_module.git" target="_blank" rel="noopener">https://gitee.com/xxx/xinhua_media_flutter_module.git</a></li><li>在<code>原生</code> Android 项目更目录添加 <code>git submodule</code><pre><code>git submodule add {Flutter module 仓库地址}, 即上面拿到的仓库地址 https://gitee.com/xxx/xinhua_media_flutter_module.gitgit submodule update</code></pre>此时项目结构如下图：<br><img src="https://github.com/yangxiaoge/PersonResources/blob/master/flutter/%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90flutter%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true" alt="原生集成flutter工程目录结构.png"></li><li>在原生项目<code>根目录</code> <code>settings.gradle</code> 中 <code>include &#39;:app&#39;</code> 下面添加如下配置<pre><code>setBinding(new Binding([gradle: this]))evaluate(new File(     &#39;xinhua_media_flutter_module/.android/include_flutter.groovy&#39;))</code></pre></li><li>原生项目 <code>app</code> 目录下的 <code>build.gradle</code> 文件中添加 <code>xinhua_media_flutter_module</code> 库的依赖<pre><code>// MyApp/app/build.gradleimplementation project(&#39;:flutter&#39;)</code></pre></li><li>在原生项目中新建一个 <code>FlutterActivity</code> 用来加载 Flutter mudule 页面入口<pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // &quot;flutter_page&quot; 是路由名称，在 Flutter `main.dart` 页面中需要用到 FlutterView seuicSettingPage = Flutter.createView(this, getLifecycle(), &quot;flutter_page&quot;); FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); // 加 flutterview 添加到布局中 addContentView(seuicSettingPage, layoutParams);}</code></pre></li><li>在 <code>xinhua_media_flutter_module</code> lib 下的 <code>main.dart</code> 文件中添加逻辑<br><code>`</code><br>// xinhua_media_flutter_module/lib/main.dart<br>// 以下 “flutter_page” 判断路由名称，MyApp 是自定义的组件，接下来就可以开发自己的功能逻辑。<br>// 如果发现 AS 不识别 Dart 语言，设置中勾选 <code>Enable Dart support</code><br>import ‘dart:ui’;<br>import ‘package:flutter/material.dart’;</li></ol><p>void main() =&gt; runApp(_widgetForRoute(window.defaultRouteName));</p><p>Widget _widgetForRoute(String route) {<br>  switch (route) {<br>    case ‘flutter_page’:<br>      return MyApp();<br>    default:<br>      return Center(<br>        child: Text(‘Unknown route: $route’, textDirection: TextDirection.ltr),<br>      );<br>  }<br>}<br><code>`</code></p><ol start="8"><li>然后<code>运行</code> Android 原生项目，</li></ol><p>如果混合项目想要使用 flutter <code>hot start/reload</code>，需要 cd 进入 <code>xinhua_media_flutter_module</code> 目录，然后执行 <code>flutter attach</code>，<br>然后打开 flutter 的页面就能正常使用 Hot restart/reload 啦，好了 Android 集成 flutter 到此结束，iOS 集成可以看 Google 官方教程。</p><ol start="9"><li>emmmmm，Flutter 真香😀😆😉😎😘🤩 </li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>Flutter</code> 作为 Google 的亲儿子，它还是「Google 下一代操作系统」<code>Fuchsia OS</code> 的内置 UI SDK ！2019 年将是 Flutter 的爆发期，<a href="https://github.com/search?q=flutter" target="_blank" rel="noopener">Github</a> 上已经有很多<br>国人开发的相关插件以及项目了，接下来我也会写一些跟自己 Flutter 项目相关的技术文章！加油！📚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 &lt;a href=&quot;https://github.com/
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter | 状态管理拓展篇——RxDart</title>
    <link href="https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%8B%93%E5%B1%95%E7%AF%87-RxDart/"/>
    <id>https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter状态管理拓展篇-RxDart/</id>
    <published>2019-02-19T11:22:01.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p><strong>元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！</strong></p><blockquote><ul><li>原文地址：<a href="https://juejin.im/post/5bcea438e51d4536c65d2232" target="_blank" rel="noopener">https://juejin.im/post/5bcea438e51d4536c65d2232</a></li><li>原文作者：<a href="https://juejin.im/user/5b5d45f4e51d453526175c06/posts" target="_blank" rel="noopener">Vadaski</a></li></ul></blockquote><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><h3 id="ReactiveX-是什么"><a href="#ReactiveX-是什么" class="headerlink" title="ReactiveX 是什么"></a>ReactiveX 是什么</h3><p>ReactiveX 是一个强大的库，用于通过使用<strong>可观察序列</strong>来编写<strong>异步</strong>和<strong>基于事件</strong>的程序。它突破了<strong>语言</strong>和<strong>平台</strong>的限制，让我们编写异步程序就像在自家花园散步那样 easy。我相信你一定会爱上它！</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/24/166a563fd4eb5800?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665e4f1257f4e00?imageslim" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5bcea438e51d4
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android数据库高手秘籍（LitePal）</title>
    <link href="https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E6%89%8B%E7%A7%98%E7%B1%8D%EF%BC%88LitePal%EF%BC%89/"/>
    <id>https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android数据库高手秘籍（LitePal）/</id>
    <published>2018-08-23T15:28:49.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自 <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">郭霖 CSDN</a></p><p>Android 数据库高手秘籍： <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/android-database-pro.html</a></p><p>本专栏主要讲解 Android 数据库相关的高级技术。其中包括了 SQLite 中一些不为人知的使用技巧，以及全面剖析 LitePal 这款 Android 数据库框架的所有用法。LitePal 项目地址是: <a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p><h3 id="Android-数据库高手秘籍-零-——前言"><a href="#Android-数据库高手秘籍-零-——前言" class="headerlink" title="Android 数据库高手秘籍 (零)——前言"></a><a href="https://blog.csdn.net/guolin_blog/article/details/38083103" target="_blank" rel="noopener">Android 数据库高手秘籍 (零)——前言</a></h3><h3 id="Android-数据库高手秘籍-一-——SQLite-命令"><a href="#Android-数据库高手秘籍-一-——SQLite-命令" class="headerlink" title="Android 数据库高手秘籍 (一)——SQLite 命令"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38461239" target="_blank" rel="noopener">Android 数据库高手秘籍 (一)——SQLite 命令</a></h3><h3 id="Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法"><a href="#Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法" class="headerlink" title="Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38556989" target="_blank" rel="noopener">Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法</a></h3><h3 id="Android-数据库高手秘籍-三-——使用-LitePal-升级表"><a href="#Android-数据库高手秘籍-三-——使用-LitePal-升级表" class="headerlink" title="Android 数据库高手秘籍 (三)——使用 LitePal 升级表"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39151617" target="_blank" rel="noopener">Android 数据库高手秘籍 (三)——使用 LitePal 升级表</a></h3><h3 id="Android-数据库高手秘籍-四-——使用-LitePal-建立表关联"><a href="#Android-数据库高手秘籍-四-——使用-LitePal-建立表关联" class="headerlink" title="Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39207945" target="_blank" rel="noopener">Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联</a></h3><h3 id="Android-数据库高手秘籍-五-——LitePal-的存储操作"><a href="#Android-数据库高手秘籍-五-——LitePal-的存储操作" class="headerlink" title="Android 数据库高手秘籍 (五)——LitePal 的存储操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39345833" target="_blank" rel="noopener">Android 数据库高手秘籍 (五)——LitePal 的存储操作</a></h3><h3 id="Android-数据库高手秘籍-六-——LitePal-的修改和删除操作"><a href="#Android-数据库高手秘籍-六-——LitePal-的修改和删除操作" class="headerlink" title="Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40083685" target="_blank" rel="noopener">Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作</a></h3><h3 id="Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术"><a href="#Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术" class="headerlink" title="Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40153833" target="_blank" rel="noopener">Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术</a></h3><h3 id="Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数"><a href="#Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数" class="headerlink" title="Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40614197" target="_blank" rel="noopener">Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数</a></h3><h3 id="Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧"><a href="#Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧" class="headerlink" title="Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧"></a><a href="http://blog.csdn.net/guolin_blog/article/details/80586028" target="_blank" rel="noopener">Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧</a></h3><h3 id="LitePal-学习笔记-忽略字段，多数据库"><a href="#LitePal-学习笔记-忽略字段，多数据库" class="headerlink" title="LitePal 学习笔记 - 忽略字段，多数据库"></a><a href="https://www.jianshu.com/p/bc68e763c7a2" target="_blank" rel="noopener">LitePal 学习笔记 - 忽略字段，多数据库</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自 &lt;a href=&quot;https://blog.csdn.net/column/details/android-database-pro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郭霖 CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android 数
      
    
    </summary>
    
      <category term="数据库" scheme="https://yangxiaoge.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 常用设计模式</title>
    <link href="https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android常用设计模式/</id>
    <published>2018-08-22T15:37:34.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式专栏： <a href="https://blog.csdn.net/lovelixue/article/category/7959476" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/category/7959476</a></p><p>代码 Github ：<a href="https://github.com/sdgSnow/DesignPattern" target="_blank" rel="noopener">https://github.com/sdgSnow/DesignPattern</a></p><h3 id="Android-常用设计模式（一、单例模式）："><a href="#Android-常用设计模式（一、单例模式）：" class="headerlink" title="Android 常用设计模式（一、单例模式）："></a><a href="https://blog.csdn.net/lovelixue/article/details/81940996" target="_blank" rel="noopener">Android 常用设计模式（一、单例模式）</a>：</h3><ol><li>饿汉式</li><li>懒汉式</li><li>双重锁模式</li></ol><h3 id="Android-常用设计模式（二、建造者模式）"><a href="#Android-常用设计模式（二、建造者模式）" class="headerlink" title="Android 常用设计模式（二、建造者模式）:"></a><a href="https://blog.csdn.net/lovelixue/article/details/81944629" target="_blank" rel="noopener">Android 常用设计模式（二、建造者模式）</a>:</h3><pre><code>//通过builder创建一个Person对象Person person = new Person.PersonBuilder(&quot;小羊羊&quot;)        .setAge(18)        .setSex(&quot;男&quot;)        .setIdentity(&quot;码农&quot;)        .build();</code></pre><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式专栏： &lt;a href=&quot;https://blog.csdn.net/lovelixue/article/category/7959476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lovelixue
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yangxiaoge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java 字节数组 序列化 与 C# 字节数组 序列化差异性</title>
    <link href="https://yangxiaoge.github.io/2018/08/16/2018-8-16-java%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%B8%8EC%E4%BA%95%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%AE%E5%BC%82%E6%80%A7/"/>
    <id>https://yangxiaoge.github.io/2018/08/16/2018-8-16-java字节数组与C井字节数组序列化差异性/</id>
    <published>2018-08-16T19:40:05.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WRAP）字符串；</p><p>因此： java 这边需要手动将 byte[] 转成  Base64字符串:<code>Base64.encodeToString(bytes, Base64.NO_WRAP);</code><br>java 我用的是 <code>Gson</code> 序列化， 客户的 .NET 代码用的是 <code>JsonConvert.SerializeObject(obj)</code>。</p><p><img src="https://img-blog.csdn.net/20180816185942460?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180816190114298?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WR
      
    
    </summary>
    
    
      <category term="byte" scheme="https://yangxiaoge.github.io/tags/byte/"/>
    
      <category term="C#" scheme="https://yangxiaoge.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据库获取 Android 短信</title>
    <link href="https://yangxiaoge.github.io/2018/08/14/2018-8-14-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%8F%96Android%E7%9F%AD%E4%BF%A1/"/>
    <id>https://yangxiaoge.github.io/2018/08/14/2018-8-14-数据库获取Android短信/</id>
    <published>2018-08-14T14:43:05.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读取短信需要的权限"><a href="#读取短信需要的权限" class="headerlink" title="读取短信需要的权限"></a>读取短信需要的权限</h3><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;</code></pre><h3 id="读取数据库短信方法"><a href="#读取数据库短信方法" class="headerlink" title="读取数据库短信方法"></a>读取数据库短信方法</h3><pre><code>   public static List&lt;Map&lt;String, String&gt;&gt; getSmsCode() {        String lastTime = &quot;1534228493681&quot;; // 时间        Log.i(&quot;SMSUtil&quot;, &quot;开始获取短信&quot;);        Cursor cursor = null;        // 添加异常捕捉        try {            //第一种， 查询所有短信            cursor = App.mContext.getContentResolver().query(                    Uri.parse(&quot;content://sms&quot;),                    new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;body&quot;, &quot;date&quot;, &quot;person&quot;, &quot;type&quot;},                    null, null, &quot;date desc&quot;);            //第二种， 通过查询条件， 例如：date &gt; lastTime， 过滤数据            /*cursor = App.mContext.getContentResolver().query(                        Uri.parse(&quot;content://sms&quot;),                        new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;body&quot;, &quot;date&quot;, &quot;person&quot;, &quot;type&quot;},                        &quot;date &gt; ?&quot;, new String[]{lastTime}, &quot;date desc&quot;);*/            if (cursor != null) {                List&lt;Map&lt;String, String&gt;&gt; smsList = new ArrayList&lt;&gt;();                while (cursor.moveToNext()) {                    String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));// 在这里获取短信信息                    String person = cursor.getString(cursor.getColumnIndex(&quot;person&quot;)); // 陌生人为null                    String address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));                    String _id = cursor.getString(cursor.getColumnIndex(&quot;_id&quot;));                    String date = cursor.getString(cursor.getColumnIndex(&quot;date&quot;));                    String type = cursor.getString(cursor.getColumnIndex(&quot;type&quot;));                    HashMap&lt;String, String&gt; smsMap = new HashMap&lt;&gt;();                    smsMap.put(&quot;body&quot;, body);                    smsMap.put(&quot;person&quot;, person);                    smsMap.put(&quot;address&quot;, address);                    smsMap.put(&quot;_id&quot;, _id);                    smsMap.put(&quot;date&quot;, date);                    smsList.add(smsMap);                    Log.i(&quot;test_sms&quot;, &quot;body = &quot; + body + &quot;  person = &quot; + person + &quot;  address = &quot; + address                            + &quot;  date = &quot; + date + &quot;  type = &quot; + type);                }                // 返回所有的短信                return smsList;            }        } catch (Exception e) {            e.printStackTrace();            Log.i(&quot;test_sms&quot;, &quot;e = &quot; + e.getMessage());        } finally {            if (cursor != null) {                cursor.close();            }        }        return null;    }</code></pre><h3 id="URI-主要有："><a href="#URI-主要有：" class="headerlink" title="URI 主要有："></a>URI 主要有：</h3><pre><code>content://sms/             所有短信 (本示例用的所有)content://sms/inbox        收件箱content://sms/sent         已发送content://sms/draft        草稿content://sms/outbox       发件箱content://sms/failed       发送失败content://sms/queued       待发送列表</code></pre><h3 id="SMS-主要结构："><a href="#SMS-主要结构：" class="headerlink" title="SMS 主要结构："></a>SMS 主要结构：</h3><pre><code>_id =&gt; 短消息序号 如 100  thread_id =&gt; 对话的序号 如 100  address =&gt; 发件人地址，手机号. 如 + 8613811810000  person =&gt; 发件人，返回一个数字就是联系人列表里的序号，陌生人为 null  date =&gt; 日期  long 型。如 1256539465022  protocol =&gt; 协议 0 SMS_RPOTO, 1 MMS_PROTO   read =&gt; 是否阅读 0 未读， 1 已读   status =&gt; 状态 -1 接收，0 complete, 64 pending, 128 failed   type =&gt; 类型 1 是接收到的，2 是已发出          (ALL    = 0; 所有    INBOX  = 1; 收件箱    SENT   = 2; 已发送    DRAFT  = 3; 草稿    OUTBOX = 4; 发件箱    FAILED = 5; 失败    QUEUED = 6;)待发送body =&gt; 短消息内容   service_center =&gt; 短信服务中心号码编号。如 + 8613800755500  </code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/ithomer/article/details/7328321" target="_blank" rel="noopener">https://blog.csdn.net/ithomer/article/details/7328321</a><br><a href="https://blog.csdn.net/laichao1112/article/details/6436511" target="_blank" rel="noopener">https://blog.csdn.net/laichao1112/article/details/6436511</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读取短信需要的权限&quot;&gt;&lt;a href=&quot;#读取短信需要的权限&quot; class=&quot;headerlink&quot; title=&quot;读取短信需要的权限&quot;&gt;&lt;/a&gt;读取短信需要的权限&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;
      
    
    </summary>
    
    
      <category term="AndroidSMS" scheme="https://yangxiaoge.github.io/tags/AndroidSMS/"/>
    
  </entry>
  
  <entry>
    <title>（译）为什么每个 Android 开发者都应该尝试 Flutter</title>
    <link href="https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/"/>
    <id>https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/</id>
    <published>2018-08-06T18:10:08.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f" target="_blank" rel="noopener">Why every Android Developer should try out Flutter</a></li><li>原文作者：<a href="https://proandroiddev.com/@aaronoe?source=post_header_lockup" target="_blank" rel="noopener">Aaron Oertel</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>掘金链接：<a href="https://juejin.im/post/5b5e70ffe51d4518e311b63d" target="_blank" rel="noopener">https://juejin.im/post/5b5e70ffe51d4518e311b63d</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md</a></li><li>译者：<a href="https://github.com/ALVINYEH" target="_blank" rel="noopener">ALVINYEH</a></li><li>校对者：<a href="https://github.com/DateBro" target="_blank" rel="noopener">DateBro</a></li></ul></blockquote><h1 id="为什么每个-Android-开发者都应该尝试-Flutter"><a href="#为什么每个-Android-开发者都应该尝试-Flutter" class="headerlink" title="为什么每个 Android 开发者都应该尝试 Flutter"></a>为什么每个 Android 开发者都应该尝试 Flutter</h1><p>几个月前，我写过一篇题为“<a href="https://juejin.im/post/5add65c46fb9a07aa541e97e" target="_blank" rel="noopener">为什么 Flutter 能最好地改变移动开发</a>”的文章。虽然已经过去了一段时间，但是我对 Flutter 的热爱依然非常强烈；事实上，当我继续使用它时，我意识到了我之前忽略了 Flutter 独特方面的重要性。不要误会我的意思 —— 我仍然认为 Flutter 最强大的一点就是如何解决跨平台开发的许多问题。但最近我开始关注移动开发发展的更多领域，特别是声明性用户界面的概念。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*pV87QzKfowqgkEkd" alt></p><p>摄影者：来自 <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Unsplash</a> 的 <a href="https://unsplash.com/@licole?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Chris Charles</a>。</p><p>我相信你已经听过一系列关于为什么 Android 开发者应该关注 Flutter 的若干论据（如果你还没有看过，请让我谦逊地建议你瞧瞧<a href="https://proandroiddev.com/why-flutter-will-change-mobile-development-for-the-best-c249f71fa63c" target="_blank" rel="noopener">这个</a>），但是我想指出一个我还没有真正解决的大问题，那就是 Flutter 可以让你对 App 开发有完全不同的看法。首先，你的应用本身将采用不同的方式构建 —— 但更重要的是，实际的 UI 开发通过将其合并到你的 Dart 代码（而不是 XML）中而被推到前台，因此使它成为了“一等公民”。一旦你的 UI 代码突然出现在一种非标记语言中，你就会意识到你突然有了构建应用的可能性。说实话，在使用 Flutter 之后，我开始讨厌在 Android 上编写 UI 代码；因为在 Android 中步骤更加繁琐，虽然你仍然可以使用数据绑定等工具构建响应式应用，但它实际上比 Flutter 中要花费更多的时间。</p><p>当你考虑在 Android 中整合动画和其他动态数据时，使用 Flutter 的论点变得更加有力。整合动画可能会不太方便，有时你可能不得不拒绝设计师的要求，因为要实现他们的需求太难了。谢天谢地，Flutter 改变了这一切。如果你一直在关注 Flutter，你可能已经从 <a href="https://medium.com/fluttery" target="_blank" rel="noopener">Fluttery</a> 听说过 <strong>Flutter 挑战</strong>。这些挑战展示了构建具有大量自定义组件和精美设计（包括动画）的复杂 UI 的快速和直观性。在 Android 上实现这样的东西会变得非常困难 —— 特别是因为与 Flutter 不同，Android 的视图基于继承而非组合，这使得构建视图变得更加复杂。</p><p>下面，让我们切入正题：使用 Flutter <strong>构建声明性 UI</strong>，这改变了 UI 开发的一切。现在也许你在想，<strong>Android 布局不也是以声明方式构建的吗？</strong>答案是肯定的，但事实不是。使用 XML 来定义布局让我们有了以声明方式定义布局的感觉，但如果你的视图是完全静态的，并且所有数据都是以 XML 格式设置的，那么这种感觉才真正成立。不幸的是，这种情况几乎从未发生过；一旦添加动态数据和类似列表之类的东西，你自然必须使用一些 Java / Kotlin 代码将数据绑定到视图。然后我们最终得到某种 ViewModel，它将数据设置为视图。想象一下，这就像在 Android 上调用 <code>textView.text =“Hello Medium！”</code> 一样。在 Flutter 上，这是完全不同的：你创建了一个包含某个状态的窗口组件类，然后根据该状态以声明方式定义你的布局。每当状态改变时，我们调用 <code>setState（）</code> 来重新渲染我们改变的组件树的部分。让我们看一下如何在 Flutter 中使用 API，并使用结果渲染一个 List：</p><pre><code>@overrideWidget build(BuildContext context) {  return new FutureBuilder&lt;Repositories&gt;(    future: apiClient.getUserRepositoriesFuture(username),    builder: (BuildContext context,         AsyncSnapshot&lt;Repositories&gt; snapshot) {      if (snapshot.hasError)        return new Center(child: new Text(&quot;Network error&quot;));      if (!snapshot.hasData)        return new Center(          child: new CircularProgressIndicator(),        );      return new ListView.builder(        itemCount: snapshot.data.nodes.length,        itemBuilder: (BuildContext context, int index) =&gt;            new RepoPreviewTile(              repository: snapshot.data.nodes[index],            ),      );    },  );}</code></pre><p>在这里，我们使用了 <code>FutureBuilder</code> 来等待网络调用（Future）的完成。一旦网络调用完成，出现结果或错误，<code>FutureBuilder</code> 组件会在内部调用 <code>setState</code> 来调用所提供的 <code>builder</code> 方法来重新渲染。正如你在这个例子中看到的，一切都是<strong>声明式的</strong>。在 Android 上做同样的事情通常需要一个被动的 XML 布局，然后需要一些其他类来手动设置状态，比如 Adapter 和视图模型。这种方法的问题在于，状态可能与屏幕上渲染的状态不同。这就是为什么我们希望拥有像 Flutter 为我们提供的那样的声明性布局。我们最终编写的代码要少得多，同时将状态绑定到要在屏幕上显示的内容。</p><p>有了这些声明性布局，我们也开始对架构进行了不同的思考。突然间，<strong>reactive</strong> 这个词出现了，我们谈论了更多的是关于状态管理的内容，而不是架构。有了 Flutter，像 MVP 和 MVVM 这样的架构已经没有多大有意义了；我们不再使用它们了，而是考虑状态如何流经我们的应用。状态突然成为讨论的一个重要部分，我们将投入越来越多精力去思考构建应用的新方法上。这对我们所有人来说都是一次新的旅程，有许多事情可以解决，但最重要的是，这是我们开阔视野的机会。</p><p>坦白地说，Flutter 也不只有阳光和彩虹。我目前正在与 Flutter 合作开展一个更大的项目来了解它的弱点，迄今为止我遇到的最大缺陷是缺乏基础设施。当我尝试使用 Graphql-API 时，这个问题就非常明显；虽然有库确实会这样做，但它们并没有接近 Android 与 Apollo 的关系。不过，好消息是，Flutter 迎头赶上只是时间的问题，在此期间扩展现有的库，甚至建立自己的库并不困难。请注意，你可能需要花一些时间投入在应用程序的基础设施中，而对于 Android 和 iOS 来说，情况通常并非如此 —— 毕竟，天下没有免费的午餐。</p><p>最后，我最近从使用 Flutter 中得到的最大启示之一就是，体验这种构建 UI 的声明方式以及它对状态管理的影响是非常有用的。我觉得 Flutter 太棒了；不过，我告诫你不要把它当作解决你所有问题的银弹，而应该是作为一种创新的工具，它可以比在 Android 上更快地构建漂亮的自定义 UI。更重要的是，它展示了强大的声明性布局功能，并让你将应用视为渲染状态，而不是非连贯性 Activity，视图和视图模型 —— 仅此而言，我强烈建议你尝试一下 Flutter。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Git clone 慢怎么办 - 配置代理</title>
    <link href="https://yangxiaoge.github.io/2018/08/03/2018-8-3-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>https://yangxiaoge.github.io/2018/08/03/2018-8-3-git配置代理/</id>
    <published>2018-08-03T17:23:35.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。</p><p>配置 Git 代理。</p><pre><code>// 查看当前代理设置git config --global http.proxy// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080git config --global http.proxy &#39;http://127.0.0.1:1080&#39;git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;/// 删除代理git config --global --unset http.proxy// 注意 `mac` 小飞机需要开启全局代理</code></pre><p>接下来尽情的使用 git 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。&lt;/p&gt;
&lt;p&gt;配置 Git 代理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看当前代理设置
git config --global http.proxy

      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何接入 VirtualAPK 插件框架</title>
    <link href="https://yangxiaoge.github.io/2018/07/25/2018-07-25%20-%20%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%20virtualapk%20%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    <id>https://yangxiaoge.github.io/2018/07/25/2018-07-25 - 如何接入 virtualapk 插件框架/</id>
    <published>2018-07-25T17:05:06.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/didi/VirtualAPK/raw/master/imgs/va.png" alt></p><p>封面图片来源: <a href="https://blog.csdn.net/byeweiyang/article/details/80127643" target="_blank" rel="noopener">https://blog.csdn.net/byeweiyang/article/details/80127643</a></p><p>话不多说，先上我的 Demo 地址：<a href="https://github.com/yangxiaoge/VirtualAPKDemo" target="_blank" rel="noopener">https://github.com/yangxiaoge/VirtualAPKDemo</a></p><p>本文转载：原文链接<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p>最近都在搞插件框架，为项目搭建用，之前集成了下阿里的 atlas，现在送上一篇滴滴的 virtualapk，就个人而言，滴滴的集成过程比阿里简单些，有兴趣的可以看看我 atlas 的：<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p><em>废话不多说，上过程</em></p><h3 id="1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写"><a href="#1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写" class="headerlink" title="1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写"></a>1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写</h3><p>1.1 新建一个工程，根目录的 build.gradle 里面</p><p>classpath ‘com.android.tools.build:gradle:3.0.0’</p><p>classpath ‘com.didi.virtualapk:gradle:0.9.8.4’</p><p>根目录 就配置这两个</p><p>1.2 在 app（宿主）目录下的 build.gradle 文件下添加</p><p>apply plugin: ‘com.didi.virtualapk.host’<br>在 dependencies 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>1.3 重点来了，通过 file，new module 的形式新建一个 module，然后我命名为 plugindemo，然后在 nodule.gradle 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>接着在末端添加</p><p>apply plugin: ‘com.didi.virtualapk.plugin’<br>virtualApk {<br>    // 插件资源表中的packageId，需要确保不同插件有不同的packageId.<br>    packageId = 0x6f             // The package id of Resources.<br>    // 宿主工程application模块的路径，插件的构建需要依赖这个路径<br>    targetHost=’../app’ // The path of application module in host project.<br>    //默认为true，如果插件有引用宿主的类，那么这个选项可以使得插件和宿主保持混淆一致<br>    applyHostMapping = true      // [Optional] Default value is true.<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725103642552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>基本 环境就到此为止了，接下来代码部分</p><h3 id="2-代码添加并验证"><a href="#2-代码添加并验证" class="headerlink" title="2. 代码添加并验证"></a>2. 代码添加并验证</h3><p>在 app 的 mainactivity 里面添加两个按钮，一个是跳转到 module 去的，一个是加载插件的</p><p>public void loadPlugin() {<br>    PluginManager pluginManager = PluginManager.getInstance(this);<br>    //此处是当查看插件apk是否存在,如果存在就去加载(比如修改线上的bug,把插件apk下载到sdcard的根目录下取名为plugin-release.apk)<br>    File apk = new File(Environment.getExternalStorageDirectory(), “plugin-release.apk”);<br>    if (apk.exists()) {<br>        try {<br>            pluginManager.loadPlugin(apk);<br>            Toast.makeText(this, “插件加载成功”, Toast.LENGTH_SHORT).show();<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>            Toast.makeText(this, “插件加载异常！”, Toast.LENGTH_SHORT).show();<br>        }<br>    }<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725104101299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这个时候跳转是不行的，接下来就需要加载插件了 ，首先需要生成插件 apk</p><p>官方文档是通过命令</p><p>gradle clean assemblePlugin来构建插件</p><p>如果不想这样，也可以通过直接 gradle 的来，具体如下<br><img src="https://img-blog.csdn.net/20180725104350857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这样 就生成插件 apk 了，同时官方文档介绍了下这个，就是只能生成 release 版本的，插件包位于 build 目录下<br><img src="https://img-blog.csdn.net/20180725104530319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>到这里 就可以结束验证了，点击加载插件，然后再点击跳转，你会发现可以跳转了，如果如果有帮助可以帮我点个赞或者 githup 上面 star 一下，谢谢，如果有问题，可以下面评论回复，一起学习探讨。下面贴上注意点</p><ol><li><p>集成环境一定要配置好</p></li><li><p>生成的插件包和加载的时候名字一定要一样</p></li><li><p>注意 SD 卡的权限</p></li></ol><p>贴上相关参考文档和我的 githup 代码</p><p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK</a></p><p><a href="https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88</a></p><p>github：<a href="https://github.com/sdgSnow/VirtualAPK" target="_blank" rel="noopener">https://github.com/sdgSnow/VirtualAPK</a></p><p>希望对大家有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/didi/VirtualAPK/raw/master/imgs/va.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;封面图片来源: &lt;a href=&quot;https://blog.csdn.net/byeweiyang/articl
      
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://yangxiaoge.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>锻炼身体从现在做起</title>
    <link href="https://yangxiaoge.github.io/2018/03/23/2018-3-23-%E9%94%BB%E7%82%BC%E8%BA%AB%E4%BD%93%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%81%9A%E8%B5%B7/"/>
    <id>https://yangxiaoge.github.io/2018/03/23/2018-3-23-锻炼身体从现在做起/</id>
    <published>2018-03-23T11:19:14.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- <a href="https://www.zhihu.com/question/22918787/answer/23166234" target="_blank" rel="noopener">杨小彻的回答 - 知乎 </a></p></blockquote><h3 id="上学"><a href="#上学" class="headerlink" title="上学"></a>上学</h3><p>我也是曾经瘦过的人，一度认为自己不会胖，上初高中一直都没有胖起来。于是我上了大学，入学时119斤173的个子，大学疯玩了4年，胡吃胡喝，毕业后我125斤😂</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>工作1年不到，长期坐着也不怎么运动，放假也不出门，十足的宅男。不用想肯定又胖了，emmm，130斤了Σ( °吓°|||)︴。</p><h3 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h3><p>交往我老婆以后，自己也不宅了，犹如一个没吃过东西的人，吃遍了各种以前没吃过的食物。她吃不完的我这人又舍不得浪费我就帮着消灭了（其实还是我能吃），再加上老婆烧的饭也很好吃，我就hold不住了。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>随着时间流逝，毕业快3年了，我体重飚到144斤了，啊五环～ 突然想唱这首歌🎤。呵，难道就是胖了就这么结束了？不，我还越来越黑了，由于从事it每天电脑相伴（我猜是这样的）。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>重点来了，在老婆的<code>劝导</code>下我要开始健身了，没错就是健身，不能任由自己这么胖下去了。既然事态发展到这步田地，箭在弦上不得不发了，不是我瘦就是健身房亡！社会社会|･ω･｀)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- &lt;a href=&quot;https://www.zhihu.com/question/22918787/answer/23166234&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Nice git log</title>
    <link href="https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/"/>
    <id>https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/</id>
    <published>2017-12-13T10:11:01.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。</p><p>开发中查看提交记录是家常便饭了，<code>git log</code> 命令是查看全部提交日志，<code>git log -2</code>  查看最近 2 次的提交日志，<code>git log -p</code>  查看历史纪录以来哪几行被修改，<code>git log --stat --summary</code> 查看每个版本变动的档案和行数。</p><p>Git 默认的 git log 是这样子的，emmmmmm….. 丑</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e2fcca990.png"></div><p>于是乎 Google 了一个 git 配置，打开终端，输入以下命令。</p><pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;  </code></pre><p>以后在终端输入 git lg，就能看到下面漂亮的 git log 了。</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e32602b21.png"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。&lt;/p&gt;
&lt;p&gt;开发中查看提交记录是家常便饭了，&lt;code&gt;git log&lt;/code&gt; 命令是查看全部提交日志，&lt;code&gt;git log -2&lt;/code&gt;  查看最近 2 次的提交日志，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android Launcher 界面添加未接来电/未读短信条数显示</title>
    <link href="https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-%E7%95%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E6%9C%AA%E6%8E%A5%E6%9D%A5%E7%94%B5-%E6%9C%AA%E8%AF%BB%E7%9F%AD%E4%BF%A1%E6%9D%A1%E6%95%B0%E6%98%BE%E7%A4%BA/"/>
    <id>https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-界面添加未接来电-未读短信条数显示/</id>
    <published>2017-10-19T16:00:50.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Thumbnail by <a href="https://octiviotti.deviantart.com/" target="_blank" rel="noopener">octiviotti</a></p></blockquote><p>本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。</p><p>涉及到几个文件：<br><a id="more"></a></p><ol><li>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</li><li>packages/apps/Launcher3/src/com/android/launcher3/Utilities.java</li><li>packages/apps/Launcher3/AndroidManifest.xml </li></ol><p>具体的思路：<code>Launcher</code> 中注册 <code>ContentObserver</code> 来监听短信和电话数据库，当数据发生变化时，读取读取数据库未读数目之后通过 ICON_NAME ，<code>重新绘制</code>短信，电话的图标（在原图右上角画圆和数字）。</p><hr><p>具体代码：</p><h3 id="1-Launcher-java"><a href="#1-Launcher-java" class="headerlink" title="1. Launcher.java"></a>1. Launcher.java</h3><ul><li>首先是定义两个 ContentObserver</li></ul><pre><code>private final static int UPDATE_MMS_ICON = 826;  private final static int UPDATE_CALL_ICON = 1206;public class SMSContentObserver extends ContentObserver {    private Handler mHandler;    public SMSContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;SMSContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_MMS_ICON);        Message msg = mHandler.obtainMessage(UPDATE_MMS_ICON);        msg.obj = getMissMmsCount();        mHandler.sendMessage(msg);    }}public class CallContentObserver extends ContentObserver {    private Handler mHandler;    public CallContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;CallContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_CALL_ICON);        Message msg = mHandler.obtainMessage(UPDATE_CALL_ICON);        msg.obj = getMissCallCount();        mHandler.sendMessage(msg);    }}</code></pre><ul><li>在 onCreate() 中注册 ContentObserver</li></ul><pre><code>private SMSContentObserver smsContentObserver = null;  private CallContentObserver callContentObserver = null;  smsContentObserver = new SMSContentObserver(this,mHandler);callContentObserver =new CallContentObserver(this,mHandler);getContentResolver().registerContentObserver(Calls.CONTENT_URI,true,callContentObserver);getContentResolver().registerContentObserver(Uri.parse(&quot;content://mms-sms/&quot;),true,smsContentObserver);</code></pre><ul><li>定义两个 ICON_NAME</li></ul><pre><code>// 这两个 ICON_NAME 根据自己实际系统短信和电话页面对应包名填写private final static String PHONE_ICON_NAME = &quot;com.android.dialer.DialtactsActivity&quot;;private final static String MMS_ICON_NAME = &quot;com.android.messaging.ui.conversationlist.ConversationListActivity&quot;;</code></pre><ul><li>mHandler 中处理</li></ul><pre><code>@Thunkfinal Handler mHandler = new Handler(new Handler.Callback() {    @Override    public boolean handleMessage(Message msg) {        Log.i(&quot;Launcher-&quot;,&quot;mHandler msg.what = &quot; + msg.what);        if (msg.what == ADVANCE_MSG) {            int i = 0;            for (View key : mWidgetsToAdvance.keySet()) {                final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);                final int delay = mAdvanceStagger * i;                if (v instanceof Advanceable) {                    mHandler.postDelayed(new Runnable() {                        public void run() {                            ((Advanceable) v).advance();                        }                    }, delay);                }                i++;            }            sendAdvanceMessage(mAdvanceInterval);        }        //ADD BY Bruce Yang FOR SHOW UNREAD MMS        else if (msg.what == UPDATE_MMS_ICON) {            setMmsOrPhoneNum(MMS_ICON_NAME, getMissMmsCount());        } else if (msg.what == UPDATE_CALL_ICON) {            setMmsOrPhoneNum(PHONE_ICON_NAME, getMissCallCount());        }        return true;    }});</code></pre><ul><li>获取数据库中未读数目</li></ul><pre><code> private int getMissMmsCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount&quot;);    int missSmsCount = 0;    Cursor cursorSMS = null;    Cursor cursorMMS = null;    try {        cursorSMS = getContentResolver().query(                Uri.parse(&quot;content://sms&quot;), null, &quot;(read=0 and type=1)&quot;,                null, null);        cursorMMS = getContentResolver().query(                Uri.parse(&quot;content://mms&quot;), null, &quot;(read=0)&quot;, null,                null);    } catch (SQLiteException e) {        return missSmsCount;    }    if (cursorSMS != null) {        missSmsCount = cursorSMS.getCount();        cursorSMS.close();    }    if (cursorMMS != null) {            missSmsCount = missSmsCount + cursorMMS.getCount();        cursorMMS.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount  missSmsCount = &quot; + missSmsCount);    return missSmsCount;}private int getMissCallCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount&quot;);    int missCallCount = 0;    Uri missingCallUri = Calls.CONTENT_URI;    String where = Calls.TYPE + &quot;=&#39;&quot; + Calls.MISSED_TYPE + &quot;&#39;&quot;            + &quot; AND new=1&quot;;    Cursor cursorCall = null;    try {        cursorCall = getContentResolver().query(missingCallUri,                null, where, null, null);    } catch (SQLiteException e) {        return missCallCount;    }    if (cursorCall != null) {        missCallCount = cursorCall.getCount();        cursorCall.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount  missCallCount = &quot; + missCallCount);    return missCallCount;}</code></pre><ul><li>设置 ICON 未读数</li></ul><pre><code>/**    *    * @param flag 更新电话或短信 ICON    * @param missCount 未读数*/private void setMmsOrPhoneNum(final String flag, final int missCount) {    Log.i(&quot;Launcher-&quot;,&quot;flag = &quot;+flag +&quot; missCount = &quot;+missCount);    if(mWorkspace == null) return;    ArrayList&lt;CellLayout&gt; cellLayouts = mWorkspace.getWorkspaceAndHotseatCellLayouts();    for (final CellLayout layoutParent: cellLayouts) {        final ViewGroup shortcutAndWidgetContainer = layoutParent.getShortcutsAndWidgets();        mWorkspace.post(new Runnable() {            public void run() {                int childCount = shortcutAndWidgetContainer.getChildCount();                for (int j = 0; j &lt;childCount; j++) {                    View view = shortcutAndWidgetContainer.getChildAt(j);                    Object tag = view.getTag();                    if (tag instanceof ShortcutInfo) {                        final ShortcutInfo info = (ShortcutInfo) tag;                        final Intent intent = info.intent;                        if (intent != null) {                            final ComponentName name = intent.getComponent();                            if (name != null &amp;&amp; name.getClassName().equals(flag)) {                                BubbleTextView bv = (BubbleTextView) view;                                Bitmap defaultIconBitmap = Bitmap.createBitmap(info.getIcon(mIconCache));                                Bitmap bitmap = Utilities.createIconBitmap(defaultIconBitmap, missCount);                                bv.setCompoundDrawablesWithIntrinsicBounds(null,                                        new FastBitmapDrawable(bitmap),                                        null, null);                            }                        }                    }                }            }        });    }}</code></pre><ul><li>第一次启动 Launcher 就能获取未读数目，在 finishBindingItems() 添加逻辑</li></ul><pre><code>//ADD BY Bruce Yangint missCall = getMissCallCount();int missMms = getMissMmsCount();if(missCall != 0) {    setMmsOrPhoneNum(PHONE_ICON_NAME, missCall);}if(missMms != 0) {    setMmsOrPhoneNum(MMS_ICON_NAME, missMms);}</code></pre><ul><li>在 onDestroy() 中反注册 ContentObserver</li></ul><pre><code>getContentResolver().unregisterContentObserver(smsContentObserver);getContentResolver().unregisterContentObserver(callContentObserver);</code></pre><h3 id="2-Utilities-java"><a href="#2-Utilities-java" class="headerlink" title="2. Utilities.java"></a>2. Utilities.java</h3><p>新增构造方法，用于重新绘制带数字的应用图标。</p><pre><code>//add by Bruce Yang for ...static Bitmap createIconBitmap(Bitmap b, int count) {    Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888,true);    Log.i(&quot;Launcher-&quot;,&quot;b.isMutable() = &quot;+b.isMutable()); // 如果为 false 就会抛出 java.lang.IllegalStateException 异常， http://bbs.csdn.net/topics/370021698    if (count == 0) return b;    int textureWidth = bitmap.getWidth();    final Canvas canvas = sCanvas;    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    canvas.setBitmap(bitmap);    paint.setColor(Color.RED);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    paint.setColor(Color.WHITE);    paint.setStyle(Paint.Style.STROKE);    paint.setStrokeWidth(2);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    Paint countPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    countPaint.setColor(Color.WHITE);    countPaint.setTextSize(26f);    countPaint.setTypeface(Typeface.DEFAULT_BOLD);    float x = textureWidth - 24-4;    if (count &gt; 9) x -= 4+6;    if (count &gt; 99) {        countPaint.setTextSize(22f);        String text = String.valueOf(99) + &quot;+&quot;;        canvas.drawText(text, x-2, 25+5, countPaint);    } else {        String text = String.valueOf(count);        canvas.drawText(text,x, 25+5, countPaint);    }    return bitmap;}</code></pre><h3 id="3-AndroidManifest-xml"><a href="#3-AndroidManifest-xml" class="headerlink" title="3. AndroidManifest.xml"></a>3. AndroidManifest.xml</h3><p>添加如下两个权限，由于 Android 6.0 以上需要动态权限申请，这里为了直接获取权限，可以将 targetSdkVersion 改成 21（原来是 23）。</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot; /&gt;</code></pre><h3 id="4-修改对比"><a href="#4-修改对比" class="headerlink" title="4. 修改对比"></a>4. 修改对比</h3><blockquote><p>修改前：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e865f6b26df.png" width="270" height="480"></p><blockquote><p>修改后：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e86659672b9.png" width="270" height="480"></p><blockquote><p>参考文章： </p></blockquote><p><a href="http://blog.csdn.net/chenxiong668/article/details/12851357" target="_blank" rel="noopener">http://blog.csdn.net/chenxiong668/article/details/12851357</a><br><a href="http://blog.csdn.net/kerancsdn/article/details/26705767" target="_blank" rel="noopener">http://blog.csdn.net/kerancsdn/article/details/26705767</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Thumbnail by &lt;a href=&quot;https://octiviotti.deviantart.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;octiviotti&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。&lt;/p&gt;
&lt;p&gt;涉及到几个文件：&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从 0 搭建直播系统</title>
    <link href="https://yangxiaoge.github.io/2017/09/12/2017-09-12-%E4%BB%8E-0-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/</id>
    <published>2017-09-12T15:45:18.000Z</published>
    <updated>2017-10-12T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个直播的 Demo，今天正好看到<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统</a>，索性就把我自己的搭(折)建(腾)过程做一个记录。<br><a id="more"></a><br>搭建流程：</p><blockquote><p>服务器系统：Ubuntu 16.10 系统<br>推流，拉流系统：Win 7, Android</p></blockquote><p>一个简易的直播系统，大致可以由三部分组成（详情见<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋博客</a>）：</p><ul><li>搭建一个 rtmp 媒体服务器：这里使用 srs，链接为：<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li>推流端：这里使用 obs，链接为：<a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a></li><li>拉流端：这里使用播放器 vlc，链接为：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></li></ul><h3 id="使用第三方-SDK-推流"><a href="#使用第三方-SDK-推流" class="headerlink" title="使用第三方 SDK 推流"></a>使用第三方 SDK 推流</h3><p>这里以百度云的直播 SDK 为例，下载地址：<br><a href="https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E" target="_blank" rel="noopener">https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E</a></p><p>修改推流地址之后上传到了我的 <a href="https://github.com/yangxiaoge/PushFlowLive" target="_blank" rel="noopener">PushFlowLive</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/baidu-livecamera-%E6%8E%A8%E6%B5%81.apk" target="_blank" rel="noopener">apk 下载</a></p><h3 id="使用开源项目推流"><a href="#使用开源项目推流" class="headerlink" title="使用开源项目推流"></a>使用开源项目推流</h3><p>使用一个开源项目：</p><blockquote><p><a href="https://github.com/begeekmyfriend/yasea" target="_blank" rel="noopener">https://github.com/begeekmyfriend/yasea</a></p></blockquote><blockquote><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/yasea-推流.apk" target="_blank" rel="noopener">apk 下载</a></p></blockquote><h3 id="利用-ffmpeg-推流"><a href="#利用-ffmpeg-推流" class="headerlink" title="利用 ffmpeg 推流"></a>利用 ffmpeg 推流</h3><blockquote><p>详情见鸿洋博客</p></blockquote><p>大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。</p><p>这里，由于篇幅，我们就直接使用别人编好的项目了。</p><p><a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="noopener">https://github.com/WritingMinds/ffmpeg-android-java</a></p><p><strong><em>搭建过程截图</em></strong>：<br>直播步骤：1，开启rtmp 媒体服务器 2，推流（推流客户端，apk等） 3，拉流（vlc等）<br><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-43.jpg" alt></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-51.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-57.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-02.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-04.jpg" alt></p><blockquote><p>封面小黄人动图来自 <a href="https://giphy.com/search/new-follower" target="_blank" rel="noopener">giphy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想搞个直播的 Demo，今天正好看到&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/77937483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统&lt;/a&gt;，索性就把我自己的搭(折)建(腾)过程做一个记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="直播" scheme="https://yangxiaoge.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的 Android Framework</title>
    <link href="https://yangxiaoge.github.io/2017/09/05/2017-09-05-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-Android-Framework/"/>
    <id>https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/</id>
    <published>2017-09-05T14:16:37.000Z</published>
    <updated>2019-03-21T08:44:17.578Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— <code>前言</code><br><a id="more"></a></p><blockquote><p>本文转自 <a href="https://juejin.im/post/586da43b1b69e60062cb8a4f" target="_blank" rel="noopener">墨镜猫</a>，通俗有趣的文笔</p></blockquote><div align="center"><img src="https://github.com/yangxiaoge/PersonResources/blob/bfd168d0f60a7fa8b11ad50cdc53694c77d90bd9/Android/Android%20Framework.jpg?raw=true"></div><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含以下类：</p><ul><li>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。</li><li>Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。</li><li>PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。</li><li>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。</li><li>DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。</li><li>ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。</li></ul><h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><p>Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。</p><p>每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。</p><h3 id="从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的</h3><p>ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。</p><p>接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。</p><p><strong><em>很多线程是不是很晕？</em></strong></p><ol><li>安卓程序中都有哪些线程？</li></ol><p>客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。</p><ol start="2"><li>UI 线程是什么？</li></ol><p>一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p><ol start="3"><li>自定义的线程和 UI 线程有什么区别？</li></ol><p>UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— &lt;code&gt;前言&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Framework" scheme="https://yangxiaoge.github.io/tags/Framework/"/>
    
  </entry>
  
</feed>
