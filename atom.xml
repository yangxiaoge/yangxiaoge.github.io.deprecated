<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>珠珠のBlog</title>
  <icon>https://www.gravatar.com/avatar/4ec65d784d203bac0fd2da7375835dff</icon>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangxiaoge.github.io/"/>
  <updated>2019-02-28T10:48:36.240Z</updated>
  <id>https://yangxiaoge.github.io/</id>
  
  <author>
    <name>Bruce Yang</name>
    <email>yang.jianan0926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter_Go 代码开发规范 - alibaba</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go 代码开发规范/</id>
    <published>2019-02-28T10:27:22.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">Flutter Go 开发规范第一版</a></li><li>原文作者：<a href="https://github.com/alibaba" target="_blank" rel="noopener">alibaba</a></li></ul></blockquote><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="标识符三种类型"><a href="#标识符三种类型" class="headerlink" title="标识符三种类型"></a>标识符三种类型</h3><h4 id="大驼峰"><a href="#大驼峰" class="headerlink" title="大驼峰"></a>大驼峰</h4><p>类、枚举、typedef和类型参数</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliderMenu</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">typedef Predicate = <span class="keyword">bool</span> <span class="function"><span class="keyword">Function</span>&lt;<span class="title">T</span>&gt;<span class="params">(T value)</span></span>;</span><br></pre></td></tr></table></figure><p>包括用于元数据注释的类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Foo([arg]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo(anArg)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="使用小写加下划线来命名库和源文件"><a href="#使用小写加下划线来命名库和源文件" class="headerlink" title="使用小写加下划线来命名库和源文件"></a>使用小写加下划线来命名库和源文件</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> peg_parser.source_scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'file_system.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'slider_menu.dart'</span>;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> pegparser.SourceScanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'file-system.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'SliderMenu.dart'</span>;</span><br></pre></td></tr></table></figure><h4 id="使用小写加下划线来命名导入前缀"><a href="#使用小写加下划线来命名导入前缀" class="headerlink" title="使用小写加下划线来命名导入前缀"></a>使用小写加下划线来命名导入前缀</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:angular_components/angular_components'</span></span><br><span class="line">    <span class="keyword">as</span> angular_components;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:js/js.dart'</span> <span class="keyword">as</span> js;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> <span class="built_in">Math</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:angular_components/angular_components'</span></span><br><span class="line">    <span class="keyword">as</span> angularComponents;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:js/js.dart'</span> <span class="keyword">as</span> JS;</span><br></pre></td></tr></table></figure><h4 id="使用小驼峰法命名其他标识符"><a href="#使用小驼峰法命名其他标识符" class="headerlink" title="使用小驼峰法命名其他标识符"></a>使用小驼峰法命名其他标识符</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"></span><br><span class="line">HttpRequest httpRequest;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">align</span>(<span class="params"><span class="keyword">bool</span> clearItems</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先使用小驼峰法作为常量命名"><a href="#优先使用小驼峰法作为常量命名" class="headerlink" title="优先使用小驼峰法作为常量命名"></a>优先使用小驼峰法作为常量命名</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> defaultTimeout = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">final</span> urlScheme = <span class="built_in">RegExp</span>(<span class="string">'^([a-z]+):'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> numberGenerator = Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> DefaultTimeout = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">final</span> URL_SCHEME = <span class="built_in">RegExp</span>(<span class="string">'^([a-z]+):'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> NUMBER_GENERATOR = Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不使用前缀字母"><a href="#不使用前缀字母" class="headerlink" title="不使用前缀字母"></a>不使用前缀字母</h4><p>因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">defaultTimeout</span></span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kDefaultTimeout</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p><h4 id="在其他引入之前引入所需的dart库"><a href="#在其他引入之前引入所需的dart库" class="headerlink" title="在其他引入之前引入所需的dart库"></a>在其他引入之前引入所需的dart库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:bar/bar.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:foo/foo.dart'</span>;</span><br></pre></td></tr></table></figure><h4 id="在相对引入之前先引入在包中的库"><a href="#在相对引入之前先引入在包中的库" class="headerlink" title="在相对引入之前先引入在包中的库"></a>在相对引入之前先引入在包中的库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:bar/bar.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:foo/foo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'util.dart'</span>;</span><br></pre></td></tr></table></figure><h4 id="第三方包的导入先于其他包"><a href="#第三方包的导入先于其他包" class="headerlink" title="第三方包的导入先于其他包"></a>第三方包的导入先于其他包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:bar/bar.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:foo/foo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:my_package/util.dart'</span>;</span><br></pre></td></tr></table></figure><h4 id="在所有导入之后，在单独的部分中指定导出"><a href="#在所有导入之后，在单独的部分中指定导出" class="headerlink" title="在所有导入之后，在单独的部分中指定导出"></a>在所有导入之后，在单独的部分中指定导出</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'src/error.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'src/foo_bar.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/error.dart'</span>;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'src/error.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'src/error.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'src/foo_bar.dart'</span>;</span><br></pre></td></tr></table></figure><h3 id="所有流控制结构，请使用大括号"><a href="#所有流控制结构，请使用大括号" class="headerlink" title="所有流控制结构，请使用大括号"></a>所有流控制结构，请使用大括号</h3><p>这样做可以避免悬浮的else问题</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWeekDay) &#123;</span><br><span class="line">  <span class="keyword">print</span>('Bike to work!');</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">print</span>('Go dancing or read a book!');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arg == <span class="built_in">null</span>) <span class="keyword">return</span> defaultValue;</span><br></pre></td></tr></table></figure><p>如果流程体超出了一行需要分划请使用大括号：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (overflowChars != other.overflowChars) &#123;</span><br><span class="line">  <span class="keyword">return</span> overflowChars &lt; other.overflowChars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (overflowChars != other.overflowChars)</span><br><span class="line">  <span class="keyword">return</span> overflowChars &lt; other.overflowChars;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="要像句子一样格式化"><a href="#要像句子一样格式化" class="headerlink" title="要像句子一样格式化"></a>要像句子一样格式化</h3><p>除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(name) &#123;</span><br><span class="line">  <span class="comment">// Assume we have a valid name.</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hi, <span class="subst">$name</span>!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(name) &#123;</span><br><span class="line">  <span class="comment">/* Assume we have a valid name. */</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Hi, <span class="subst">$name</span>!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用//</p><h3 id="Doc注释"><a href="#Doc注释" class="headerlink" title="Doc注释"></a>Doc注释</h3><p>使用///文档注释来记录成员和类型。</p><p>使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// The number <span class="keyword">of</span> characters in this chunk <span class="keyword">when</span> unsplit.</span><br><span class="line">int get length =&gt; ...</span><br></pre></td></tr></table></figure><blockquote><p>由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/<strong>…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/</strong>和<em>/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用</em>标记列表项的项目符号列表。</p></blockquote><h3 id="考虑为私有api编写文档注释"><a href="#考虑为私有api编写文档注释" class="headerlink" title="考虑为私有api编写文档注释"></a>考虑为私有api编写文档注释</h3><p>Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员</p><h4 id="用一句话总结开始doc注释"><a href="#用一句话总结开始doc注释" class="headerlink" title="用一句话总结开始doc注释"></a>用一句话总结开始doc注释</h4><p>以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Deletes the file at [path] from the file system.</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">delete</span>(<span class="keyword">String</span> path) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Depending on the state of the file system <span class="keyword">and</span> the use<span class="string">r's permissions,</span></span><br><span class="line"><span class="string">/// certain operations may or may not be possible. If there is no file at</span></span><br><span class="line"><span class="string">/// [path] or it can'</span>t be accessed, this function throws either [IOError]</span><br><span class="line">/// <span class="keyword">or</span> [PermissionError], respectively. Otherwise, this deletes the file.</span><br><span class="line">void delete(String path) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="“doc注释”的第一句话分隔成自己的段落"><a href="#“doc注释”的第一句话分隔成自己的段落" class="headerlink" title="“doc注释”的第一句话分隔成自己的段落"></a>“doc注释”的第一句话分隔成自己的段落</h4><p>在第一个句子之后添加一个空行，把它分成自己的段落</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Deletes the file at [path].</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Throws an [IOError] if the file could not be found. Throws a</span></span><br><span class="line"><span class="comment">/// [PermissionError] if the file is present but could not be deleted.</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">delete</span>(<span class="keyword">String</span> path) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flutter-Go-使用参考"><a href="#Flutter-Go-使用参考" class="headerlink" title="Flutter_Go 使用参考"></a>Flutter_Go 使用参考</h2><h3 id="库的引用"><a href="#库的引用" class="headerlink" title="库的引用"></a>库的引用</h3><p>flutter go 中，导入lib下文件库，统一指定包名，避免过多的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">package:flutter_go/</span><br></pre></td></tr></table></figure></p><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="使用相邻字符串连接字符串文字"><a href="#使用相邻字符串连接字符串文字" class="headerlink" title="使用相邻字符串连接字符串文字"></a>使用相邻字符串连接字符串文字</h4><p>如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raiseAlarm(</span><br><span class="line">    <span class="comment">'ERROR: Parts of the spaceship are on fire. Other '</span></span><br><span class="line">    <span class="comment">'parts are overrun by martians. Unclear which are which.');</span></span><br></pre></td></tr></table></figure><p>不推荐如下写法:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raiseAlarm(<span class="comment">'ERROR: Parts of the spaceship are on fire. Other ' +</span></span><br><span class="line">    <span class="comment">'parts are overrun by martians. Unclear which are which.');</span></span><br></pre></td></tr></table></figure><h4 id="优先使用模板字符串"><a href="#优先使用模板字符串" class="headerlink" title="优先使用模板字符串"></a>优先使用模板字符串</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hello, <span class="subst">$name</span>! You are <span class="subst">$&#123;year - birth&#125;</span> years old.'</span>;</span><br></pre></td></tr></table></figure><h4 id="在不需要的时候，避免使用花括号"><a href="#在不需要的时候，避免使用花括号" class="headerlink" title="在不需要的时候，避免使用花括号"></a>在不需要的时候，避免使用花括号</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hi, <span class="subst">$name</span>!'</span></span><br><span class="line"><span class="string">"Wear your wildest <span class="subst">$decade</span>'s outfit."</span></span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hello, '</span> + <span class="built_in">name</span> + <span class="string">'! You are '</span> + (year - birth).<span class="built_in">toString</span>() + <span class="string">' y...'</span>;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hi, <span class="subst">$&#123;name&#125;</span>!'</span></span><br><span class="line"><span class="string">"Wear your wildest <span class="subst">$&#123;decade&#125;</span>'s outfit."</span></span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="尽可能使用集合字面量"><a href="#尽可能使用集合字面量" class="headerlink" title="尽可能使用集合字面量"></a>尽可能使用集合字面量</h4><p>如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var points</span> = [];</span><br><span class="line"><span class="attribute">var addresses</span> = &#123;&#125;;</span><br><span class="line"><span class="attribute">var lines</span> = &lt;Lines&gt;[];</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> points = <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">var</span> addresses = <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure><h4 id="不要使用-length查看集合是否为空"><a href="#不要使用-length查看集合是否为空" class="headerlink" title="不要使用.length查看集合是否为空"></a>不要使用.length查看集合是否为空</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lunchBox.isEmpty) <span class="keyword">return</span> <span class="string">'so hungry...'</span>;</span><br><span class="line"><span class="keyword">if</span> (words.isNotEmpty) <span class="keyword">return</span> words.join(<span class="string">' '</span>);</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lunchBox.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'so hungry...'</span>;</span><br><span class="line"><span class="keyword">if</span> (!words.isEmpty) <span class="keyword">return</span> words.join(<span class="string">' '</span>);</span><br></pre></td></tr></table></figure><h4 id="考虑使用高阶方法转换序列"><a href="#考虑使用高阶方法转换序列" class="headerlink" title="考虑使用高阶方法转换序列"></a>考虑使用高阶方法转换序列</h4><p>如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var aquaticNames = animals</span><br><span class="line">    .where(<span class="function"><span class="params">(animal)</span> =&gt;</span> animal.isAquatic)</span><br><span class="line">    .map(<span class="function"><span class="params">(animal)</span> =&gt;</span> animal.name);</span><br></pre></td></tr></table></figure><h4 id="避免使用带有函数字面量的Iterable-forEach"><a href="#避免使用带有函数字面量的Iterable-forEach" class="headerlink" title="避免使用带有函数字面量的Iterable.forEach()"></a>避免使用带有函数字面量的Iterable.forEach()</h4><p>在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="selector-tag">var</span> person <span class="keyword">in</span> people) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">people</span><span class="selector-class">.forEach</span>((person) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="不要使用List-from-，除非打算更改结果的类型"><a href="#不要使用List-from-，除非打算更改结果的类型" class="headerlink" title="不要使用List.from()，除非打算更改结果的类型"></a>不要使用List.from()，除非打算更改结果的类型</h4><p>给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> copy1 = iterable.toList();</span><br><span class="line"><span class="keyword">var</span> copy2 = List.<span class="keyword">from</span>(iterable);</span><br></pre></td></tr></table></figure><p>明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a List&lt;int&gt;:</span></span><br><span class="line">var iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints "List&lt;int&gt;":</span></span><br><span class="line">print(iterable.toList().runtimeType);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a List&lt;int&gt;:</span></span><br><span class="line"><span class="keyword">var</span> iterable = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints "List&lt;dynamic&gt;":</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">List</span>.from(iterable).runtimeType);</span><br></pre></td></tr></table></figure><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><h4 id="使用-将命名参数与其默认值分割开"><a href="#使用-将命名参数与其默认值分割开" class="headerlink" title="使用=将命名参数与其默认值分割开"></a>使用=将命名参数与其默认值分割开</h4><p>由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">insert</span>(<span class="keyword">Object</span> item, &#123;<span class="built_in">int</span> <span class="keyword">at</span> = <span class="number">0</span>&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">insert</span>(<span class="keyword">Object</span> item, &#123;<span class="built_in">int</span> <span class="keyword">at</span>: <span class="number">0</span>&#125;) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="不要使用显式默认值null"><a href="#不要使用显式默认值null" class="headerlink" title="不要使用显式默认值null"></a>不要使用显式默认值null</h4><p>如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">([String message])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stderr</span>.write(message ?? <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">([String message = null])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">stderr</span>.write(message ?? <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="不要显式地将变量初始化为空"><a href="#不要显式地将变量初始化为空" class="headerlink" title="不要显式地将变量初始化为空"></a>不要显式地将变量初始化为空</h4><p>在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _nextId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LazyId &#123;</span><br><span class="line">  <span class="keyword">int</span> _<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> get <span class="keyword">id</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextId == null) _nextId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_<span class="keyword">id</span> == null) _<span class="keyword">id</span> = _nextId++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _<span class="keyword">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐如下写法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _nextId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LazyId</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> _id = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">get</span> id &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextId == <span class="literal">null</span>) _nextId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_id == <span class="literal">null</span>) _id = _nextId++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免储存你能计算的东西"><a href="#避免储存你能计算的东西" class="headerlink" title="避免储存你能计算的东西"></a>避免储存你能计算的东西</h4><p>在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们:</p><p>应该避免的写法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">  num radius;</span><br><span class="line">  num area;</span><br><span class="line">  num circumference;</span><br><span class="line"></span><br><span class="line">  Circle(num radius)</span><br><span class="line">      :<span class="built_in"> radius </span>= radius,</span><br><span class="line">       <span class="built_in"> area </span>= pi *<span class="built_in"> radius </span>* radius,</span><br><span class="line">        circumference = pi * 2.0 * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码问题：</p><ul><li>浪费内存</li><li>缓存的问题是无效——如何知道何时缓存过期需要重新计算？</li></ul><p>推荐的写法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">  num radius;</span><br><span class="line"></span><br><span class="line">  Circle(this.radius);</span><br><span class="line"></span><br><span class="line">  num <span class="builtin-name">get</span><span class="built_in"> area </span>=&gt; pi *<span class="built_in"> radius </span>* radius;</span><br><span class="line">  num <span class="builtin-name">get</span> circumference =&gt; pi * 2.0 * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="不要把不必要地将字段包装在getter和setter中"><a href="#不要把不必要地将字段包装在getter和setter中" class="headerlink" title="不要把不必要地将字段包装在getter和setter中"></a>不要把不必要地将字段包装在getter和setter中</h4><p>不推荐如下写法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> _contents;</span><br><span class="line">  <span class="keyword">get</span> contents =&gt; _contents;</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">contents</span>(<span class="params"><span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    _contents = <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先使用final字段来创建只读属性"><a href="#优先使用final字段来创建只读属性" class="headerlink" title="优先使用final字段来创建只读属性"></a>优先使用final字段来创建只读属性</h4><p>尤其对于 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 在不需要的时候不要用this</span><br><span class="line"></span><br><span class="line">不推荐如下写法：</span><br></pre></td></tr></table></figure></p><p>  class Box {<br>    var value;</p><pre><code>void clear() {  this.update(null);}void update(value) {  this.value = value;}</code></pre><p>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐如下写法：</span><br></pre></td></tr></table></figure></p><p>  class Box {<br>    var value;</p><pre><code>void clear() {  update(null);}void update(value) {  this.value = value;}</code></pre><p>  }<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 构造函数</span><br><span class="line"></span><br><span class="line">#### 尽可能使用初始化的形式</span><br><span class="line"></span><br><span class="line">不推荐如下写法：</span><br></pre></td></tr></table></figure></p><p>  class Point {<br>    num x, y;<br>    Point(num x, num y) {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐如下写法：</span><br></pre></td></tr></table></figure></p><p>class Point {<br>  num x, y;<br>  Point(this.x, this.y);<br>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 不要使用new</span><br><span class="line"></span><br><span class="line">Dart2使new 关键字可选</span><br><span class="line"></span><br><span class="line">推荐写法：</span><br></pre></td></tr></table></figure></p><p>  Widget build(BuildContext context) {<br>    return Row(<br>      children: [<br>        RaisedButton(<br>          child: Text(‘Increment’),<br>        ),<br>        Text(‘Click!’),<br>      ],<br>    );<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不推荐如下写法：</span><br></pre></td></tr></table></figure></p><p>  Widget build(BuildContext context) {<br>    return new Row(<br>      children: [<br>        new RaisedButton(<br>          child: new Text(‘Increment’),<br>        ),<br>        new Text(‘Click!’),<br>      ],<br>    );<br>  }<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 异步</span><br><span class="line"></span><br><span class="line">#### 优先使用async/await代替原始的futures</span><br><span class="line"></span><br><span class="line">async/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。</span><br></pre></td></tr></table></figure></p><p>  Future<int> countActivePlayers(String teamName) async {<br>    try {<br>      var team = await downloadTeam(teamName);<br>      if (team == null) return 0;</int></p><pre><code>  var players = await team.roster;  return players.where((player) =&gt; player.isActive).length;} catch (e) {  log.error(e);  return 0;}</code></pre><p>  }<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 当异步没有任何用处时，不要使用它</span><br><span class="line"></span><br><span class="line">如果可以在不改变函数行为的情况下省略异步，那么就这样做。、</span><br></pre></td></tr></table></figure></p><p>  Future afterTwoThings(Future first, Future second) {<br>    return Future.wait([first, second]);<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不推荐写法：</span><br></pre></td></tr></table></figure></p><p>  Future afterTwoThings(Future first, Future second) async {<br>    return Future.wait([first, second]);<br>  }<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android 原生项目集成 Flutter 混合开发</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android%20%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Flutter%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android 原生项目集成 Flutter 混合开发/</id>
    <published>2019-02-28T09:09:06.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 <a href="https://github.com/yangxiaoge/wanandroid_flutter" target="_blank" rel="noopener">MuMuxi-Flutter</a> 版本，<br>但是现在想要把 Flutter 使用在现有的项目中，改如何操作呢？哈哈，Google 官方已经考虑到了这个问题，并且给出了集成方案 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">Add-Flutter-to-existing-apps</a>。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>新建一个 <code>Flutter module</code>，使用命令：<code>flutter create -t module {moduleName}</code>，其中 <code>moduleName</code> 我这里取名 <code>xinhua_media_flutter_module</code></li><li>随后将 <code>Flutter module</code> 推送至<code>git</code> 仓库，git 推送我就不累赘了，拿到仓库地址 <a href="https://gitee.com/xxx/xinhua_media_flutter_module.git" target="_blank" rel="noopener">https://gitee.com/xxx/xinhua_media_flutter_module.git</a></li><li>在<code>原生</code> Android 项目更目录添加 <code>git submodule</code><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule <span class="built_in">add</span> &#123;Flutter module 仓库地址&#125;, 即上面拿到的仓库地址 http<span class="variable">s:</span>//gitee.<span class="keyword">com</span>/xxx/xinhua_media_flutter_module.git</span><br><span class="line">git submodule <span class="keyword">update</span></span><br></pre></td></tr></table></figure></li></ol><p>此时项目结构如下图：<br><img src="https://github.com/yangxiaoge/PersonResources/blob/master/flutter/%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90flutter%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true" alt="原生集成flutter工程目录结构.png"></p><ol start="4"><li><p>在原生项目<code>根目录</code> <code>settings.gradle</code> 中 <code>include &#39;:app&#39;</code> 下面添加如下配置</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setBinding(<span class="name">new</span> Binding([gradle: this]))</span><br><span class="line">evaluate(<span class="name">new</span> File(</span><br><span class="line">        'xinhua_media_flutter_module/.android/include_flutter.groovy'</span><br><span class="line">))</span><br></pre></td></tr></table></figure></li><li><p>原生项目 <code>app</code> 目录下的 <code>build.gradle</code> 文件中添加 <code>xinhua_media_flutter_module</code> 库的依赖</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> MyApp<span class="regexp">/app/</span>build.gradle</span><br><span class="line">implementation project(<span class="string">':flutter'</span>)</span><br></pre></td></tr></table></figure></li><li><p>在原生项目中新建一个 <code>FlutterActivity</code> 用来加载 Flutter mudule 页面入口</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"><span class="comment">// "flutter_page" 是路由名称，在 Flutter `main.dart` 页面中需要用到</span></span><br><span class="line">FlutterView seuicSettingPage = Flutter.createView(<span class="keyword">this</span>, getLifecycle(), <span class="string">"flutter_page"</span>);</span><br><span class="line">FrameLayout.LayoutParams layoutParams = <span class="keyword">new</span> FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);</span><br><span class="line"><span class="comment">// 加 flutterview 添加到布局中</span></span><br><span class="line">addContentView(seuicSettingPage, layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>xinhua_media_flutter_module</code> lib 下的 <code>main.dart</code> 文件中添加逻辑</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xinhua_media_flutter_module/lib/main.dart</span></span><br><span class="line"><span class="comment">// 以下 "flutter_page" 判断路由名称，MyApp 是自定义的组件，接下来就可以开发自己的功能逻辑。</span></span><br><span class="line"><span class="comment">// 如果发现 AS 不识别 Dart 语言，设置中勾选 `Enable Dart support`</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(_widgetForRoute(<span class="built_in">window</span>.defaultRouteName));</span><br><span class="line"></span><br><span class="line">Widget _widgetForRoute(<span class="built_in">String</span> route) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (route) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'flutter_page'</span>:</span><br><span class="line">      <span class="keyword">return</span> MyApp();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> Center(</span><br><span class="line">        child: Text(<span class="string">'Unknown route: <span class="subst">$route</span>'</span>, textDirection: TextDirection.ltr),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后<code>运行</code> Android 原生项目，</p></li></ol><p>如果混合项目想要使用 flutter <code>hot start/reload</code>，需要 cd 进入 <code>xinhua_media_flutter_module</code> 目录，然后执行 <code>flutter attach</code>，<br>然后打开 flutter 的页面就能正常使用 Hot restart/reload 啦，好了 Android 集成 flutter 到此结束，iOS 集成可以看 Google 官方教程。</p><ol start="9"><li>emmmmm，Flutter 真香😀😆😉😎😘🤩 </li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>Flutter</code> 作为 Google 的亲儿子，它还是「Google 下一代操作系统」<code>Fuchsia OS</code> 的内置 UI SDK ！2019 年将是 Flutter 的爆发期，<a href="https://github.com/search?q=flutter" target="_blank" rel="noopener">Github</a> 上已经有很多<br>国人开发的相关插件以及项目了，接下来我也会写一些跟自己 Flutter 项目相关的技术文章！加油！📚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 &lt;a href=&quot;https://github.com/
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter | 状态管理拓展篇——RxDart</title>
    <link href="https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%8B%93%E5%B1%95%E7%AF%87-RxDart/"/>
    <id>https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter状态管理拓展篇-RxDart/</id>
    <published>2019-02-19T11:22:01.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p><strong>元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！</strong></p><blockquote><ul><li>原文地址：<a href="https://juejin.im/post/5bcea438e51d4536c65d2232" target="_blank" rel="noopener">https://juejin.im/post/5bcea438e51d4536c65d2232</a></li><li>原文作者：<a href="https://juejin.im/user/5b5d45f4e51d453526175c06/posts" target="_blank" rel="noopener">Vadaski</a></li></ul></blockquote><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><h3 id="ReactiveX-是什么"><a href="#ReactiveX-是什么" class="headerlink" title="ReactiveX 是什么"></a>ReactiveX 是什么</h3><p>ReactiveX 是一个强大的库，用于通过使用<strong>可观察序列</strong>来编写<strong>异步</strong>和<strong>基于事件</strong>的程序。它突破了<strong>语言</strong>和<strong>平台</strong>的限制，让我们编写异步程序就像在自家花园散步那样 easy。我相信你一定会爱上它！</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/24/166a563fd4eb5800?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665e4f1257f4e00?imageslim" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5bcea438e51d4
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android数据库高手秘籍（LitePal）</title>
    <link href="https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E6%89%8B%E7%A7%98%E7%B1%8D%EF%BC%88LitePal%EF%BC%89/"/>
    <id>https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android数据库高手秘籍（LitePal）/</id>
    <published>2018-08-23T15:28:49.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自 <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">郭霖 CSDN</a></p><p>Android 数据库高手秘籍： <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/android-database-pro.html</a></p><p>本专栏主要讲解 Android 数据库相关的高级技术。其中包括了 SQLite 中一些不为人知的使用技巧，以及全面剖析 LitePal 这款 Android 数据库框架的所有用法。LitePal 项目地址是: <a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p><h3 id="Android-数据库高手秘籍-零-——前言"><a href="#Android-数据库高手秘籍-零-——前言" class="headerlink" title="Android 数据库高手秘籍 (零)——前言"></a><a href="https://blog.csdn.net/guolin_blog/article/details/38083103" target="_blank" rel="noopener">Android 数据库高手秘籍 (零)——前言</a></h3><h3 id="Android-数据库高手秘籍-一-——SQLite-命令"><a href="#Android-数据库高手秘籍-一-——SQLite-命令" class="headerlink" title="Android 数据库高手秘籍 (一)——SQLite 命令"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38461239" target="_blank" rel="noopener">Android 数据库高手秘籍 (一)——SQLite 命令</a></h3><h3 id="Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法"><a href="#Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法" class="headerlink" title="Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38556989" target="_blank" rel="noopener">Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法</a></h3><h3 id="Android-数据库高手秘籍-三-——使用-LitePal-升级表"><a href="#Android-数据库高手秘籍-三-——使用-LitePal-升级表" class="headerlink" title="Android 数据库高手秘籍 (三)——使用 LitePal 升级表"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39151617" target="_blank" rel="noopener">Android 数据库高手秘籍 (三)——使用 LitePal 升级表</a></h3><h3 id="Android-数据库高手秘籍-四-——使用-LitePal-建立表关联"><a href="#Android-数据库高手秘籍-四-——使用-LitePal-建立表关联" class="headerlink" title="Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39207945" target="_blank" rel="noopener">Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联</a></h3><h3 id="Android-数据库高手秘籍-五-——LitePal-的存储操作"><a href="#Android-数据库高手秘籍-五-——LitePal-的存储操作" class="headerlink" title="Android 数据库高手秘籍 (五)——LitePal 的存储操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39345833" target="_blank" rel="noopener">Android 数据库高手秘籍 (五)——LitePal 的存储操作</a></h3><h3 id="Android-数据库高手秘籍-六-——LitePal-的修改和删除操作"><a href="#Android-数据库高手秘籍-六-——LitePal-的修改和删除操作" class="headerlink" title="Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40083685" target="_blank" rel="noopener">Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作</a></h3><h3 id="Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术"><a href="#Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术" class="headerlink" title="Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40153833" target="_blank" rel="noopener">Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术</a></h3><h3 id="Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数"><a href="#Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数" class="headerlink" title="Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40614197" target="_blank" rel="noopener">Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数</a></h3><h3 id="Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧"><a href="#Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧" class="headerlink" title="Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧"></a><a href="http://blog.csdn.net/guolin_blog/article/details/80586028" target="_blank" rel="noopener">Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧</a></h3><h3 id="LitePal-学习笔记-忽略字段，多数据库"><a href="#LitePal-学习笔记-忽略字段，多数据库" class="headerlink" title="LitePal 学习笔记 - 忽略字段，多数据库"></a><a href="https://www.jianshu.com/p/bc68e763c7a2" target="_blank" rel="noopener">LitePal 学习笔记 - 忽略字段，多数据库</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自 &lt;a href=&quot;https://blog.csdn.net/column/details/android-database-pro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郭霖 CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android 数
      
    
    </summary>
    
      <category term="数据库" scheme="https://yangxiaoge.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 常用设计模式</title>
    <link href="https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android常用设计模式/</id>
    <published>2018-08-22T15:37:34.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式专栏： <a href="https://blog.csdn.net/lovelixue/article/category/7959476" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/category/7959476</a></p><p>代码 Github ：<a href="https://github.com/sdgSnow/DesignPattern" target="_blank" rel="noopener">https://github.com/sdgSnow/DesignPattern</a></p><h3 id="Android-常用设计模式（一、单例模式）："><a href="#Android-常用设计模式（一、单例模式）：" class="headerlink" title="Android 常用设计模式（一、单例模式）："></a><a href="https://blog.csdn.net/lovelixue/article/details/81940996" target="_blank" rel="noopener">Android 常用设计模式（一、单例模式）</a>：</h3><ol><li>饿汉式</li><li>懒汉式</li><li>双重锁模式</li></ol><h3 id="Android-常用设计模式（二、建造者模式）"><a href="#Android-常用设计模式（二、建造者模式）" class="headerlink" title="Android 常用设计模式（二、建造者模式）:"></a><a href="https://blog.csdn.net/lovelixue/article/details/81944629" target="_blank" rel="noopener">Android 常用设计模式（二、建造者模式）</a>:</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//通过builder创建一个Person对象</span><br><span class="line">Person person = new Person.PersonBuilder(<span class="string">"小羊羊"</span>)</span><br><span class="line"><span class="meta">        .setAge</span>(<span class="number">18</span>)</span><br><span class="line"><span class="meta">        .setSex</span>(<span class="string">"男"</span>)</span><br><span class="line"><span class="meta">        .setIdentity</span>(<span class="string">"码农"</span>)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式专栏： &lt;a href=&quot;https://blog.csdn.net/lovelixue/article/category/7959476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lovelixue
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yangxiaoge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java 字节数组 序列化 与 C# 字节数组 序列化差异性</title>
    <link href="https://yangxiaoge.github.io/2018/08/16/2018-8-16-java%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%B8%8EC%E4%BA%95%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%AE%E5%BC%82%E6%80%A7/"/>
    <id>https://yangxiaoge.github.io/2018/08/16/2018-8-16-java字节数组与C井字节数组序列化差异性/</id>
    <published>2018-08-16T19:40:05.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WRAP）字符串；</p><p>因此： java 这边需要手动将 byte[] 转成  Base64字符串:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Base64</span><span class="selector-class">.encodeToString</span>(<span class="selector-tag">bytes</span>, <span class="selector-tag">Base64</span><span class="selector-class">.NO_WRAP</span>);</span><br></pre></td></tr></table></figure></p><p>java 我用的是 <code>Gson</code> 序列化， 客户的 .NET 代码用的是 <code>JsonConvert.SerializeObject(obj)</code>。</p><p><img src="https://img-blog.csdn.net/20180816185942460?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180816190114298?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WR
      
    
    </summary>
    
    
      <category term="byte，C#" scheme="https://yangxiaoge.github.io/tags/byte%EF%BC%8CC/"/>
    
  </entry>
  
  <entry>
    <title>数据库获取 Android 短信</title>
    <link href="https://yangxiaoge.github.io/2018/08/14/2018-8-14-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%8F%96Android%E7%9F%AD%E4%BF%A1/"/>
    <id>https://yangxiaoge.github.io/2018/08/14/2018-8-14-数据库获取Android短信/</id>
    <published>2018-08-14T14:43:05.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读取短信需要的权限"><a href="#读取短信需要的权限" class="headerlink" title="读取短信需要的权限"></a>读取短信需要的权限</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">"android.permission.READ_SMS"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="读取数据库短信方法"><a href="#读取数据库短信方法" class="headerlink" title="读取数据库短信方法"></a>读取数据库短信方法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; getSmsCode() &#123;</span><br><span class="line">     <span class="keyword">String</span> lastTime = <span class="string">"1534228493681"</span>; <span class="comment">// 时间</span></span><br><span class="line">     Log.i(<span class="string">"SMSUtil"</span>, <span class="string">"开始获取短信"</span>);</span><br><span class="line">     Cursor <span class="built_in">cursor</span> = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 添加异常捕捉</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//第一种， 查询所有短信</span></span><br><span class="line">         <span class="built_in">cursor</span> = App.mContext.getContentResolver().query(</span><br><span class="line">                 Uri.parse(<span class="string">"content://sms"</span>),</span><br><span class="line">                 <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;<span class="string">"_id"</span>, <span class="string">"address"</span>, <span class="string">"body"</span>, <span class="string">"date"</span>, <span class="string">"person"</span>, <span class="string">"type"</span>&#125;,</span><br><span class="line">                 <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"date desc"</span>);</span><br><span class="line">         <span class="comment">//第二种， 通过查询条件， 例如：date &gt; lastTime， 过滤数据</span></span><br><span class="line">         <span class="comment">/*cursor = App.mContext.getContentResolver().query(</span></span><br><span class="line"><span class="comment">                     Uri.parse("content://sms"),</span></span><br><span class="line"><span class="comment">                     new String[]&#123;"_id", "address", "body", "date", "person", "type"&#125;,</span></span><br><span class="line"><span class="comment">                     "date &gt; ?", new String[]&#123;lastTime&#125;, "date desc");*/</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">             List&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; smsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             <span class="keyword">while</span> (<span class="built_in">cursor</span>.moveToNext()) &#123;</span><br><span class="line">                 <span class="keyword">String</span> body = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"body"</span>));<span class="comment">// 在这里获取短信信息</span></span><br><span class="line">                 <span class="keyword">String</span> person = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"person"</span>)); <span class="comment">// 陌生人为null</span></span><br><span class="line">                 <span class="keyword">String</span> address = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"address"</span>));</span><br><span class="line">                 <span class="keyword">String</span> _id = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"_id"</span>));</span><br><span class="line">                 <span class="keyword">String</span> date = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"date"</span>));</span><br><span class="line">                 <span class="keyword">String</span> type = <span class="built_in">cursor</span>.getString(<span class="built_in">cursor</span>.getColumnIndex(<span class="string">"type"</span>));</span><br><span class="line">                 <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; smsMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">                 smsMap.put(<span class="string">"body"</span>, body);</span><br><span class="line">                 smsMap.put(<span class="string">"person"</span>, person);</span><br><span class="line">                 smsMap.put(<span class="string">"address"</span>, address);</span><br><span class="line">                 smsMap.put(<span class="string">"_id"</span>, _id);</span><br><span class="line">                 smsMap.put(<span class="string">"date"</span>, date);</span><br><span class="line">                 smsList.<span class="built_in">add</span>(smsMap);</span><br><span class="line"></span><br><span class="line">                 Log.i(<span class="string">"test_sms"</span>, <span class="string">"body = "</span> + body + <span class="string">"  person = "</span> + person + <span class="string">"  address = "</span> + address</span><br><span class="line">                         + <span class="string">"  date = "</span> + date + <span class="string">"  type = "</span> + type);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 返回所有的短信</span></span><br><span class="line">             <span class="keyword">return</span> smsList;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         Log.i(<span class="string">"test_sms"</span>, <span class="string">"e = "</span> + e.getMessage());</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="built_in">cursor</span>.close();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="URI-主要有："><a href="#URI-主要有：" class="headerlink" title="URI 主要有："></a>URI 主要有：</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">content:</span><span class="comment">//sms/             所有短信 (本示例用的所有)</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/inbox        收件箱</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/sent         已发送</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/draft        草稿</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/outbox       发件箱</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/failed       发送失败</span></span><br><span class="line"><span class="symbol">content:</span><span class="comment">//sms/queued       待发送列表</span></span><br></pre></td></tr></table></figure><h3 id="SMS-主要结构："><a href="#SMS-主要结构：" class="headerlink" title="SMS 主要结构："></a>SMS 主要结构：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_id =&gt; 短消息序号 如 <span class="number">100</span>  </span><br><span class="line">thread_id =&gt; 对话的序号 如 <span class="number">100</span>  </span><br><span class="line">address =&gt; 发件人地址，手机号. 如 + <span class="number">8613811810000</span>  </span><br><span class="line">person =&gt; 发件人，返回一个数字就是联系人列表里的序号，陌生人为 null  </span><br><span class="line">date =&gt; 日期  long 型。如 <span class="number">1256539465022</span>  </span><br><span class="line">protocol =&gt; 协议 <span class="number">0</span> SMS_RPOTO, <span class="number">1</span> MMS_PROTO   </span><br><span class="line">read =&gt; 是否阅读 <span class="number">0</span> 未读， <span class="number">1</span> 已读   </span><br><span class="line">status =&gt; 状态 <span class="number">-1</span> 接收，<span class="number">0</span> complete, <span class="number">64</span> pending, <span class="number">128</span> failed   </span><br><span class="line">type =&gt; 类型 <span class="number">1</span> 是接收到的，<span class="number">2</span> 是已发出       </span><br><span class="line">   (ALL    = <span class="number">0</span>; 所有</span><br><span class="line">    INBOX  = <span class="number">1</span>; 收件箱</span><br><span class="line">    SENT   = <span class="number">2</span>; 已发送</span><br><span class="line">    DRAFT  = <span class="number">3</span>; 草稿</span><br><span class="line">    OUTBOX = <span class="number">4</span>; 发件箱</span><br><span class="line">    FAILED = <span class="number">5</span>; 失败</span><br><span class="line">    QUEUED = <span class="number">6</span>;)待发送</span><br><span class="line"></span><br><span class="line">body =&gt; 短消息内容   </span><br><span class="line">service_center =&gt; 短信服务中心号码编号。如 + <span class="number">8613800755500</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/ithomer/article/details/7328321" target="_blank" rel="noopener">https://blog.csdn.net/ithomer/article/details/7328321</a><br><a href="https://blog.csdn.net/laichao1112/article/details/6436511" target="_blank" rel="noopener">https://blog.csdn.net/laichao1112/article/details/6436511</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读取短信需要的权限&quot;&gt;&lt;a href=&quot;#读取短信需要的权限&quot; class=&quot;headerlink&quot; title=&quot;读取短信需要的权限&quot;&gt;&lt;/a&gt;读取短信需要的权限&lt;/h3&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="Android，SMS" scheme="https://yangxiaoge.github.io/tags/Android%EF%BC%8CSMS/"/>
    
  </entry>
  
  <entry>
    <title>（译）为什么每个 Android 开发者都应该尝试 Flutter</title>
    <link href="https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/"/>
    <id>https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/</id>
    <published>2018-08-06T18:10:08.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f" target="_blank" rel="noopener">Why every Android Developer should try out Flutter</a></li><li>原文作者：<a href="https://proandroiddev.com/@aaronoe?source=post_header_lockup" target="_blank" rel="noopener">Aaron Oertel</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>掘金链接：<a href="https://juejin.im/post/5b5e70ffe51d4518e311b63d" target="_blank" rel="noopener">https://juejin.im/post/5b5e70ffe51d4518e311b63d</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md</a></li><li>译者：<a href="https://github.com/ALVINYEH" target="_blank" rel="noopener">ALVINYEH</a></li><li>校对者：<a href="https://github.com/DateBro" target="_blank" rel="noopener">DateBro</a></li></ul></blockquote><h1 id="为什么每个-Android-开发者都应该尝试-Flutter"><a href="#为什么每个-Android-开发者都应该尝试-Flutter" class="headerlink" title="为什么每个 Android 开发者都应该尝试 Flutter"></a>为什么每个 Android 开发者都应该尝试 Flutter</h1><p>几个月前，我写过一篇题为“<a href="https://juejin.im/post/5add65c46fb9a07aa541e97e" target="_blank" rel="noopener">为什么 Flutter 能最好地改变移动开发</a>”的文章。虽然已经过去了一段时间，但是我对 Flutter 的热爱依然非常强烈；事实上，当我继续使用它时，我意识到了我之前忽略了 Flutter 独特方面的重要性。不要误会我的意思 —— 我仍然认为 Flutter 最强大的一点就是如何解决跨平台开发的许多问题。但最近我开始关注移动开发发展的更多领域，特别是声明性用户界面的概念。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*pV87QzKfowqgkEkd" alt></p><p>摄影者：来自 <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Unsplash</a> 的 <a href="https://unsplash.com/@licole?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Chris Charles</a>。</p><p>我相信你已经听过一系列关于为什么 Android 开发者应该关注 Flutter 的若干论据（如果你还没有看过，请让我谦逊地建议你瞧瞧<a href="https://proandroiddev.com/why-flutter-will-change-mobile-development-for-the-best-c249f71fa63c" target="_blank" rel="noopener">这个</a>），但是我想指出一个我还没有真正解决的大问题，那就是 Flutter 可以让你对 App 开发有完全不同的看法。首先，你的应用本身将采用不同的方式构建 —— 但更重要的是，实际的 UI 开发通过将其合并到你的 Dart 代码（而不是 XML）中而被推到前台，因此使它成为了“一等公民”。一旦你的 UI 代码突然出现在一种非标记语言中，你就会意识到你突然有了构建应用的可能性。说实话，在使用 Flutter 之后，我开始讨厌在 Android 上编写 UI 代码；因为在 Android 中步骤更加繁琐，虽然你仍然可以使用数据绑定等工具构建响应式应用，但它实际上比 Flutter 中要花费更多的时间。</p><p>当你考虑在 Android 中整合动画和其他动态数据时，使用 Flutter 的论点变得更加有力。整合动画可能会不太方便，有时你可能不得不拒绝设计师的要求，因为要实现他们的需求太难了。谢天谢地，Flutter 改变了这一切。如果你一直在关注 Flutter，你可能已经从 <a href="https://medium.com/fluttery" target="_blank" rel="noopener">Fluttery</a> 听说过 <strong>Flutter 挑战</strong>。这些挑战展示了构建具有大量自定义组件和精美设计（包括动画）的复杂 UI 的快速和直观性。在 Android 上实现这样的东西会变得非常困难 —— 特别是因为与 Flutter 不同，Android 的视图基于继承而非组合，这使得构建视图变得更加复杂。</p><p>下面，让我们切入正题：使用 Flutter <strong>构建声明性 UI</strong>，这改变了 UI 开发的一切。现在也许你在想，<strong>Android 布局不也是以声明方式构建的吗？</strong>答案是肯定的，但事实不是。使用 XML 来定义布局让我们有了以声明方式定义布局的感觉，但如果你的视图是完全静态的，并且所有数据都是以 XML 格式设置的，那么这种感觉才真正成立。不幸的是，这种情况几乎从未发生过；一旦添加动态数据和类似列表之类的东西，你自然必须使用一些 Java / Kotlin 代码将数据绑定到视图。然后我们最终得到某种 ViewModel，它将数据设置为视图。想象一下，这就像在 Android 上调用 <code>textView.text =“Hello Medium！”</code> 一样。在 Flutter 上，这是完全不同的：你创建了一个包含某个状态的窗口组件类，然后根据该状态以声明方式定义你的布局。每当状态改变时，我们调用 <code>setState（）</code> 来重新渲染我们改变的组件树的部分。让我们看一下如何在 Flutter 中使用 API，并使用结果渲染一个 List：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FutureBuilder&lt;Repositories&gt;(</span><br><span class="line">    future: apiClient.getUserRepositoriesFuture(username),</span><br><span class="line">    builder: (BuildContext context, </span><br><span class="line">        AsyncSnapshot&lt;Repositories&gt; snapshot) &#123;</span><br><span class="line">      <span class="keyword">if</span> (snapshot.hasError)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Center(child: <span class="keyword">new</span> Text(<span class="string">"Network error"</span>));</span><br><span class="line">      <span class="keyword">if</span> (!snapshot.hasData)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> CircularProgressIndicator(),</span><br><span class="line">        );</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ListView.builder(</span><br><span class="line">        itemCount: snapshot.data.nodes.length,</span><br><span class="line">        itemBuilder: <span class="function"><span class="params">(BuildContext context, int index)</span> =&gt;</span></span><br><span class="line">            <span class="keyword">new</span> RepoPreviewTile(</span><br><span class="line">              repository: snapshot.data.nodes[index],</span><br><span class="line">            ),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们使用了 <code>FutureBuilder</code> 来等待网络调用（Future）的完成。一旦网络调用完成，出现结果或错误，<code>FutureBuilder</code> 组件会在内部调用 <code>setState</code> 来调用所提供的 <code>builder</code> 方法来重新渲染。正如你在这个例子中看到的，一切都是<strong>声明式的</strong>。在 Android 上做同样的事情通常需要一个被动的 XML 布局，然后需要一些其他类来手动设置状态，比如 Adapter 和视图模型。这种方法的问题在于，状态可能与屏幕上渲染的状态不同。这就是为什么我们希望拥有像 Flutter 为我们提供的那样的声明性布局。我们最终编写的代码要少得多，同时将状态绑定到要在屏幕上显示的内容。</p><p>有了这些声明性布局，我们也开始对架构进行了不同的思考。突然间，<strong>reactive</strong> 这个词出现了，我们谈论了更多的是关于状态管理的内容，而不是架构。有了 Flutter，像 MVP 和 MVVM 这样的架构已经没有多大有意义了；我们不再使用它们了，而是考虑状态如何流经我们的应用。状态突然成为讨论的一个重要部分，我们将投入越来越多精力去思考构建应用的新方法上。这对我们所有人来说都是一次新的旅程，有许多事情可以解决，但最重要的是，这是我们开阔视野的机会。</p><p>坦白地说，Flutter 也不只有阳光和彩虹。我目前正在与 Flutter 合作开展一个更大的项目来了解它的弱点，迄今为止我遇到的最大缺陷是缺乏基础设施。当我尝试使用 Graphql-API 时，这个问题就非常明显；虽然有库确实会这样做，但它们并没有接近 Android 与 Apollo 的关系。不过，好消息是，Flutter 迎头赶上只是时间的问题，在此期间扩展现有的库，甚至建立自己的库并不困难。请注意，你可能需要花一些时间投入在应用程序的基础设施中，而对于 Android 和 iOS 来说，情况通常并非如此 —— 毕竟，天下没有免费的午餐。</p><p>最后，我最近从使用 Flutter 中得到的最大启示之一就是，体验这种构建 UI 的声明方式以及它对状态管理的影响是非常有用的。我觉得 Flutter 太棒了；不过，我告诫你不要把它当作解决你所有问题的银弹，而应该是作为一种创新的工具，它可以比在 Android 上更快地构建漂亮的自定义 UI。更重要的是，它展示了强大的声明性布局功能，并让你将应用视为渲染状态，而不是非连贯性 Activity，视图和视图模型 —— 仅此而言，我强烈建议你尝试一下 Flutter。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Git clone 慢怎么办 - 配置代理</title>
    <link href="https://yangxiaoge.github.io/2018/08/03/2018-8-3-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>https://yangxiaoge.github.io/2018/08/03/2018-8-3-git配置代理/</id>
    <published>2018-08-03T17:23:35.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。</p><p>配置 Git 代理。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看当前代理设置</span></span><br><span class="line">git config --global http.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span></span><br><span class="line">git config --global http<span class="selector-class">.proxy</span> <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global http<span class="selector-class">.proxy</span> <span class="string">'socks5://127.0.0.1:1080'</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 `mac` 小飞机需要开启全局代理</span></span><br></pre></td></tr></table></figure></p><p>接下来尽情的使用 git 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。&lt;/p&gt;
&lt;p&gt;配置 Git 代理。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何接入 VirtualAPK 插件框架</title>
    <link href="https://yangxiaoge.github.io/2018/07/25/2018-07-25%20-%20%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%20virtualapk%20%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    <id>https://yangxiaoge.github.io/2018/07/25/2018-07-25 - 如何接入 virtualapk 插件框架/</id>
    <published>2018-07-25T17:05:06.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/didi/VirtualAPK/raw/master/imgs/va.png" alt></p><p>封面图片来源: <a href="https://blog.csdn.net/byeweiyang/article/details/80127643" target="_blank" rel="noopener">https://blog.csdn.net/byeweiyang/article/details/80127643</a></p><p>话不多说，先上我的 Demo 地址：<a href="https://github.com/yangxiaoge/VirtualAPKDemo" target="_blank" rel="noopener">https://github.com/yangxiaoge/VirtualAPKDemo</a></p><p>本文转载：原文链接<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p>最近都在搞插件框架，为项目搭建用，之前集成了下阿里的 atlas，现在送上一篇滴滴的 virtualapk，就个人而言，滴滴的集成过程比阿里简单些，有兴趣的可以看看我 atlas 的：<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p><em>废话不多说，上过程</em></p><h3 id="1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写"><a href="#1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写" class="headerlink" title="1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写"></a>1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写</h3><p>1.1 新建一个工程，根目录的 build.gradle 里面</p><p>classpath ‘com.android.tools.build:gradle:3.0.0’</p><p>classpath ‘com.didi.virtualapk:gradle:0.9.8.4’</p><p>根目录 就配置这两个</p><p>1.2 在 app（宿主）目录下的 build.gradle 文件下添加</p><p>apply plugin: ‘com.didi.virtualapk.host’<br>在 dependencies 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>1.3 重点来了，通过 file，new module 的形式新建一个 module，然后我命名为 plugindemo，然后在 nodule.gradle 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>接着在末端添加</p><p>apply plugin: ‘com.didi.virtualapk.plugin’<br>virtualApk {<br>    // 插件资源表中的packageId，需要确保不同插件有不同的packageId.<br>    packageId = 0x6f             // The package id of Resources.<br>    // 宿主工程application模块的路径，插件的构建需要依赖这个路径<br>    targetHost=’../app’ // The path of application module in host project.<br>    //默认为true，如果插件有引用宿主的类，那么这个选项可以使得插件和宿主保持混淆一致<br>    applyHostMapping = true      // [Optional] Default value is true.<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725103642552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>基本 环境就到此为止了，接下来代码部分</p><h3 id="2-代码添加并验证"><a href="#2-代码添加并验证" class="headerlink" title="2. 代码添加并验证"></a>2. 代码添加并验证</h3><p>在 app 的 mainactivity 里面添加两个按钮，一个是跳转到 module 去的，一个是加载插件的</p><p>public void loadPlugin() {<br>    PluginManager pluginManager = PluginManager.getInstance(this);<br>    //此处是当查看插件apk是否存在,如果存在就去加载(比如修改线上的bug,把插件apk下载到sdcard的根目录下取名为plugin-release.apk)<br>    File apk = new File(Environment.getExternalStorageDirectory(), “plugin-release.apk”);<br>    if (apk.exists()) {<br>        try {<br>            pluginManager.loadPlugin(apk);<br>            Toast.makeText(this, “插件加载成功”, Toast.LENGTH_SHORT).show();<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>            Toast.makeText(this, “插件加载异常！”, Toast.LENGTH_SHORT).show();<br>        }<br>    }<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725104101299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这个时候跳转是不行的，接下来就需要加载插件了 ，首先需要生成插件 apk</p><p>官方文档是通过命令</p><p>gradle clean assemblePlugin来构建插件</p><p>如果不想这样，也可以通过直接 gradle 的来，具体如下<br><img src="https://img-blog.csdn.net/20180725104350857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这样 就生成插件 apk 了，同时官方文档介绍了下这个，就是只能生成 release 版本的，插件包位于 build 目录下<br><img src="https://img-blog.csdn.net/20180725104530319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>到这里 就可以结束验证了，点击加载插件，然后再点击跳转，你会发现可以跳转了，如果如果有帮助可以帮我点个赞或者 githup 上面 star 一下，谢谢，如果有问题，可以下面评论回复，一起学习探讨。下面贴上注意点</p><ol><li><p>集成环境一定要配置好</p></li><li><p>生成的插件包和加载的时候名字一定要一样</p></li><li><p>注意 SD 卡的权限</p></li></ol><p>贴上相关参考文档和我的 githup 代码</p><p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK</a></p><p><a href="https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88</a></p><p>github：<a href="https://github.com/sdgSnow/VirtualAPK" target="_blank" rel="noopener">https://github.com/sdgSnow/VirtualAPK</a></p><p>希望对大家有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/didi/VirtualAPK/raw/master/imgs/va.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;封面图片来源: &lt;a href=&quot;https://blog.csdn.net/byeweiyang/articl
      
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://yangxiaoge.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>锻炼身体从现在做起</title>
    <link href="https://yangxiaoge.github.io/2018/03/23/2018-3-23-%E9%94%BB%E7%82%BC%E8%BA%AB%E4%BD%93%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%81%9A%E8%B5%B7/"/>
    <id>https://yangxiaoge.github.io/2018/03/23/2018-3-23-锻炼身体从现在做起/</id>
    <published>2018-03-23T11:19:14.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- <a href="https://www.zhihu.com/question/22918787/answer/23166234" target="_blank" rel="noopener">杨小彻的回答 - 知乎 </a></p></blockquote><h3 id="上学"><a href="#上学" class="headerlink" title="上学"></a>上学</h3><p>我也是曾经瘦过的人，一度认为自己不会胖，上初高中一直都没有胖起来。于是我上了大学，入学时119斤173的个子，大学疯玩了4年，胡吃胡喝，毕业后我125斤😂</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>工作1年不到，长期坐着也不怎么运动，放假也不出门，十足的宅男。不用想肯定又胖了，emmm，130斤了Σ( °吓°|||)︴。</p><h3 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h3><p>交往我老婆以后，自己也不宅了，犹如一个没吃过东西的人，吃遍了各种以前没吃过的食物。她吃不完的我这人又舍不得浪费我就帮着消灭了（其实还是我能吃），再加上老婆烧的饭也很好吃，我就hold不住了。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>随着时间流逝，毕业快3年了，我体重飚到144斤了，啊五环～ 突然想唱这首歌🎤。呵，难道就是胖了就这么结束了？不，我还越来越黑了，由于从事it每天电脑相伴（我猜是这样的）。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>重点来了，在老婆的<code>劝导</code>下我要开始健身了，没错就是健身，不能任由自己这么胖下去了。既然事态发展到这步田地，箭在弦上不得不发了，不是我瘦就是健身房亡！社会社会|･ω･｀)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- &lt;a href=&quot;https://www.zhihu.com/question/22918787/answer/23166234&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Nice git log</title>
    <link href="https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/"/>
    <id>https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/</id>
    <published>2017-12-13T10:11:01.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。</p><p>开发中查看提交记录是家常便饭了，<code>git log</code> 命令是查看全部提交日志，<code>git log -2</code>  查看最近 2 次的提交日志，<code>git log -p</code>  查看历史纪录以来哪几行被修改，<code>git log --stat --summary</code> 查看每个版本变动的档案和行数。</p><p>Git 默认的 git log 是这样子的，emmmmmm….. 丑</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e2fcca990.png"></div><p>于是乎 Google 了一个 git 配置，打开终端，输入以下命令。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure></p><p>以后在终端输入 git lg，就能看到下面漂亮的 git log 了。</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e32602b21.png"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。&lt;/p&gt;
&lt;p&gt;开发中查看提交记录是家常便饭了，&lt;code&gt;git log&lt;/code&gt; 命令是查看全部提交日志，&lt;code&gt;git log -2&lt;/code&gt;  查看最近 2 次的提交日志，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android Launcher 界面添加未接来电/未读短信条数显示</title>
    <link href="https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-%E7%95%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E6%9C%AA%E6%8E%A5%E6%9D%A5%E7%94%B5-%E6%9C%AA%E8%AF%BB%E7%9F%AD%E4%BF%A1%E6%9D%A1%E6%95%B0%E6%98%BE%E7%A4%BA/"/>
    <id>https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-界面添加未接来电-未读短信条数显示/</id>
    <published>2017-10-19T16:00:50.000Z</published>
    <updated>2019-02-28T10:48:36.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Thumbnail by <a href="https://octiviotti.deviantart.com/" target="_blank" rel="noopener">octiviotti</a></p></blockquote><p>本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。</p><p>涉及到几个文件：<br><a id="more"></a></p><ol><li>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</li><li>packages/apps/Launcher3/src/com/android/launcher3/Utilities.java</li><li>packages/apps/Launcher3/AndroidManifest.xml </li></ol><p>具体的思路：<code>Launcher</code> 中注册 <code>ContentObserver</code> 来监听短信和电话数据库，当数据发生变化时，读取读取数据库未读数目之后通过 ICON_NAME ，<code>重新绘制</code>短信，电话的图标（在原图右上角画圆和数字）。</p><hr><p>具体代码：</p><h3 id="1-Launcher-java"><a href="#1-Launcher-java" class="headerlink" title="1. Launcher.java"></a>1. Launcher.java</h3><ul><li>首先是定义两个 ContentObserver</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> UPDATE_MMS_ICON = <span class="number">826</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> UPDATE_CALL_ICON = <span class="number">1206</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSContentObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SMSContentObserver</span><span class="params">(Context context, Handler <span class="keyword">handler</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">handler</span>);</span><br><span class="line">        mHandler = <span class="keyword">handler</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"Launcher-"</span>,<span class="string">"SMSContentObserver onChange"</span>);</span><br><span class="line">        mHandler.removeMessages(UPDATE_MMS_ICON);</span><br><span class="line">        Message msg = mHandler.obtainMessage(UPDATE_MMS_ICON);</span><br><span class="line">        msg.obj = getMissMmsCount();</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallContentObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallContentObserver</span><span class="params">(Context context, Handler <span class="keyword">handler</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">handler</span>);</span><br><span class="line">        mHandler = <span class="keyword">handler</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"Launcher-"</span>,<span class="string">"CallContentObserver onChange"</span>);</span><br><span class="line">        mHandler.removeMessages(UPDATE_CALL_ICON);</span><br><span class="line">        Message msg = mHandler.obtainMessage(UPDATE_CALL_ICON);</span><br><span class="line">        msg.obj = getMissCallCount();</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 onCreate() 中注册 ContentObserver</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SMSContentObserver smsContentObserver = <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">private</span> CallContentObserver callContentObserver = <span class="literal">null</span>;  </span><br><span class="line"></span><br><span class="line">smsContentObserver = <span class="keyword">new</span> <span class="type">SMSContentObserver</span>(<span class="built_in">this</span>,mHandler);</span><br><span class="line">callContentObserver =<span class="keyword">new</span> <span class="type">CallContentObserver</span>(<span class="built_in">this</span>,mHandler);</span><br><span class="line"></span><br><span class="line">getContentResolver().registerContentObserver(Calls.CONTENT_URI,<span class="literal">true</span>,callContentObserver);</span><br><span class="line">getContentResolver().registerContentObserver(Uri.parse(<span class="string">"content://mms-sms/"</span>),<span class="literal">true</span>,smsContentObserver);</span><br></pre></td></tr></table></figure><ul><li>定义两个 ICON_NAME</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个 ICON_NAME 根据自己实际系统短信和电话页面对应包名填写</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> PHONE_ICON_NAME = <span class="string">"com.android.dialer.DialtactsActivity"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> MMS_ICON_NAME = <span class="string">"com.android.messaging.ui.conversationlist.ConversationListActivity"</span>;</span><br></pre></td></tr></table></figure><ul><li>mHandler 中处理</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Thunk</span></span><br><span class="line"><span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"Launcher-"</span>,<span class="string">"mHandler msg.what = "</span> + msg.what);</span><br><span class="line">        <span class="keyword">if</span> (msg.what == ADVANCE_MSG) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (View key : mWidgetsToAdvance.keySet()) &#123;</span><br><span class="line">                <span class="keyword">final</span> View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> delay = mAdvanceStagger * i;</span><br><span class="line">                <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Advanceable) &#123;</span><br><span class="line">                    mHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            ((Advanceable) v).advance();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, delay);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sendAdvanceMessage(mAdvanceInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ADD BY Bruce Yang FOR SHOW UNREAD MMS</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(msg.what == UPDATE_MMS_ICON)</span> </span>&#123;</span><br><span class="line">            setMmsOrPhoneNum(MMS_ICON_NAME, getMissMmsCount());</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(msg.what == UPDATE_CALL_ICON)</span> </span>&#123;</span><br><span class="line">            setMmsOrPhoneNum(PHONE_ICON_NAME, getMissCallCount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>获取数据库中未读数目</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMissMmsCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"getMissMmsCount"</span>);</span><br><span class="line">    <span class="keyword">int</span> missSmsCount = <span class="number">0</span>;</span><br><span class="line">    Cursor cursorSMS = <span class="literal">null</span>;</span><br><span class="line">    Cursor cursorMMS = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cursorSMS = getContentResolver().query(</span><br><span class="line">                Uri.parse(<span class="string">"content://sms"</span>), <span class="literal">null</span>, <span class="string">"(read=0 and type=1)"</span>,</span><br><span class="line">                <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        cursorMMS = getContentResolver().query(</span><br><span class="line">                Uri.parse(<span class="string">"content://mms"</span>), <span class="literal">null</span>, <span class="string">"(read=0)"</span>, <span class="literal">null</span>,</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> missSmsCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorSMS != <span class="literal">null</span>) &#123;</span><br><span class="line">        missSmsCount = cursorSMS.getCount();</span><br><span class="line">        cursorSMS.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cursorMMS != <span class="literal">null</span>) &#123;</span><br><span class="line">            missSmsCount = missSmsCount + cursorMMS.getCount();</span><br><span class="line">        cursorMMS.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"getMissMmsCount  missSmsCount = "</span> + missSmsCount);</span><br><span class="line">    <span class="keyword">return</span> missSmsCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMissCallCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"getMissCallCount"</span>);</span><br><span class="line">    <span class="keyword">int</span> missCallCount = <span class="number">0</span>;</span><br><span class="line">    Uri missingCallUri = Calls.CONTENT_URI;</span><br><span class="line">    String <span class="keyword">where</span> = Calls.TYPE + <span class="string">"='"</span> + Calls.MISSED_TYPE + <span class="string">"'"</span></span><br><span class="line">            + <span class="string">" AND new=1"</span>;</span><br><span class="line">    Cursor cursorCall = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cursorCall = getContentResolver().query(missingCallUri,</span><br><span class="line">                <span class="literal">null</span>, <span class="keyword">where</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> missCallCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cursorCall != <span class="literal">null</span>) &#123;</span><br><span class="line">        missCallCount = cursorCall.getCount();</span><br><span class="line">        cursorCall.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"getMissCallCount  missCallCount = "</span> + missCallCount);</span><br><span class="line">    <span class="keyword">return</span> missCallCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 ICON 未读数</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> flag 更新电话或短信 ICON</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> missCount 未读数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setMmsOrPhoneNum</span><span class="params">(<span class="keyword">final</span> String flag, <span class="keyword">final</span> <span class="keyword">int</span> missCount)</span> </span>&#123;</span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"flag = "</span>+flag +<span class="string">" missCount = "</span>+missCount);</span><br><span class="line">    <span class="keyword">if</span>(mWorkspace == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    ArrayList&lt;CellLayout&gt; cellLayouts = mWorkspace.getWorkspaceAndHotseatCellLayouts();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> CellLayout layoutParent: cellLayouts) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup shortcutAndWidgetContainer = layoutParent.getShortcutsAndWidgets();</span><br><span class="line"></span><br><span class="line">        mWorkspace.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> childCount = shortcutAndWidgetContainer.getChildCount();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;childCount; j++) &#123;</span><br><span class="line">                    View view = shortcutAndWidgetContainer.getChildAt(j);</span><br><span class="line"></span><br><span class="line">                    Object tag = view.getTag();</span><br><span class="line">                    <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ShortcutInfo info = (ShortcutInfo) tag;</span><br><span class="line">                        <span class="keyword">final</span> Intent intent = info.intent;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> ComponentName name = intent.getComponent();</span><br><span class="line">                            <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.getClassName().equals(flag)) &#123;</span><br><span class="line">                                BubbleTextView bv = (BubbleTextView) view;</span><br><span class="line">                                Bitmap defaultIconBitmap = Bitmap.createBitmap(info.getIcon(mIconCache));</span><br><span class="line">                                Bitmap bitmap = Utilities.createIconBitmap(defaultIconBitmap, missCount);</span><br><span class="line">                                bv.setCompoundDrawablesWithIntrinsicBounds(<span class="keyword">null</span>,</span><br><span class="line">                                        <span class="keyword">new</span> FastBitmapDrawable(bitmap),</span><br><span class="line">                                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一次启动 Launcher 就能获取未读数目，在 finishBindingItems() 添加逻辑</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//ADD BY Bruce Yang</span><br><span class="line">int missC<span class="literal">all</span> = getMissC<span class="literal">all</span>Count();</span><br><span class="line">int missMms = getMissMmsCount();</span><br><span class="line">if(missC<span class="literal">all</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">set</span>MmsOrPhoneNum(PHONE_ICON_NAME, missC<span class="literal">all</span>);</span><br><span class="line">&#125;</span><br><span class="line">if(missMms != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">set</span>MmsOrPhoneNum(MMS_ICON_NAME, missMms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 onDestroy() 中反注册 ContentObserver</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">getContentResolver</span>()<span class="selector-class">.unregisterContentObserver</span>(smsContentObserver);</span><br><span class="line"><span class="selector-tag">getContentResolver</span>()<span class="selector-class">.unregisterContentObserver</span>(callContentObserver);</span><br></pre></td></tr></table></figure><h3 id="2-Utilities-java"><a href="#2-Utilities-java" class="headerlink" title="2. Utilities.java"></a>2. Utilities.java</h3><p>新增构造方法，用于重新绘制带数字的应用图标。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add by Bruce Yang for ...</span></span><br><span class="line">static Bitmap createIconBitmap(Bitmap b, int count) &#123;</span><br><span class="line">    Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888,true);</span><br><span class="line">    Log.i(<span class="string">"Launcher-"</span>,<span class="string">"b.isMutable() = "</span>+b.isMutable()); <span class="comment">// 如果为 false 就会抛出 java.lang.IllegalStateException 异常， http://bbs.csdn.net/topics/370021698</span></span><br><span class="line">    if (count == <span class="number">0</span>) return b;</span><br><span class="line">    int textureWidth = bitmap.getWidth();</span><br><span class="line">    final Canvas canvas = sCanvas;</span><br><span class="line">    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);</span><br><span class="line">    canvas.setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">    paint.setColor(Color.RED);</span><br><span class="line">    canvas.drawCircle(textureWidth - <span class="number">17</span><span class="number">-6</span>, <span class="number">16</span>+<span class="number">6</span>, <span class="number">16</span>+<span class="number">6</span>, paint);</span><br><span class="line">    paint.setColor(Color.WHITE);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setStrokeWidth(<span class="number">2</span>);</span><br><span class="line">    canvas.drawCircle(textureWidth - <span class="number">17</span><span class="number">-6</span>, <span class="number">16</span>+<span class="number">6</span>, <span class="number">16</span>+<span class="number">6</span>, paint);</span><br><span class="line"></span><br><span class="line">    Paint countPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);</span><br><span class="line">    countPaint.setColor(Color.WHITE);</span><br><span class="line">    countPaint.setTextSize(<span class="number">26</span>f);</span><br><span class="line">    countPaint.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> x = textureWidth - <span class="number">24</span><span class="number">-4</span>;</span><br><span class="line">    if (count &gt; <span class="number">9</span>) x -= <span class="number">4</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    if (count &gt; <span class="number">99</span>) &#123;</span><br><span class="line">        countPaint.setTextSize(<span class="number">22</span>f);</span><br><span class="line">        String text = String.valueOf(<span class="number">99</span>) + <span class="string">"+"</span>;</span><br><span class="line">        canvas.drawText(text, x<span class="number">-2</span>, <span class="number">25</span>+<span class="number">5</span>, countPaint);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String text = String.valueOf(count);</span><br><span class="line">        canvas.drawText(text,x, <span class="number">25</span>+<span class="number">5</span>, countPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    return bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-AndroidManifest-xml"><a href="#3-AndroidManifest-xml" class="headerlink" title="3. AndroidManifest.xml"></a>3. AndroidManifest.xml</h3><p>添加如下两个权限，由于 Android 6.0 以上需要动态权限申请，这里为了直接获取权限，可以将 targetSdkVersion 改成 21（原来是 23）。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"android.permission.READ_SMS"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"android.permission.READ_CALL_LOG"</span> /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="4-修改对比"><a href="#4-修改对比" class="headerlink" title="4. 修改对比"></a>4. 修改对比</h3><blockquote><p>修改前：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e865f6b26df.png" width="270" height="480"></p><blockquote><p>修改后：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e86659672b9.png" width="270" height="480"></p><blockquote><p>参考文章： </p></blockquote><p><a href="http://blog.csdn.net/chenxiong668/article/details/12851357" target="_blank" rel="noopener">http://blog.csdn.net/chenxiong668/article/details/12851357</a><br><a href="http://blog.csdn.net/kerancsdn/article/details/26705767" target="_blank" rel="noopener">http://blog.csdn.net/kerancsdn/article/details/26705767</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Thumbnail by &lt;a href=&quot;https://octiviotti.deviantart.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;octiviotti&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。&lt;/p&gt;
&lt;p&gt;涉及到几个文件：&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从 0 搭建直播系统</title>
    <link href="https://yangxiaoge.github.io/2017/09/12/2017-09-12-%E4%BB%8E-0-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/</id>
    <published>2017-09-12T15:45:18.000Z</published>
    <updated>2017-10-12T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个直播的 Demo，今天正好看到<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统</a>，索性就把我自己的搭(折)建(腾)过程做一个记录。<br><a id="more"></a><br>搭建流程：</p><blockquote><p>服务器系统：Ubuntu 16.10 系统<br>推流，拉流系统：Win 7, Android</p></blockquote><p>一个简易的直播系统，大致可以由三部分组成（详情见<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋博客</a>）：</p><ul><li>搭建一个 rtmp 媒体服务器：这里使用 srs，链接为：<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li>推流端：这里使用 obs，链接为：<a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a></li><li>拉流端：这里使用播放器 vlc，链接为：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></li></ul><h3 id="使用第三方-SDK-推流"><a href="#使用第三方-SDK-推流" class="headerlink" title="使用第三方 SDK 推流"></a>使用第三方 SDK 推流</h3><p>这里以百度云的直播 SDK 为例，下载地址：<br><a href="https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E" target="_blank" rel="noopener">https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E</a></p><p>修改推流地址之后上传到了我的 <a href="https://github.com/yangxiaoge/PushFlowLive" target="_blank" rel="noopener">PushFlowLive</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/baidu-livecamera-%E6%8E%A8%E6%B5%81.apk" target="_blank" rel="noopener">apk 下载</a></p><h3 id="使用开源项目推流"><a href="#使用开源项目推流" class="headerlink" title="使用开源项目推流"></a>使用开源项目推流</h3><p>使用一个开源项目：</p><blockquote><p><a href="https://github.com/begeekmyfriend/yasea" target="_blank" rel="noopener">https://github.com/begeekmyfriend/yasea</a></p></blockquote><blockquote><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/yasea-推流.apk" target="_blank" rel="noopener">apk 下载</a></p></blockquote><h3 id="利用-ffmpeg-推流"><a href="#利用-ffmpeg-推流" class="headerlink" title="利用 ffmpeg 推流"></a>利用 ffmpeg 推流</h3><blockquote><p>详情见鸿洋博客</p></blockquote><p>大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。</p><p>这里，由于篇幅，我们就直接使用别人编好的项目了。</p><p><a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="noopener">https://github.com/WritingMinds/ffmpeg-android-java</a></p><p><strong><em>搭建过程截图</em></strong>：<br>直播步骤：1，开启rtmp 媒体服务器 2，推流（推流客户端，apk等） 3，拉流（vlc等）<br><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-43.jpg" alt></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-51.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-57.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-02.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-04.jpg" alt></p><blockquote><p>封面小黄人动图来自 <a href="https://giphy.com/search/new-follower" target="_blank" rel="noopener">giphy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想搞个直播的 Demo，今天正好看到&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/77937483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统&lt;/a&gt;，索性就把我自己的搭(折)建(腾)过程做一个记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="直播" scheme="https://yangxiaoge.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的 Android Framework</title>
    <link href="https://yangxiaoge.github.io/2017/09/05/2017-09-05-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-Android-Framework/"/>
    <id>https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/</id>
    <published>2017-09-05T14:16:37.000Z</published>
    <updated>2019-02-28T10:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— <code>前言</code><br><a id="more"></a></p><blockquote><p>本文转自 <a href="https://juejin.im/post/586da43b1b69e60062cb8a4f" target="_blank" rel="noopener">墨镜猫</a>，通俗有趣的文笔</p></blockquote><div align="center"><img src="https://github.com/yangxiaoge/PersonResources/blob/bfd168d0f60a7fa8b11ad50cdc53694c77d90bd9/Android/Android%20Framework.jpg?raw=true"></div><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含以下类：</p><ul><li>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。</li><li>Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。</li><li>PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。</li><li>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。</li><li>DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。</li><li>ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。</li></ul><h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><p>Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。</p><p>每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。</p><h3 id="从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的</h3><p>ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。</p><p>接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。</p><p><strong><em>很多线程是不是很晕？</em></strong></p><ol><li>安卓程序中都有哪些线程？</li></ol><p>客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。</p><ol start="2"><li>UI 线程是什么？</li></ol><p>一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p><ol start="3"><li>自定义的线程和 UI 线程有什么区别？</li></ol><p>UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— &lt;code&gt;前言&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Framework" scheme="https://yangxiaoge.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源许可证？</title>
    <link href="https://yangxiaoge.github.io/2017/08/29/2017-08-29-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%9F/"/>
    <id>https://yangxiaoge.github.io/2017/08/29/2017-08-29-如何选择开源许可证？/</id>
    <published>2017-08-29T14:36:51.000Z</published>
    <updated>2019-02-28T10:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。<br><a id="more"></a></p><blockquote><p>本文转自 <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a> 大大</p></blockquote><p>如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">上百种</a>。很少有人搞得清楚它们的区别。即使在最流行的六种—– <a href="http://www.gnu.org/licenses/gpl.html" target="_blank" rel="noopener">GPL</a>、<a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener">BSD</a>、<a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener">MIT</a>、<a href="http://www.mozilla.org/MPL/" target="_blank" rel="noopener">Mozilla</a>、<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache</a> 和 <a href="http://www.gnu.org/copyleft/lesser.html" target="_blank" rel="noopener">LGPL</a>—-之中做选择，也很复杂。<br>乌克兰程序员 <a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="noopener">Paul Bagwell</a> ，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。<br>下面是我制作的中文版，请看大图。<br><img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt></p><p>有兴趣详细了解开源协议的可以看这篇文章：<a href="http://www.gcssloop.com/tips/choose-license" target="_blank" rel="noopener">程序员不可不知的版权协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。&lt;br&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Binder源码分析</title>
    <link href="https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder源码分析/</id>
    <published>2017-07-06T10:00:05.000Z</published>
    <updated>2017-11-22T14:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>forked from <a href="https://github.com/xdtianyu/SourceAnalysis" target="_blank" rel="noopener">xdtianyu/SourceAnalysis</a></p></blockquote><p>本文是基于 <a href="https://github.com/xdtianyu/android-6.0.0_r1" target="_blank" rel="noopener">Android 6.0.0</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow" target="_blank" rel="noopener">kernel 3.4</a> 源码 及 Android SDK 23 展开的。</p><p>先上一张图，直白的了解 Binder 通信过程。(摘自<a href="http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA" target="_blank" rel="noopener">超详细 Android 面试的准备与经历分享 | 百度 (offer)</a>)</p><blockquote><p><img src="/assets/学习资料/面试小札/Binder通信过程.png" alt></p></blockquote><a id="more"></a><p><strong>目录</strong></p><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-binder-与-aidl">2. Binder 与 AIDL</a><ul><li><a href="#21-aidl-客户端">2.1 AIDL 客户端</a></li><li><a href="#22-aidl-服务端">2.2 AIDL 服务端</a></li><li><a href="#23-远程服务的获取与使用">2.3 远程服务的获取与使用</a></li></ul></li><li><a href="#3-binder-框架及-native-层">3. Binder 框架及 Native 层</a><ul><li><a href="#31-binder-native-的入口">3.1 Binder Native 的入口</a></li><li><a href="#32-binder-本地层的整个函数/方法调用过程">3.2 Binder 本地层的整个函数/方法调用过程</a></li><li><a href="#33-binder-设备文件的打开和读写">3.3 Binder 设备文件的打开和读写</a></li></ul></li><li><a href="#4-binder-驱动">4. Binder 驱动</a><ul><li><a href="#41-binder-设备的创建">4.1 binder 设备的创建</a></li><li><a href="#42-binder-协议和数据结构">4.2 binder 协议和数据结构</a></li><li><a href="#43-binder-驱动文件操作">4.3 binder 驱动文件操作</a></li></ul></li><li><a href="#5-binder-与系统服务">5. Binder 与系统服务</a><ul><li><a href="#51-contextgetsystemservice">5.1 Context.getSystemService()</a></li><li><a href="#52-contextgetsystemservice-源码分析">5.2 Context.getSystemService() 源码分析</a></li></ul></li><li><a href="#6-结论">6. 结论</a></li><li><a href="#7-参考">7. 参考</a></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 <code>Context.getSystemService()</code> 来获取系统服务，或直接使用 <code>AIDL</code> 来实现多个程序(APP)间数据交互。</p><p>Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/android_binder.png" alt="android_binder"></p><p>不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。</p><p>我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。</p><h2 id="2-Binder-与-AIDL"><a href="#2-Binder-与-AIDL" class="headerlink" title="2. Binder 与 AIDL"></a>2. Binder 与 AIDL</h2><p>AIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/AIDL.png" alt="AIDL概念图"></p><ul><li><p>Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。</p></li><li><p>Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。</p></li></ul><p>接下来再看具体实现， 完整源代码见 <a href="https://github.com/xdtianyu/AidlExample" target="_blank" rel="noopener">AidlExample</a>。在这个工程中，我们新建了两个应用， <code>app</code> 是客户端代码， <code>remoteservice</code> 则是服务端代码。</p><h3 id="2-1-AIDL-客户端"><a href="#2-1-AIDL-客户端" class="headerlink" title="2.1 AIDL 客户端"></a>2.1 AIDL 客户端</h3><p>在 Android Studio 项目上右键， <code>New</code> -&gt; <code>AIDL</code> -&gt; <code>AIDL File</code> 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.android.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从生成的示例代码可以看出，AIDL 的语法类似 Java， <code>basicTypes()</code> 方法传递的参数只是基本类型。</p><p>如果要传递自定义类型如 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java#L6" target="_blank" rel="noopener">User</a>，则需要实现 <a href="http://developer.android.com/reference/android/os/Parcelable.html" target="_blank" rel="noopener">Parcelable</a> 接口。<code>Parcelable</code> 是一个与 Java <code>Serializable</code> 类似的序列化接口。 </p><p>这样类 <code>User</code> 的实例就可以储存到 <a href="http://developer.android.com/reference/android/os/Parcel.html" target="_blank" rel="noopener">Parcel</a> 中，而 <code>Parcel</code> 则是一个可以通过 <code>IBinder</code> 发送数据或对象引用的容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Parcel 中读取数据，顺序需要和写入保持一致</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        uid = in.readInt();</span><br><span class="line">        name = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须实现，用于从 Parcel 对象中生成类实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据写入到 Parcel 中， 顺序需要与读取保持一致</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(uid);</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再向 <code>IRemoteService.aidl</code> 中添加一个 <code>addUser()</code> 方法，同时新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.android.aidltest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.aidltest.User;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(in User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.android.aidltest;</span><br><span class="line">parcelable User;</span><br></pre></td></tr></table></figure><p>运行编译后，会在 <code>generated</code> 文件夹中生成一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">IRemoteService.java</a> 接口文件。这个接口中有两个内部类 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Stub.Proxy</a>。注意客户端生成的<code>IRemoteService.java</code> 文件和在后文服务端生成的文件内容是相同的。</p><p>客户端会从 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L34" target="_blank" rel="noopener">Stub.asInterface()</a> 得到 <code>IRemoteService (Stub.Proxy)</code> 的实例，这个实例就是一个通过 Binder 传递回来的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L93" target="_blank" rel="noopener">远程对象</a> 的包装。而服务端则需要实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">IRemoteService.addUser()</a> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.xdty.remoteservice.<span class="function">IRemoteService <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> org.xdty.remoteservice.IRemoteService))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((org.xdty.remoteservice.IRemoteService) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-AIDL-服务端"><a href="#2-2-AIDL-服务端" class="headerlink" title="2.2 AIDL 服务端"></a>2.2 AIDL 服务端</h3><p>为了演示进程间通信，我们新建一个模块（应用） <a href="https://github.com/xdtianyu/AidlExample/tree/master/remoteservice" target="_blank" rel="noopener">RemoteService</a> 来实现功能，并在客户端绑定服务。</p><p>按客户端的结构新建 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java" target="_blank" rel="noopener">User.java</a> 文件，并拷贝内容，注意如果需要请修改包名。</p><p>新建服务 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L29" target="_blank" rel="noopener">RemoteService</a> ，覆盖(Override) <code>onBind()</code> 方法并返回 <code>IRemoteService.Stub</code> 实例 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoteService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = RemoteService.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"basicTypes: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"addUser: "</span> + user.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样服务端就实现了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">addUser()</a> 方法，当客户端通过远程对象调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L135" target="_blank" rel="noopener">IRemoteService.Stub.Proxy.addUser()</a> 时，远程对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">mRemote</a> 就会通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 发送命令给服务端，服务端收到命令后在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L76" target="_blank" rel="noopener">Stub.onTransact()</a> 中读取数据并执行 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">addUser()</a> 方法。更多细节我们将在 <a href="#3-binder-%E6%A1%86%E6%9E%B6%E5%8F%8A-native-%E5%B1%82">3. Binder 框架及 Native 层</a> 小节讲述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addUser: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            org.xdty.remoteservice.User _arg0;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _arg0 = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.addUser(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-远程服务的获取与使用"><a href="#2-3-远程服务的获取与使用" class="headerlink" title="2.3 远程服务的获取与使用"></a>2.3 远程服务的获取与使用</h3><p>客户端要使用远程服务，需要绑定服务 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L45" target="_blank" rel="noopener">bindService</a>) 并建立服务连接 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L19" target="_blank" rel="noopener">ServiceConnection</a>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IRemoteService remoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                remoteService.addUser(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"neo"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent().setComponent(<span class="keyword">new</span> ComponentName(</span><br><span class="line">                <span class="string">"org.xdty.remoteservice"</span>,</span><br><span class="line">                <span class="string">"org.xdty.remoteservice.RemoteService"</span>));</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，客户端通过 <code>binderService()</code> 方法，获取远程服务并在服务连接 <code>ServiceConnection</code> 中 <code>onServiceConnected()</code> 回调中得到了 <code>IBinder service</code> 实例， 最后通过上文提到的 <code>IRemoteService.Stub.asInterface(service)</code> 方法得到远程服务 <code>IRemoteService</code> 的实例。通过 <code>IRemoteService.addUser()</code> 方法我们可以像调用本地方法一样调用远程方法。在来看 <code>IRemoteService.addUser()</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.xdty.remoteservice.<span class="function">IRemoteService <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">xdty</span>.<span class="title">remoteservice</span>.<span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">    Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(org.xdty.remoteservice.User user)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> ((user != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                user.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到客户端调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L25" target="_blank" rel="noopener">remoteService.addUser(new User(1, “neo”))</a> 方法实际上是通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IBinder service</a> 实例的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 方法，发送了与服务端约定好的命令 <code>Stub.TRANSACTION_addUser</code>，并将参数按格式打包进 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L137" target="_blank" rel="noopener">Parcel</a> 对象。</p><p>服务端则在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法中收到命令后会对命令和参数重新解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addUser: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            org.xdty.remoteservice.User _arg0;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _arg0 = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.addUser(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>onTransact()</code> 中，最终 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">this.addUser(_arg0)</a> 调用了上文提到的服务端的实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub.addUser()</a> 。</p><p>远程 Binder 对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L42" target="_blank" rel="noopener">mRemote</a> 是由客户端绑定服务时 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L23" target="_blank" rel="noopener">onServiceConnected()</a> 返回的。继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1283" target="_blank" rel="noopener">bindService()</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最后是通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1317#L1320" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> 来绑定服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bindServiceCommon()</span></span><br><span class="line"><span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">    mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">    service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">    sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityManagerNative.getDefault().bindService()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent service, String resolvedType, IServiceConnection connection,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags,  String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    data.writeStrongBinder(connection.asBinder());</span><br><span class="line">    ...</span><br><span class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追踪到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3740" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> ，可以发现 <code>ActivityManager</code> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3750" target="_blank" rel="noopener">IServiceConnection</a>也是一个 <code>AIDL</code> 实现。通过它的 <code>ActivityManagerProxy.bindService()</code> 将绑定请求发送给本地层。</p><p>再从 <code>onServiceConnected()</code> 回调追踪， <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1223" target="_blank" rel="noopener">onServiceConnected()</a> 是由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1175" target="_blank" rel="noopener">LoadedApk.ServiceDispatcher.doConnected()</a> 回调的。</p><p><em>关于更多的 <code>bindService()</code> 远程服务创建及 <code>ServiceConnection</code> 回调， 请参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6745181" target="_blank" rel="noopener">Android应用程序绑定服务（bindService）的过程源代码分析</a></em></p><p><em>利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 <a href="https://github.com/xdtianyu/CallerInfo/tree/master/plugin/src/main" target="_blank" rel="noopener">CallerInfo Plugin</a> 的实现 </em></p><p>从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。</p><h2 id="3-Binder-框架及-Native-层"><a href="#3-Binder-框架及-Native-层" class="headerlink" title="3. Binder 框架及 Native 层"></a>3. Binder 框架及 Native 层</h2><p>Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/Binder.png" alt="Binder框架图片"></p><p>Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 <a href="#4-binder-%E9%A9%B1%E5%8A%A8">4. Binder 驱动</a> 小节详细讲述。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native.png" alt="Binder本地框架图片"></p><p>JNI 的代码位于 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/core/jni" target="_blank" rel="noopener">frameworks/base/core/jni</a> 目录下，主要是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp" target="_blank" rel="noopener">android_util_Binder.cpp</a> 文件和头文件 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.h" target="_blank" rel="noopener">android_util_Binder.h</a></p><p>Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 <code>libandroid_runtime.so</code> 系统库。</p><p>Binder 本地层的代码在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/libs/binder" target="_blank" rel="noopener">frameworks/native/libs/binder</a> 目录下， 此目录在 Android 系统编译后会生成 <code>libbinder.so</code> 文件，供 JNI 调用。<code>libbinder</code> 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/include/binder" target="_blank" rel="noopener">frameworks/native/include/binder</a> 目录下。</p><h3 id="3-1-Binder-Native-的入口"><a href="#3-1-Binder-Native-的入口" class="headerlink" title="3.1 Binder Native 的入口"></a>3.1 Binder Native 的入口</h3><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IInterface.cpp#L33" target="_blank" rel="noopener">IInterface.cpp</a> 是 Binder 本地层入口，与 java 层的 <code>android.os.IInterface</code> 对应，提供 <code>asBinder()</code> 的实现，返回 <code>IBinder</code> 对象。</p><p>在头文件中有两个类 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L50" target="_blank" rel="noopener">BnInterface (Binder Native Interface)</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L63" target="_blank" rel="noopener">BpInterface (Binder Proxy Interface)</a>, 对应于 java 层的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Proxy</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; IInterface::asBinder(<span class="keyword">const</span> IInterface* iface)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iface == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;IInterface*&gt;(iface)-&gt;onAsBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16&amp; _descriptor);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp;     <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>BnInterface</code> 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。<code>BpInterface</code> 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。</p><h3 id="3-2-Binder-本地层的整个函数-方法调用过程"><a href="#3-2-Binder-本地层的整个函数-方法调用过程" class="headerlink" title="3.2 Binder 本地层的整个函数/方法调用过程"></a>3.2 Binder 本地层的整个函数/方法调用过程</h3><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native_stack.png" alt="Binder本地函数调用图"></p><p>1. Java 层 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IRemoteService.Stub.Proxy</a> 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L501" target="_blank" rel="noopener">android.os.IBinder (实现在 android.os.Binder.BinderProxy)</a> 的 <code>transact()</code> 发送 <code>Stub.TRANSACTION_addUser</code> 命令。</p><p>2. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L507" target="_blank" rel="noopener">BinderProxy.transact()</a> 进入 native 层。</p><p>3. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">jni</a> 转到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">android_os_BinderProxy_transact()</a> 函数。</p><p>4. 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1124" target="_blank" rel="noopener">IBinder-&gt;transact</a> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>gBinderProxyOffsets.mObject</code> 则是在 java 层调用 <code>IBinder.getContextObject()</code> 时在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L580" target="_blank" rel="noopener">javaObjectForIBinder</a> 函数中设置的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</span><br><span class="line">    <span class="comment">// The proxy holds a reference to the native object.</span></span><br><span class="line">    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">    val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L85" target="_blank" rel="noopener">ProcessState::getContextObject()</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L220" target="_blank" rel="noopener">ProcessState::getStrongProxyForHandle()</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    ...</span><br><span class="line">    b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">    result = b;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 <a href>android_os_BinderProxy_transact()</a> 函数实际上调用的是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L159" target="_blank" rel="noopener">BpBinder::transact()</a> 函数。</p><p>5. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L164" target="_blank" rel="noopener">BpBinder::transact()</a> 则又调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L548" target="_blank" rel="noopener">IPCThreadState::self()-&gt;transact()</a> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由函数内容可以看出， 数据再一次通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L904" target="_blank" rel="noopener">writeTransactionData()</a> 传递给 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L934" target="_blank" rel="noopener">mOut</a> 进行写入操作。 <code>mOut</code> 是一个 Parcel 对象， 声明在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IPCThreadState.h#L123" target="_blank" rel="noopener">IPCThreadState.h</a> 文件中。之后则调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L583" target="_blank" rel="noopener">waitForResponse()</a> 函数。</p><p>6. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L712" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> 在一个 <code>while</code> 循环里不断的调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">talkWithDriver()</a> 并检查是否有数据返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> 函数是真正与 binder 驱动交互的实现。<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 就是使用系统调用函数 <code>ioctl</code> 向 binder 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="comment">// 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L718" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> ,就将数据发送给了 Binder 驱动。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L723" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> ，可以从 第6步 发现 <code>IPCThreadState</code> 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L787" target="_blank" rel="noopener">executeCommand(cmd)</a> 函数。</p><p>8. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L947" target="_blank" rel="noopener">IPCThreadState::executeCommand()</a> 处理 Binder 驱动返回命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            ...</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">                error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9. 可以看出其调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">BBinder::transact()</a> 函数，将数据返回给上层。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10. 而这里的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags)</a> 中的 <code>b (BBinder)</code> 是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L217" target="_blank" rel="noopener">JavaBBinder</a> 的实例，所以会调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L247" target="_blank" rel="noopener">JavaBBinder::onTransact()</a> 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line">        ...</span><br><span class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, <span class="string">"execTransact"</span>, <span class="string">"(IJJI)Z"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11. 可见 JNI 通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L260" target="_blank" rel="noopener">gBinderOffsets.mExecTransact</a> 最后执行了 <code>android.os.Binder</code> 的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L865" target="_blank" rel="noopener">execTransact()</a> 方法。</p><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L442" target="_blank" rel="noopener">execTransact()</a> 方法是 jni 回调的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry point from android_util_Binder.cpp's onTransact</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>12. 而我们则在服务端 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub</a> 重载了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法，所以数据最后会回到我们的服务端并执行服务端实现的 <code>addUser()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">xdty</span>.<span class="title">remoteservice</span>.<span class="title">IRemoteService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_addUser: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                org.xdty.remoteservice.User _arg0;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                    _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.addUser(_arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 <code>BC_TRANSACTION</code> 到 Binder 驱动，服务端进程监听返回的 <code>BR_TRANSACTION</code> 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 <code>BC_REPLY</code> 命令， 客户端监听 <code>BR_REPLY</code> 命令。</p><h3 id="3-3-Binder-设备文件的打开和读写"><a href="#3-3-Binder-设备文件的打开和读写" class="headerlink" title="3.3 Binder 设备文件的打开和读写"></a>3.3 Binder 设备文件的打开和读写</h3><p><strong>1. 设备的打开</strong></p><p>在上一小节中我们看到 JNI 过程中调用了 <code>ProcessState::getContextObject()</code> 函数， 在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">ProcessState</a> 初始化时会打开 binder 设备</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    ...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L311#L337" target="_blank" rel="noopener">open_driver()</a> 函数内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开设备文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取驱动版本</span></span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查驱动版本是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置最多 15 个 binder 线程</span></span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 设备的读写</strong></p><p>打开设备文件后，文件描述符被保存在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">mDriverFD</a>， 通过系统调用 <code>ioctl</code> 函数操作 <code>mDriverFD</code> 就可以实现和 binder 驱动的交互。</p><p>对 Binder 设备文件的所有读写及关闭操作则都在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L805" target="_blank" rel="noopener">IPCThreadState</a> 中，如上一小节提及到的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver</a> 函数</p><p><code>talkWithDriver()</code> 函数封装了 <code>BINDER_WRITE_READ</code> 命令，会从 binder 驱动读取或写入封装在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">binder_write_read</a> 结构体中的本地或远程对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;   </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">        err = NO_ERROR;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。</p><h2 id="4-Binder-驱动"><a href="#4-Binder-驱动" class="headerlink" title="4. Binder 驱动"></a>4. Binder 驱动</h2><p>关于 binder 驱动建议参考另一篇文章 <a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a> <a href="[Android Binder](https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11">原文</a>，本小节仍需要完善。</p><p>Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_reference.png" alt="Binder reference"></p><p>Binder 驱动的代码位于 kernel 代码的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/tree/master/drivers/staging/android" target="_blank" rel="noopener">drivers/staging/android</a> 目录下。主文件是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c" target="_blank" rel="noopener">binder.c</a></p><p>进程间传输的数据被称为 Binder 对象，它是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L49" target="_blank" rel="noopener">flat_binder_object</a>，结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></span><br><span class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* extra data associated with local object */</span></span><br><span class="line">    <span class="keyword">void</span>            *cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 类型 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">type</a> 描述了 Binder 对象的类型，包含 <code>BINDER</code>(本地对象)、<code>HANDLE</code>(远程对象)、 <code>FD</code> 三大类(五种)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L52" target="_blank" rel="noopener">flags</a> 则表述了<a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L110" target="_blank" rel="noopener">传输方式</a>，如异步、无返回等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> transaction_flags &#123;</span><br><span class="line">    TF_ONE_WAY  = <span class="number">0x01</span>, <span class="comment">/* this is a one-way call: async, no return */</span></span><br><span class="line">    TF_ROOT_OBJECT  = <span class="number">0x04</span>, <span class="comment">/* contents are the component's root object */</span></span><br><span class="line">    TF_STATUS_CODE  = <span class="number">0x08</span>, <span class="comment">/* contents are a 32-bit status code */</span></span><br><span class="line">    TF_ACCEPT_FDS   = <span class="number">0x10</span>, <span class="comment">/* allow replies with file descriptors */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>flat_binder_object</code> 中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L55" target="_blank" rel="noopener">union 联合体</a> 就是要传输的数据，当类型为 <code>BINDER</code> 时， 数据就是一个本地对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L56" target="_blank" rel="noopener">*binder</a>，而类型为 <code>HANDLE</code> 时，数据则是一个远程对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L57" target="_blank" rel="noopener">handle</a>。</p><p>当 <code>flat_binder_object</code> 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1671" target="_blank" rel="noopener">binder_transaction</a> 的实现。</p><p>该如何理解本地 <code>BINDER</code> 对象和远程 <code>HANDLE</code> 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 <code>RemoteService</code> 有个对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>，对于 <code>RemoteService</code> 来说，<code>mBinder</code> 就是一个本地的 <code>BINDER</code> 对象；如果进程 <code>app</code> 通过 Binder 驱动访问 <code>RemoteService</code> 的 <code>mBinder</code> 对象，对于 <code>app</code> 来说， <code>mBinder</code> 就是一个 <code>HANDLE</code>。因此，从根本上来说 <code>handle</code> 和 <code>binder</code> 都指向 <code>RemoteService</code> 的 <code>mBinder</code>。本地对象还可以带有额外的数据，保存在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L61" target="_blank" rel="noopener">cookie</a> 中。</p><p>Binder 驱动直接操作的最外层数据结构是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L117" target="_blank" rel="noopener">binder_transaction_data</a>， Binder 对象 <code>flat_binder_object</code> 被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">binder_transaction_data</a> 结构体中。</p><p><code>binder_transaction_data</code> 数据结构才是真正传输的数据，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></span><br><span class="line"><span class="comment">     * identifying the target and contents of the transaction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span>  handle; <span class="comment">/* target descriptor of command transaction */</span></span><br><span class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></span><br><span class="line">    &#125; target;</span><br><span class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* General information about the transaction. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">    <span class="keyword">pid_t</span>       sender_pid;</span><br><span class="line">    <span class="keyword">uid_t</span>       sender_euid;</span><br><span class="line">    <span class="keyword">size_t</span>      data_size;  <span class="comment">/* number of bytes of data */</span></span><br><span class="line">    <span class="keyword">size_t</span>      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></span><br><span class="line"><span class="comment">     * follows here; otherwise, it ends with a pointer to</span></span><br><span class="line"><span class="comment">     * the data buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">/* transaction data */</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</span><br><span class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">8</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>flat_binder_object</code> 就被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">*buffer</a>中，其中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L126" target="_blank" rel="noopener">unsigned int   code;</a> 则是传输命令，描述了 Binder 对象执行的操作。</p><h3 id="4-1-binder-设备的创建"><a href="#4-1-binder-设备的创建" class="headerlink" title="4.1 binder 设备的创建"></a>4.1 binder 设备的创建</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3747" target="_blank" rel="noopener">device_initcall()</a> 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    <span class="comment">// 设备文件 /dev/binder</span></span><br><span class="line">    .name = <span class="string">"binder"</span>,</span><br><span class="line">    <span class="comment">// 设备文件操作</span></span><br><span class="line">    .fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注册字符设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_miscdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调试文件， 在 /sys/kernel/debug/binder 目录下</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">        debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">                    S_IRUGO,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_state_fops);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure><p>可以看出 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3704" target="_blank" rel="noopener">binder_init()</a> 使用 <code>misc_register()</code> 函数创建了 binder 设备。从 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3716" target="_blank" rel="noopener">misc_register(&amp;binder_miscdev);</a> 及 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3695" target="_blank" rel="noopener">.name = “binder”</a> 可以看出， binder 向 kernel 注册了一个 <code>/dev/binder</code> 的字符设备，而文件操作都在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面 <code>binder_fops</code> 结构体可以看出，主要的操作是 <code>binder_ioctl()</code> <code>binder_mmap()</code> <code>binder_open()</code> 等函数实现的。</p><h3 id="4-2-binder-协议和数据结构"><a href="#4-2-binder-协议和数据结构" class="headerlink" title="4.2 binder 协议和数据结构"></a>4.2 binder 协议和数据结构</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 文件中定义了 binder 协议和重要的数据结构。</p><p>首先在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">enum</a> 中定义了 binder 处理的类型，引用或是句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这段宏定义则是在 <code>ioctl</code> 函数调用时可用的具体命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ       _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT     _IOW(<span class="meta-string">'b'</span>, 3, int64_t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY    _IOW(<span class="meta-string">'b'</span>, 6, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L166" target="_blank" rel="noopener">BinderDriverReturnProtocol</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L254" target="_blank" rel="noopener">BinderDriverCommandProtocol</a> 中 则分别定义了 客户端调用 和 服务端 返回的命令。</p><h3 id="4-3-binder-驱动文件操作"><a href="#4-3-binder-驱动文件操作" class="headerlink" title="4.3 binder 驱动文件操作"></a>4.3 binder 驱动文件操作</h3><p>上文已经提到，所有的操作定义在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中，下面讲述这些操作。</p><p><strong>设备的打开 - binder_open() 函数</strong></p><p>用户空间在打开 <code>/dev/binder</code> 设备时，驱动会出发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3004" target="_blank" rel="noopener">binder_open()</a> 函数的响应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 binder_proc 数据结构内存</span></span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加当前线程/进程的引用计数并赋值给tsk</span></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加BINDER_STAT_PROC的对象计数</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    <span class="comment">// 保存进程 id</span></span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    <span class="comment">// 驱动文件 private_data 指向 proc</span></span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>驱动文件释放 - binder_release() 函数</strong></p><p>在用户空间关闭驱动设备文件时，会调用 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3068" target="_blank" rel="noopener">binder_release()</a> 函数，清理 binder_proc 对象，释放占用的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">binder_defer_work(struct binder_proc *proc, <span class="keyword">enum</span> binder_deferred_state defer)</span><br><span class="line">&#123;</span><br><span class="line">    mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line">    proc-&gt;deferred_work |= defer;</span><br><span class="line">    <span class="keyword">if</span> (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123;</span><br><span class="line">        <span class="comment">// 添加到释放队列中</span></span><br><span class="line">        hlist_add_head(&amp;proc-&gt;deferred_work_node,</span><br><span class="line">                &amp;binder_deferred_list);</span><br><span class="line">        queue_work(binder_deferred_workqueue, &amp;binder_deferred_work);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;binder_deferred_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存映射 - binder_mmap() 函数</strong></p><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2905" target="_blank" rel="noopener">binder_mmap()</a> 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="comment">// 获得 binder_proc 对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多只分配 4M 的内存</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 flags</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br><span class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line">    <span class="comment">// 检查是否已经映射</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内核虚拟内存空间</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将申请到的内存地址保存到 binder_proc 对象中</span></span><br><span class="line">    proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针</span></span><br><span class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个页的物理内存</span></span><br><span class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存提供给 binder_buffer</span></span><br><span class="line">    buffer = proc-&gt;buffer;</span><br><span class="line">    <span class="comment">// 初始化 proc-&gt;buffers 链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">    <span class="comment">// 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中</span></span><br><span class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">    barrier();</span><br><span class="line">    proc-&gt;files = get_files_struct(proc-&gt;tsk);</span><br><span class="line">    proc-&gt;vma = vma;</span><br><span class="line">    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>驱动命令接口 - binder_ioctl() 函数</strong></p><p>用户态程序调用 <code>ioctl</code> 系统函数向 <code>/dev/binder</code> 设备发送数据时，会触发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2734" target="_blank" rel="noopener">binder_ioctl()</a> 函数响应。</p><p>上文数据结构中已经提到了 <code>binder_ioctl</code> 可以处理的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L87" target="_blank" rel="noopener">命令</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心命令，数据的读写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ       _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="comment">// 设置最大线程数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></span><br><span class="line"><span class="comment">// 设置 context manager</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></span><br><span class="line"><span class="comment">// 线程退出命令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></span><br><span class="line"><span class="comment">// binder 驱动的版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有错误</span></span><br><span class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">// 获取 binder_thread 对象</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行写入操作</span></span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行读取操作</span></span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 操作完成后将数据返回给用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:</span><br><span class="line">        <span class="comment">// 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        <span class="comment">// 检查是否已经设置</span></span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 context manager</span></span><br><span class="line">        ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;</span><br><span class="line">                ret = -EPERM;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">        <span class="comment">// 创建 binder_context_mgr_node 节点</span></span><br><span class="line">        binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化节点数据</span></span><br><span class="line">        binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">        binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">        <span class="comment">// 线程退出，释放资源</span></span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION:</span><br><span class="line">        <span class="comment">// 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">nodes</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要插入节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        node = rb_entry(parent, struct binder_node, rb_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为要插入节点分配内存空间</span></span><br><span class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    node-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    node-&gt;proc = proc;</span><br><span class="line">    node-&gt;ptr = ptr;</span><br><span class="line">    node-&gt;cookie = cookie;</span><br><span class="line">    node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BINDER_WRITE_READ 处理过程</strong></p><p>在 binder 本地层中，我们看到在 <code>IPCThreadState::talkWithDriver()</code> 函数中， binder 本地层通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 命令的形式，与 binder 驱动交互。</p><p>可以看出 <code>ioctl()</code> 的第三个参数是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L69" target="_blank" rel="noopener">binder_write_read</a> 结构体</p><p>binder.h 头文件中定义了两个数据类型, 一个是 <code>binder_write_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>write_size</code> 和 <code>read_size</code> 表示需要被读写的字节数， <code>write_consumed</code> 和 <code>read_consumed</code> 表示已经被 binder 驱动读写的字节数， <code>write_buffer</code> 和 <code>read_buffer</code> 则是指向被读写数据的指针。</p><p>具体的读写操作被 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1852" target="_blank" rel="noopener">binder_thread_write</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2266" target="_blank" rel="noopener">binder_thread_read</a> 实现。</p><p><strong>数据写入 - binder_thread_write() 函数</strong></p><p>将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="comment">// 用户空间数据，起始地址和结束地址</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">        <span class="comment">// 从用户空间获取操作命令</span></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            <span class="comment">// 增加命令计数器</span></span><br><span class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="comment">// 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref</span></span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BC_DECREFS: &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> target;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *debug_string;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取目标进程节点描述 desc</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="comment">// 索描述为 0 表示 context manager 进程</span></span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; binder_context_mgr_node &amp;&amp;</span><br><span class="line">                (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123;</span><br><span class="line">                <span class="comment">// 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用</span></span><br><span class="line">                ref = binder_get_ref_for_node(proc,</span><br><span class="line">                           binder_context_mgr_node);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用</span></span><br><span class="line">                ref = binder_get_ref(proc, target);</span><br><span class="line">            <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">                debug_string = <span class="string">"IncRefs"</span>;</span><br><span class="line">                <span class="comment">// 增加弱引用计数</span></span><br><span class="line">                binder_inc_ref(ref, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">                debug_string = <span class="string">"Acquire"</span>;</span><br><span class="line">                <span class="comment">// 增加强引用计数</span></span><br><span class="line">                binder_inc_ref(ref, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">                debug_string = <span class="string">"Release"</span>;</span><br><span class="line">                <span class="comment">// 减少强引用计数</span></span><br><span class="line">                binder_dec_ref(ref, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BC_DECREFS:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                debug_string = <span class="string">"DecRefs"</span>;</span><br><span class="line">                <span class="comment">// 减少弱引用计数</span></span><br><span class="line">                binder_dec_ref(ref, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS_DONE:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_DONE: &#123;</span><br><span class="line">            <span class="keyword">void</span> __user *node_ptr;</span><br><span class="line">            <span class="keyword">void</span> *cookie;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从用户空间读取 node_ptr</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(node_ptr, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">            <span class="comment">// 从用户空间读取 cookie</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">            <span class="comment">// 获得节点</span></span><br><span class="line">            node = binder_get_node(proc, node_ptr);</span><br><span class="line">            <span class="comment">// 没有找到则返回</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></span><br><span class="line">                    <span class="string">"%s u%p no match\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd == BC_INCREFS_DONE ?</span><br><span class="line">                    <span class="string">"BC_INCREFS_DONE"</span> :</span><br><span class="line">                    <span class="string">"BC_ACQUIRE_DONE"</span>,</span><br><span class="line">                    node_ptr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cookie 不匹配则返回</span></span><br><span class="line">            <span class="keyword">if</span> (cookie != node-&gt;cookie) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d %s u%p node %d"</span></span><br><span class="line">                    <span class="string">" cookie mismatch %p != %p\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd == BC_INCREFS_DONE ?</span><br><span class="line">                    <span class="string">"BC_INCREFS_DONE"</span> : <span class="string">"BC_ACQUIRE_DONE"</span>,</span><br><span class="line">                    node_ptr, node-&gt;debug_id,</span><br><span class="line">                    cookie, node-&gt;cookie);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cmd == BC_ACQUIRE_DONE) &#123;</span><br><span class="line">                node-&gt;pending_strong_ref = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;pending_weak_ref = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 减少节点使用计数</span></span><br><span class="line">            binder_dec_node(node, cmd == BC_ACQUIRE_DONE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放 binder_bffer</span></span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            <span class="keyword">void</span> __user *data_ptr;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从用户空间获取 data_ptr</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(data_ptr, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找 binder_buffer</span></span><br><span class="line">            buffer = binder_buffer_lookup(proc, data_ptr);</span><br><span class="line">            <span class="comment">// 没有找到则返回</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></span><br><span class="line">                    <span class="string">"BC_FREE_BUFFER u%p no match\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, data_ptr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不允许用户释放则返回</span></span><br><span class="line">            <span class="keyword">if</span> (!buffer-&gt;allow_user_free) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></span><br><span class="line">                    <span class="string">"BC_FREE_BUFFER u%p matched "</span></span><br><span class="line">                    <span class="string">"unreturned buffer\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, data_ptr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 buffer-&gt;transaction 置空</span></span><br><span class="line">            <span class="keyword">if</span> (buffer-&gt;transaction) &#123;</span><br><span class="line">                buffer-&gt;transaction-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">                buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))</span><br><span class="line">                    buffer-&gt;target_node-&gt;has_async_transaction = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放 binder_buffer 对象</span></span><br><span class="line">            trace_binder_transaction_buffer_release(buffer);</span><br><span class="line">            binder_transaction_buffer_release(proc, buffer, <span class="literal">NULL</span>);</span><br><span class="line">            binder_free_buf(proc, buffer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binder 数据传递处理</span></span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从用户空间拷贝 binder_transaction_data 对象</span></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            <span class="comment">// 实际的传输函数，在下文讲解</span></span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态</span></span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></span><br><span class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></span><br><span class="line">                    <span class="string">"after BC_ENTER_LOOPER\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span>) &#123;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></span><br><span class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></span><br><span class="line">                    <span class="string">"without request\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                proc-&gt;requested_threads--;</span><br><span class="line">                proc-&gt;requested_threads_started++;</span><br><span class="line">            &#125;</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态</span></span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></span><br><span class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></span><br><span class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125;</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态</span></span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知</span></span><br><span class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> target;</span><br><span class="line">            <span class="keyword">void</span> __user *cookie;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从用户空间获取 binder_ref 描述 desc</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="comment">// 从用户空间获取 cookie</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">            <span class="comment">// 获取 binder_ref 引用</span></span><br><span class="line">            ref = binder_get_ref(proc, target);</span><br><span class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d %s "</span></span><br><span class="line">                    <span class="string">"invalid ref %d\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?</span><br><span class="line">                    <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</span><br><span class="line">                    <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>,</span><br><span class="line">                    target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;death) &#123;</span><br><span class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></span><br><span class="line">                        <span class="string">"d BC_REQUEST_DEATH_NOTI"</span></span><br><span class="line">                        <span class="string">"FICATION death notific"</span></span><br><span class="line">                        <span class="string">"ation already set\n"</span>,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 为 binder_ref_death 对象分配内存空间</span></span><br><span class="line">                death = kzalloc(<span class="keyword">sizeof</span>(*death), GFP_KERNEL);</span><br><span class="line">                <span class="keyword">if</span> (death == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    thread-&gt;return_error = BR_ERROR;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 初始化 binder_ref_death 对象</span></span><br><span class="line">                binder_stats_created(BINDER_STAT_DEATH);</span><br><span class="line">                INIT_LIST_HEAD(&amp;death-&gt;work.entry);</span><br><span class="line">                death-&gt;cookie = cookie;</span><br><span class="line">                ref-&gt;death = death;</span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</span><br><span class="line">                    <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                        <span class="comment">// 唤醒目标进程</span></span><br><span class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;death == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></span><br><span class="line">                        <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></span><br><span class="line">                        <span class="string">"CATION death notificat"</span></span><br><span class="line">                        <span class="string">"ion not active\n"</span>,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                death = ref-&gt;death;</span><br><span class="line">                <span class="keyword">if</span> (death-&gt;cookie != cookie) &#123;</span><br><span class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></span><br><span class="line">                        <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></span><br><span class="line">                        <span class="string">"CATION death notificat"</span></span><br><span class="line">                        <span class="string">"ion cookie mismatch "</span></span><br><span class="line">                        <span class="string">"%p != %p\n"</span>,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                        death-&gt;cookie, cookie);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 ref-&gt;death 置空</span></span><br><span class="line">                ref-&gt;death = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (list_empty(&amp;death-&gt;work.entry)) &#123;</span><br><span class="line">                    death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                    <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                        <span class="comment">// 唤醒目标进程</span></span><br><span class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);</span><br><span class="line">                    death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_DEAD_BINDER_DONE: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">            <span class="keyword">void</span> __user *cookie;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span> = <span class="title">NULL</span>;</span></span><br><span class="line">            <span class="comment">// 从用户空间获取 cookie</span></span><br><span class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">            list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">tmp_death</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">binder_ref_death</span>, <span class="title">work</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (tmp_death-&gt;cookie == cookie) &#123;</span><br><span class="line">                    death = tmp_death;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (death == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d BC_DEAD"</span></span><br><span class="line">                    <span class="string">"_BINDER_DONE %p not found\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, cookie);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list_del_init(&amp;death-&gt;work.entry);</span><br><span class="line">            <span class="comment">// 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span></span><br><span class="line">            <span class="keyword">if</span> (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) &#123;</span><br><span class="line">                death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">                    wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>binder_transaction() 函数</strong></p><p>在上文处理 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2041" target="_blank" rel="noopener">BC_TRANSACTION</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2042" target="_blank" rel="noopener">BC_REPLY</a> 时，调用了 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1417" target="_blank" rel="noopener">binder_transaction()</a> 函数。我们继续追踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// BC_REPLY 处理流程</span></span><br><span class="line">        <span class="comment">// 得到 binder_transaction 对象</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_empty_call_stack;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        <span class="comment">// 获取目标线程</span></span><br><span class="line">        target_thread = in_reply_to-&gt;from;</span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// BC_TRANSACTION 处理流程</span></span><br><span class="line">        <span class="comment">// 查找目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            <span class="comment">// 获取 binder_ref 对象</span></span><br><span class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 索引为 0 则返回 context manager</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                    <span class="comment">// 获得目标线程</span></span><br><span class="line">                    target_thread = tmp-&gt;from;</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置要处理的目标进程或目标线程任务</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 binder_transaction 对象分配内存空间</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line"></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置 binder_transaction 对象</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 binder_buffer 分配内存空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="comment">// 设置 binder_buffer</span></span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从用户空间拷贝数据到 binder_buffer</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        <span class="comment">// 为 flat_binder_object 赋值</span></span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="comment">// 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE</span></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 获取 binder_node 节点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    return_error = BR_FAILED_REPLY;</span><br><span class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取 binder_ref 对象</span></span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">            <span class="comment">// 转换类型</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="comment">// 获取 binder_ref 对象</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span>*<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">            <span class="comment">// 转换类型</span></span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件类型</span></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            <span class="keyword">int</span> target_fd;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">            <span class="comment">// 获得文件对象</span></span><br><span class="line">            file = fget(fp-&gt;handle);</span><br><span class="line">            <span class="comment">// 分配一个新的文件描述符</span></span><br><span class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</span><br><span class="line">            task_fd_install(target_proc, target_fd, file);</span><br><span class="line">            fp-&gt;handle = target_fd;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象</span></span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        <span class="comment">// 同步状态(双向)需要设置回复</span></span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步传输不需要设置回复</span></span><br><span class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list = &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        <span class="comment">// 唤醒目标线程</span></span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据读取 - binder_thread_read() 函数</strong></p><p>用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一次操作时向用户空间返回 BR_NOOP 命令</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 获取将要处理的任务</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></span><br><span class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></span><br><span class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">            wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞且没有数据则返回 EAGAIN</span></span><br><span class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 阻塞则进入睡眠状态，等待可操作的任务</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--;</span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 binder_work 对象</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">            <span class="comment">// 获取 binder_transaction 对象</span></span><br><span class="line">            t = container_of(w, struct binder_transaction, work);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 返回 BR_TRANSACTION_COMPLETE 命令</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">            binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 work 链表中删除并释放内存</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_NODE: &#123;</span><br><span class="line">            <span class="comment">// 获得 binder_node 节点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">binder_node</span>, <span class="title">work</span>);</span></span><br><span class="line">            <span class="keyword">uint32_t</span> cmd = BR_NOOP;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cmd_name;</span><br><span class="line">            <span class="comment">// 根据节点类型，增加/获取、减少/释放节点索引</span></span><br><span class="line">            <span class="keyword">int</span> strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs;</span><br><span class="line">            <span class="keyword">int</span> weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong;</span><br><span class="line">            <span class="comment">// 构造 BR_* 命令</span></span><br><span class="line">            <span class="keyword">if</span> (weak &amp;&amp; !node-&gt;has_weak_ref) &#123;</span><br><span class="line">                cmd = BR_INCREFS;</span><br><span class="line">                cmd_name = <span class="string">"BR_INCREFS"</span>;</span><br><span class="line">                node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;pending_weak_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;local_weak_refs++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strong &amp;&amp; !node-&gt;has_strong_ref) &#123;</span><br><span class="line">                cmd = BR_ACQUIRE;</span><br><span class="line">                cmd_name = <span class="string">"BR_ACQUIRE"</span>;</span><br><span class="line">                node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;pending_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;local_strong_refs++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strong &amp;&amp; node-&gt;has_strong_ref) &#123;</span><br><span class="line">                cmd = BR_RELEASE;</span><br><span class="line">                cmd_name = <span class="string">"BR_RELEASE"</span>;</span><br><span class="line">                node-&gt;has_strong_ref = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!weak &amp;&amp; node-&gt;has_weak_ref) &#123;</span><br><span class="line">                cmd = BR_DECREFS;</span><br><span class="line">                cmd_name = <span class="string">"BR_DECREFS"</span>;</span><br><span class="line">                node-&gt;has_weak_ref = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向用户空间返回命令</span></span><br><span class="line">            <span class="keyword">if</span> (cmd != BR_NOOP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">                <span class="keyword">if</span> (put_user(node-&gt;ptr, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">                <span class="keyword">if</span> (put_user(node-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">                binder_stat_br(proc, thread, cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list_del_init(&amp;w-&gt;entry);</span><br><span class="line">                <span class="keyword">if</span> (!weak &amp;&amp; !strong) &#123;</span><br><span class="line">                    rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">                    kfree(node);</span><br><span class="line">                    binder_stats_deleted(BINDER_STAT_NODE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 binder_ref_death 对象</span></span><br><span class="line">            death = container_of(w, struct binder_ref_death, work);</span><br><span class="line">            <span class="comment">// 构造返回命令</span></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</span><br><span class="line">                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cmd = BR_DEAD_BINDER;</span><br><span class="line">            <span class="comment">// 向用户空间返回命令</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="comment">// 将 cookie 返回给用户空间</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line">            binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123;</span><br><span class="line">                list_del(&amp;w-&gt;entry);</span><br><span class="line">                kfree(death);</span><br><span class="line">                binder_stats_deleted(BINDER_STAT_DEATH);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);</span><br><span class="line">            <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)</span><br><span class="line">                <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            <span class="comment">// 获得 binder_node 节点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="comment">// 将数据封装到 binder_transaction_data 对象</span></span><br><span class="line">            tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">            tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority = task_nice(current);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">                !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">                binder_set_nice(t-&gt;priority);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">                binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">            <span class="comment">// 设置返回的命令类型</span></span><br><span class="line">            cmd = BR_TRANSACTION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="comment">// 拷贝 binder_transaction_data 对象到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除 binder_transaction 并释放空间</span></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">            kfree(t);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。</p><h2 id="5-Binder-与系统服务"><a href="#5-Binder-与系统服务" class="headerlink" title="5. Binder 与系统服务"></a>5. Binder 与系统服务</h2><h3 id="5-1-Context-getSystemService"><a href="#5-1-Context-getSystemService" class="headerlink" title="5.1 Context.getSystemService()"></a>5.1 Context.getSystemService()</h3><p>Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.Class&lt;T" target="_blank" rel="noopener">服务</a>) 主要有 <code>WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager</code></p><p>我们可以通过 <code>Context.getSystemService(String name)</code> 来获取 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String" target="_blank" rel="noopener">服务</a>)。</p><p>例如 可以通过如下方法从 xml 中插入新的视图</p><pre><code>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);inflater.inflate(R.layout.view, root, true);</code></pre><h3 id="5-2-Context-getSystemService-源码分析"><a href="#5-2-Context-getSystemService-源码分析" class="headerlink" title="5.2 Context.getSystemService() 源码分析"></a>5.2 Context.getSystemService() 源码分析</h3><p>追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1364" target="_blank" rel="noopener">ContextImpl</a> <code>getSystemService()</code> 源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L719" target="_blank" rel="noopener">SystemServiceRegistry</a> 源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets a system service from a given context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追踪 <code>SYSTEM_SERVICE_FETCHERS</code> 可以发现在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L318" target="_blank" rel="noopener">SystemServiceRegistry</a> 静态区中注册了几乎所有的系统服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">registerService(Context.LOCATION_SERVICE, LocationManager.class,</span><br><span class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LocationManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocationManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocationManager(ctx, ILocationManager.Stub.asInterface(b));</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码片断中，<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L322" target="_blank" rel="noopener">PhoneLayoutInflater</a> 最终回到了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/view/LayoutInflater.java#L204" target="_blank" rel="noopener">LayoutInflater</a>。而 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/LocationManager.java#L315" target="_blank" rel="noopener">LocationManager</a> 则是对 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/ILocationManager.aidl#L39" target="_blank" rel="noopener">ILocationManager</a> 的封装。可以发现，在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/location/java/android/location" target="_blank" rel="noopener">frameworks/base/location/java/android/location</a> 包下含有大量的 AIDL 文件。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L49" target="_blank" rel="noopener">ServiceManager.getService(Context.LOCATION_SERVICE)</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a reference to a service with the given name.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the service to get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码片断可以看出，<code>ServiceManager</code> 会从 <code>sCache</code> 缓存或 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">IServiceManager</a> 中查找服务并返回一个 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L85" target="_blank" rel="noopener">IBinder</a> 对象。这个 <code>IBinder</code> 就是一个远程对象，可以通过它与其他进程交互。 </p><p>继续深入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L55" target="_blank" rel="noopener">getIServiceManager().getService(name)</a> , 进入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">ServiceManagerNative</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cast a Binder object into a service manager interface, generating</span></span><br><span class="line"><span class="comment"> * a proxy if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IServiceManager in =</span><br><span class="line">        (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">        IBinder binder = reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边代码片断可以看到，<code>ServiceManager.getIServiceManager()</code> 返回的是一个 <code>ServiceManagerProxy</code>, 而 <code>ServiceManager.getService()</code> 则是在 <code>ServiceManagerProxy</code> 中通过 <code>ServiceManager</code> 的远程 <code>Binder</code> 对象 <code>mRemote</code>，操作 <code>Parcel</code> 数据，调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L223" target="_blank" rel="noopener">IBinder.transact(int code, Parcel data, Parcel reply, int flags)</a> 方法来发送请求，并通过 <code>reply.readStrongBinder()</code> 返回了要查找的服务的远程对象。</p><p>可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。</p><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。</p><p>2. 上层的 <code>android.os.Binder</code> 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。</p><p>3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 <code>transact</code> 和 <code>onTransact</code> 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><a href="http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/" target="_blank" rel="noopener">Android Binder机制</a></p><p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder</a></p><p><a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Android_Architecture_Binder.pdf" target="_blank" rel="noopener">Android Architecture Binder</a></p><p><a href="http://liuxiangtian.github.io/2016/01/07/AIDL%E4%B8%8EBinder%E6%A1%86%E6%9E%B6%E6%B5%85%E8%B0%88/" target="_blank" rel="noopener">AIDL与Binder框架浅谈</a></p><p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a></p><p><a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf" target="_blank" rel="noopener">Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013</a></p><p><a href="https://www.youtube.com/watch?v=NWhyADzgoiI" target="_blank" rel="noopener">Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video)</a></p><p><a href="http://blog.csdn.net/u010961631/article/details/20479507" target="_blank" rel="noopener">Binder源码分析之驱动层（原）</a></p><p><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a></p><p><a href="http://blog.csdn.net/qq429205464/article/details/7822442" target="_blank" rel="noopener">构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解</a></p><p><a href="http://blog.csdn.net/21cnbao/article/details/8087354" target="_blank" rel="noopener">Service与Android系统设计（7）— Binder驱动</a></p><p><a href="https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://www.cnblogs.com/zhangxinyan/p/3487889.html" target="_blank" rel="noopener">Binder机制，从Java到C （7. Native Service）</a></p><hr><p><strong>待补充的内容</strong></p><p>1. 客户端 bindService() 流程及源码分析</p><p>2. Binder Native 层其他源码文件分析</p><p>3. 系统服务（SystemService）详细列表及在本地层的源码分析</p><p>4. SystemManager 源码分析</p><p>5. 完善 binder 驱动内容，补充关系图</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;forked from &lt;a href=&quot;https://github.com/xdtianyu/SourceAnalysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xdtianyu/SourceAnalysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是基于 &lt;a href=&quot;https://github.com/xdtianyu/android-6.0.0_r1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 6.0.0&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel 3.4&lt;/a&gt; 源码 及 Android SDK 23 展开的。&lt;/p&gt;
&lt;p&gt;先上一张图，直白的了解 Binder 通信过程。(摘自&lt;a href=&quot;http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;超详细 Android 面试的准备与经历分享 | 百度 (offer)&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/学习资料/面试小札/Binder通信过程.png&quot; alt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Binder" scheme="https://yangxiaoge.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android O上手体验</title>
    <link href="https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O上手体验/</id>
    <published>2017-05-19T13:34:15.000Z</published>
    <updated>2019-02-28T10:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 <a href="http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">stormzhang</a> （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。<a id="more"></a><br>有几个重要的事件：Google AI，Android O，Kotlin，等等<br>本文重点是 Android O 的上手视频，迫不及待的把测试机 Nexus 5X 刷成了 Android 0，<a href="https://developer.android.com/preview/download.html" target="_blank" rel="noopener">Android O 系统映像文件下载</a>，官网介绍特性：<a href="https://developer.android.com/preview/index.html" target="_blank" rel="noopener">Android O 新特性介绍</a>。</p><p><strong>上手视频：</strong><br><!--<video height="800" controls>    <source src="/img/video/Android8.0device-2017-05-19-131435.mp4"></video>--><br><!--宽占满，高度自适应。 poster 预加载显示的图像--></p><video height="700" id="video" controls preload="none" poster="/img/video/Android_O_Preload.png"><br>      <source id="mp4" src="/img/video/Android8.0device-2017-05-19-131435.mp4" type="video/mp4"><br></video>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 &lt;a href=&quot;http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stormzhang&lt;/a&gt; （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。
    
    </summary>
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/categories/Android-O/"/>
    
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/tags/Android-O/"/>
    
  </entry>
  
  <entry>
    <title>Android输入法加密研究</title>
    <link href="https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android%E8%BE%93%E5%85%A5%E6%B3%95%E5%8A%A0%E5%AF%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android输入法加密研究/</id>
    <published>2017-05-09T09:51:03.000Z</published>
    <updated>2019-02-28T10:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>近期接到一个微信，QQ 聊天时加密文字的需求。<br>我当时的心情是这样的：<br><img src="/img/Android输入法加密研究/kidding_me.png" width="150" alt="are you kidding me?" align="center"><br><a id="more"></a></p><h2 id="开源项目入手"><a href="#开源项目入手" class="headerlink" title="开源项目入手"></a>开源项目入手</h2><p>冷静下来，细细思考，要不开发一个输入法？我这是要挑战搜狗输入法一个团队吗，不现实呀！然后就找到了 Goolge 开源的 PinyinIME（Android 4.4.4）。<br>毕竟输入法将输入的文字设置到编辑框要走 BaseInputConnection 中 commitText 方法，那么我就想在这个地方动手脚呗。嗯，说干就干，我就撸了一下 PinyinIME 项目中的代码，实现效果如下：(加密后的文字后面我加了一个 “中” 字)<br><img src="/img/Android输入法加密研究/撸了个加密.png" width="350" alt="加密前后" align="center"></p><p>哎呦，看着也还凑活哈。嗯，然后打开搜狗，百度输入法一看，用户就不乐意了，你家输入法真挫！一怒之下不用了。虽然这是个笑话，但是开发输入法代价太大了，毕竟要大量时间，人力。</p><h2 id="源码分析入手"><a href="#源码分析入手" class="headerlink" title="源码分析入手"></a>源码分析入手</h2><p>所以啊，我想要不从系统层入手？（<a href="https://developer.android.com/reference/android/inputmethodservice/InputMethodService.html?hl=zh-cn" target="_blank" rel="noopener">查了下 Api</a>）</p><ul><li><p><code>frameworks/base/...</code> 下有个类 <code>InputMethodManager</code> (输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的 context 中，用来沟通管理所有进程间交互的全局系统服务。) 中有个方法 showSoftInput (View view, int flags, ResultReceiver resultReceiver)。 注意到一个 view 参数，此参数就是输入框（微信，QQ，等输入框，webview除外）的 View，既然有了 view，那么我就可以 getText，setText 等等操作。<br>我将 view 中的内容 Toast 出来效果如下：<br><img src="/img/Android输入法加密研究/input_method2.png" width="350" alt="InputMethodManager中获取输入框对象，随时可以获取文本" align="center"></p></li><li><p><code>InputMethodService</code>，每个<code>输入法 App</code> 应用都是继承自它！那么就可以对它的生命周期下手了。输入法显示的时候开启一个自定义的服务（有悬浮窗的），输入法关闭的时候结束服务并且释放相应的静态变量。重点就在于生命周期的研究！</p></li><li><p>目的是，将 <code>InputMethodManager</code> 中的 编辑框 View 对象存起来，然后在 InputMethodService 中启动的服务 暂且叫做 <code>MyFloatEncryService</code> 中获取这个 View，之后就直接可以 get，set 加密了。</p></li></ul><p>实现方案在开发中，后续补充~~~ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期接到一个微信，QQ 聊天时加密文字的需求。&lt;br&gt;我当时的心情是这样的：&lt;br&gt;&lt;img src=&quot;/img/Android输入法加密研究/kidding_me.png&quot; width=&quot;150&quot; alt=&quot;are you kidding me?&quot; align=&quot;center&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/categories/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译</title>
    <link href="https://yangxiaoge.github.io/2017/05/04/2017-05-04-Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>https://yangxiaoge.github.io/2017/05/04/2017-05-04-Android源码编译/</id>
    <published>2017-05-04T11:40:24.000Z</published>
    <updated>2019-02-28T10:48:36.224Z</updated>
    
    <content type="html"><![CDATA[<p>进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）</p><ul><li><code>source build/envsetup.sh</code></li><li><code>lunch</code> (我的项目中选了 79)</li><li><code>make -j8</code>（第一次编译耗时 2 小时，机器性能好的可以 j32 等等）<a id="more"></a><blockquote><p>Android 编译命令 <a href="http://www.cnblogs.com/ifzy/p/3854560.html" target="_blank" rel="noopener">make -j8 -k 2&gt;&amp;1 | tee build.log</a> 解释: 其中 make 是编译命令，-j8 这里的 8 指的是线程数量，就是开启几个线程去编译这个工程，一般会是 CPU 核心数的 2 倍, 开多的话电脑会卡死。-k 2 是标准错误，&amp;1 是标准输出，2&gt;&amp;1 意思就是将标准错误输出到标准输出中。如果没有 2&gt;&amp;1，只会有标准输出，没有错误；tee 的作用同时输出到控制台和文件，make &gt; build.log  是将所有标准输出到这个文件中，并没有定义标准错误应该是定义到了标准输出，也就是说如果 make 执行出现错误，那么就不会写到 build.log 中，而是输出到屏幕上，2&gt;&amp;1 是错误和结果都重定向到 build.log 中！可以到根目录看到 build.log。</p></blockquote></li><li>模块编译，节约时间(比方说我修改了 frameworks/base 下的某个文件直接编译这个模块就行)<ul><li><code>mmm frameworks/base</code> （单独编译某个模块）</li><li><code>make snod</code> （重新打包 Android 系统镜像文件 system.img， 这个不要忘！）<blockquote><p>编译源码等指令可以看老罗的 <a href="http://0xcc0xcd.com/p/books/978-7-121-18108-5/c161.php" target="_blank" rel="noopener">Android 系统源代码情景分析教程</a></p></blockquote></li></ul></li></ul><p>刷机</p><ul><li><a href="https://share.weiyun.com/aef417d93a44dce31802087732ac4d8b" target="_blank" rel="noopener">刷机工具下载</a><br><img src="/img/刷机工具.png" alt="4个刷机工具"></li><li>安装下载的工具</li><li>打开 SP_Flash_Tool_exe_Windows_v5.1644.00.000\flash_tool.exe<br><img src="/img/flash_tool.png" alt="flash_tool"></li></ul><p>刷机开始</p><ul><li><code>MTK 刷机</code>（KONKAS6 代码）使用 <code>Smart Phone Flash Tool</code> 工具： 注意 KONKA 手机关机即可，首先选中 <code>Scatter-loading File</code> 这行的 <code>choose</code> ，然后<code>右击计算机</code>选择<code>映射网络驱动器</code>输入 <code>\\192.168.20.220\share</code>（这个是 <code>ubuntu</code> 共享的文件夹），然后进入对于源码目录找到 <code>KONKAS6\alps\out\target\product\kon6753_66c_s6_m0\MT6753_Android_scatter.txt</code></li><li><code>原生 AOSP</code> 用 Nexus 刷机（AOSP-6.0.1_r17 代码）：注意手机关机进入 <code>fastboot</code> 界面，进入编译生成的目录下 <code>begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/out/target/product/bullhead$</code>，然后依次刷入如下命令：<ul><li>sudo fastboot flash system system.img</li><li>sudo fastboot flash recovery recovery.img</li><li>sudo fastboot flash vendor vendor.img</li><li>sudo fastboot flash cache cache.img</li><li>sudo fastboot flash userdata userdata.img</li><li>sudo fastboot reboot 最后一步，重启手机。</li></ul></li><li>刷机录像：注意，gif 最后点击 <code>download</code> 之后再用 usb 连接关机的 KONKA 手机<br><img src="/img/MTK刷机录制.gif" alt="MTK刷机录制"></li></ul><p><code>Attention</code>： /home/begoit/temp/KONKAS6/alps/packages/apps/Provision/src/com/android/provision/DefaultActivity.java (注释 onCreate 中的部分代码，略去登录注册等功能)</p><p><strong>打 Patch 包</strong>（将 A 项目的提交打 Patch 导入到 B 项目中） <code>2017-9-18 18:14:57</code> add</p><ol><li><code>git format-patch -1 （git format-patch -n e795fefabc 根据 某一 commit 打 patch）</code>（-1 指最近一次 Git 提交） - A 项目根目录，生成 Patch 包</li><li>将生成的 <code>0001-.patch</code> 拷贝到 B 项目根目录下</li><li><code>git am 0001-.patch</code> - B 项目根目录打入 Patch 包</li></ol><p><strong>Android Ubuntu 编译源码依赖</strong> <code>2017-12-26 14:24:45</code><br><code>sudo  apt-get  install  git-core  gnupg  flex  bison  gperf  build-essential  zip  curl  zlib1g-dev  gcc-multilib  g++-multilib  libc6-dev-i386  lib32ncurses5-dev  x11proto-core-dev  libx11-dev  lib32z-dev  ccache  libgl1-mesa-dev  libxml2-utils  xsltproc  unzip</code></p><p><strong>源码代码提示的命令</strong> <code>2017-6-13 15:46:06</code> add<br>运行 <code>source build/envsetup.sh</code><br><code>mmm development/tools/idegen/</code><br><code>sh ./development/tools/idegen/idegen.sh</code> （三行全选运行），会在项目的更目录下会生成 <code>android.ipr</code>，用 <code>Android Studio</code> 打开这个文件，源码代码就有提示了!</p><p><strong>内置 apk</strong> <code>2017-6-27 11:08:49</code> add</p><ul><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/begoit 路径下将需要的 apk(TopActivity.apk) 安装包放进来</li><li>在上述路径下 Android.mk 文件中将 apk 信息加进来（这个模仿其他的内置apk）</li><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/full_kon6753_66c_s6_m0.mk 文件中增加 <code>TopActivity \</code></li><li>如果 apk 中有 so 库那么需要加别的东西，目前没有用到，可自行 google</li><li>以上操作完成之后需要重新编译项目</li></ul><p><strong>加快编译速度</strong> <code>2017-6-30 17:46:53</code> add<br><code>prebuilts/misc/linux-x86/ccache/ccache -M 50G</code> 设置 cache 缓存为 50 G</p><p>如下是编译的录屏, 临时弄个 <code>枪火</code> 先占坑，视频抽空录制（视频太大暂不录制）。<br>以下是哔哩哔哩的 html5 播放视频，参考文章：<a href="http://login926.github.io/2016/12/24/Bilibilihtml5Player/" target="_blank" rel="noopener">http://login926.github.io/2016/12/24/Bilibilihtml5Player/</a> </p><iframe src="https://www.bilibili.com/html/html5player.html?cid=5465980&aid=3444552" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe><!--宽占满，高度自适应。 poster 预加载显示的图像--><!--<video width="100%" height="auto" id="video" controls="" preload="none"       poster="http://media.w3.org/2010/05/sintel/poster.png">      <source id="mp4" src="http://cn-fjxm2-dx-v-03.acgvideo.com/vg1/f/84/5465980-1.mp4?expires=1494488400&platform=html5&ssig=sFyLhO5klFhNKadv0P9gtA&oi=1968780062&nfa=fkYkF/LEe5xFyJPq/bZ9eQ==&dynamic=1&hfa=2066162576" type="video/mp4">      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg"></video>--><p><strong>未完待续。。。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;source build/envsetup.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lunch&lt;/code&gt; (我的项目中选了 79)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make -j8&lt;/code&gt;（第一次编译耗时 2 小时，机器性能好的可以 j32 等等）
    
    </summary>
    
      <category term="Android源码" scheme="https://yangxiaoge.github.io/categories/Android%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://yangxiaoge.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
