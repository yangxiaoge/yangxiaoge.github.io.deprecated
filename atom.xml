<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>珠珠のBlog</title>
  <icon>https://www.gravatar.com/avatar/4ec65d784d203bac0fd2da7375835dff</icon>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangxiaoge.github.io/"/>
  <updated>2017-09-20T09:55:11.016Z</updated>
  <id>https://yangxiaoge.github.io/</id>
  
  <author>
    <name>Bruce Yang</name>
    <email>yang.jianan0926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 0 搭建直播系统</title>
    <link href="https://yangxiaoge.github.io/2017/09/12/2017-09-12-%E4%BB%8E-0-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/</id>
    <published>2017-09-12T15:45:18.000Z</published>
    <updated>2017-09-20T09:55:11.016Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个直播的 Demo，今天正好看到<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="external">鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统</a>，索性就把我自己的搭(折)建(腾)过程做一个记录。</p><p>搭建流程：</p><blockquote><p>服务器系统：Ubuntu 16.10 系统<br>推流，拉流系统：Win 7, Android</p></blockquote><p>一个简易的直播系统，大致可以由三部分组成（详情见鸿洋博客）：</p><ul><li>搭建一个 rtmp 媒体服务器：这里使用 srs</li><li>推流端：这里使用 obs</li><li>拉流端：这里使用播放器 vlc</li></ul><h3 id="使用第三方-SDK-推流"><a href="#使用第三方-SDK-推流" class="headerlink" title="使用第三方 SDK 推流"></a>使用第三方 SDK 推流</h3><p>这里以百度云的直播 SDK 为例，下载地址：<br><a href="https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E" target="_blank" rel="external">https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E</a></p><p>修改推流地址之后上传到了我的 <a href="https://github.com/yangxiaoge/PushFlowLive" target="_blank" rel="external">PushFlowLive</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/baidu-livecamera-%E6%8E%A8%E6%B5%81.apk" target="_blank" rel="external">apk 下载</a></p><h3 id="使用开源项目推流"><a href="#使用开源项目推流" class="headerlink" title="使用开源项目推流"></a>使用开源项目推流</h3><p>使用一个开源项目：</p><blockquote><p><a href="https://github.com/begeekmyfriend/yasea" target="_blank" rel="external">https://github.com/begeekmyfriend/yasea</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/yasea-推流.apk" target="_blank" rel="external">apk 下载</a></p></blockquote><h3 id="利用-ffmpeg-推流"><a href="#利用-ffmpeg-推流" class="headerlink" title="利用 ffmpeg 推流"></a>利用 ffmpeg 推流</h3><blockquote><p>详情见鸿洋博客</p></blockquote><p>大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。</p><p>这里，由于篇幅，我们就直接使用别人编好的项目了。</p><p><a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="external">https://github.com/WritingMinds/ffmpeg-android-java</a></p><p><strong><em>搭建过程截图</em></strong>：<br><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-43.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-51.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-57.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-02.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-04.jpg" alt=""></p><blockquote><p>封面小黄人动图来自 <a href="https://giphy.com/search/new-follower" target="_blank" rel="external">giphy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想搞个直播的 Demo，今天正好看到&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/77937483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸿洋公众号：轻松入门 Androi
      
    
    </summary>
    
    
      <category term="直播" scheme="https://yangxiaoge.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的 Android Framework</title>
    <link href="https://yangxiaoge.github.io/2017/09/05/2017-09-05-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-Android-Framework/"/>
    <id>https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/</id>
    <published>2017-09-05T14:16:37.000Z</published>
    <updated>2017-09-20T09:55:11.016Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— <code>前言</code></p><blockquote><p>本文转自 <a href="https://juejin.im/post/586da43b1b69e60062cb8a4f" target="_blank" rel="external">墨镜猫</a>，通俗有趣的文笔</p></blockquote><div align="center"><img src="https://dn-mhke0kuv.qbox.me/b06cc296588f99c3852e.jpg?imageView2/1/w/1200/h/700/q/85/interlace/1"></div><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含以下类：</p><ul><li>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。</li><li>Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。</li><li>PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。</li><li>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。</li><li>DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。</li><li>ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。</li></ul><h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><p>Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。</p><p>每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。</p><h3 id="从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的</h3><p>ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。</p><p>接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。</p><p><strong><em>很多线程是不是很晕？</em></strong></p><ol><li>安卓程序中都有哪些线程？</li></ol><p>客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。</p><ol><li>UI 线程是什么？</li></ol><p>一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p><ol><li>自定义的线程和 UI 线程有什么区别？</li></ol><p>UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— &lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文转自 &lt;a href=&quot;https://jueji
      
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Framework" scheme="https://yangxiaoge.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源许可证？</title>
    <link href="https://yangxiaoge.github.io/2017/08/29/2017-08-29-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%9F/"/>
    <id>https://yangxiaoge.github.io/2017/08/29/2017-08-29-如何选择开源许可证？/</id>
    <published>2017-08-29T14:36:51.000Z</published>
    <updated>2017-09-20T09:55:11.016Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。</p><blockquote><p>本文转自 <a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a> 大大</p></blockquote><p>如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="external">上百种</a>。很少有人搞得清楚它们的区别。即使在最流行的六种—– <a href="http://www.gnu.org/licenses/gpl.html" target="_blank" rel="external">GPL</a>、<a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="external">BSD</a>、<a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="external">MIT</a>、<a href="http://www.mozilla.org/MPL/" target="_blank" rel="external">Mozilla</a>、<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="external">Apache</a> 和 <a href="http://www.gnu.org/copyleft/lesser.html" target="_blank" rel="external">LGPL</a>—-之中做选择，也很复杂。<br>乌克兰程序员 <a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="external">Paul Bagwell</a> ，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。<br>下面是我制作的中文版，请看大图。<br><img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt=""></p><p>有兴趣详细了解开源协议的可以看这篇文章：<a href="http://www.gcssloop.com/tips/choose-license" target="_blank" rel="external">程序员不可不知的版权协议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文转自 &lt;a href=&quot;http://www.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰&lt;/
      
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Binder源码分析</title>
    <link href="https://yangxiaoge.github.io/2017/07/06/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/07/06/Binder源码分析/</id>
    <published>2017-07-06T10:00:05.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>forked from <a href="https://github.com/xdtianyu/SourceAnalysis" target="_blank" rel="external">xdtianyu/SourceAnalysis</a></p></blockquote><p>本文是基于 <a href="https://github.com/xdtianyu/android-6.0.0_r1" target="_blank" rel="external">Android 6.0.0</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow" target="_blank" rel="external">kernel 3.4</a> 源码 及 Android SDK 23 展开的。</p><p><strong>目录</strong></p><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-binder-与-aidl">2. Binder 与 AIDL</a><ul><li><a href="#21-aidl-客户端">2.1 AIDL 客户端</a></li><li><a href="#22-aidl-服务端">2.2 AIDL 服务端</a></li><li><a href="#23-远程服务的获取与使用">2.3 远程服务的获取与使用</a></li></ul></li><li><a href="#3-binder-框架及-native-层">3. Binder 框架及 Native 层</a><ul><li><a href="#31-binder-native-的入口">3.1 Binder Native 的入口</a></li><li><a href="#32-binder-本地层的整个函数/方法调用过程">3.2 Binder 本地层的整个函数/方法调用过程</a></li><li><a href="#33-binder-设备文件的打开和读写">3.3 Binder 设备文件的打开和读写</a></li></ul></li><li><a href="#4-binder-驱动">4. Binder 驱动</a><ul><li><a href="#41-binder-设备的创建">4.1 binder 设备的创建</a></li><li><a href="#42-binder-协议和数据结构">4.2 binder 协议和数据结构</a></li><li><a href="#43-binder-驱动文件操作">4.3 binder 驱动文件操作</a></li></ul></li><li><a href="#5-binder-与系统服务">5. Binder 与系统服务</a><ul><li><a href="#51-contextgetsystemservice">5.1 Context.getSystemService()</a></li><li><a href="#52-contextgetsystemservice-源码分析">5.2 Context.getSystemService() 源码分析</a></li></ul></li><li><a href="#6-结论">6. 结论</a></li><li><a href="#7-参考">7. 参考</a></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 <code>Context.getSystemService()</code> 来获取系统服务，或直接使用 <code>AIDL</code> 来实现多个程序(APP)间数据交互。</p><p>Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/android_binder.png" alt="android_binder"></p><p>不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。</p><p>我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。</p><h2 id="2-Binder-与-AIDL"><a href="#2-Binder-与-AIDL" class="headerlink" title="2. Binder 与 AIDL"></a>2. Binder 与 AIDL</h2><p>AIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/AIDL.png" alt="AIDL概念图"></p><ul><li><p>Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。</p></li><li><p>Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。</p></li></ul><p>接下来再看具体实现， 完整源代码见 <a href="https://github.com/xdtianyu/AidlExample" target="_blank" rel="external">AidlExample</a>。在这个工程中，我们新建了两个应用， <code>app</code> 是客户端代码， <code>remoteservice</code> 则是服务端代码。</p><h3 id="2-1-AIDL-客户端"><a href="#2-1-AIDL-客户端" class="headerlink" title="2.1 AIDL 客户端"></a>2.1 AIDL 客户端</h3><p>在 Android Studio 项目上右键， <code>New</code> -&gt; <code>AIDL</code> -&gt; <code>AIDL File</code> 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="external">IRemoteService.aidl</a> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.aidl</span></div><div class="line"><span class="keyword">package</span> com.android.aidltest;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从生成的示例代码可以看出，AIDL 的语法类似 Java， <code>basicTypes()</code> 方法传递的参数只是基本类型。</p><p>如果要传递自定义类型如 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java#L6" target="_blank" rel="external">User</a>，则需要实现 <a href="http://developer.android.com/reference/android/os/Parcelable.html" target="_blank" rel="external">Parcelable</a> 接口。<code>Parcelable</code> 是一个与 Java <code>Serializable</code> 类似的序列化接口。 </p><p>这样类 <code>User</code> 的实例就可以储存到 <a href="http://developer.android.com/reference/android/os/Parcel.html" target="_blank" rel="external">Parcel</a> 中，而 <code>Parcel</code> 则是一个可以通过 <code>IBinder</code> 发送数据或对象引用的容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="comment">// 从 Parcel 中读取数据，顺序需要和写入保持一致</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">        uid = in.readInt();</div><div class="line">        name = in.readString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 必须实现，用于从 Parcel 对象中生成类实例</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// 将数据写入到 Parcel 中， 顺序需要与读取保持一致</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        dest.writeInt(uid);</div><div class="line">        dest.writeString(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再向 <code>IRemoteService.aidl</code> 中添加一个 <code>addUser()</code> 方法，同时新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="external">User.aidl</a> 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.aidl</span></div><div class="line"><span class="keyword">package</span> com.android.aidltest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.android.aidltest.User;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(in User user)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// User.aidl</span></div><div class="line"><span class="keyword">package</span> com.android.aidltest;</div><div class="line">parcelable User;</div></pre></td></tr></table></figure><p>运行编译后，会在 <code>generated</code> 文件夹中生成一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="external">IRemoteService.java</a> 接口文件。这个接口中有两个内部类 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="external">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="external">Stub.Proxy</a>。注意客户端生成的<code>IRemoteService.java</code> 文件和在后文服务端生成的文件内容是相同的。</p><p>客户端会从 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L34" target="_blank" rel="external">Stub.asInterface()</a> 得到 <code>IRemoteService (Stub.Proxy)</code> 的实例，这个实例就是一个通过 Binder 传递回来的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L93" target="_blank" rel="external">远程对象</a> 的包装。而服务端则需要实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="external">IRemoteService.addUser()</a> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.xdty.remoteservice.<span class="function">IRemoteService <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> org.xdty.remoteservice.IRemoteService))) &#123;</div><div class="line">        <span class="keyword">return</span> ((org.xdty.remoteservice.IRemoteService) iin);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-AIDL-服务端"><a href="#2-2-AIDL-服务端" class="headerlink" title="2.2 AIDL 服务端"></a>2.2 AIDL 服务端</h3><p>为了演示进程间通信，我们新建一个模块（应用） <a href="https://github.com/xdtianyu/AidlExample/tree/master/remoteservice" target="_blank" rel="external">RemoteService</a> 来实现功能，并在客户端绑定服务。</p><p>按客户端的结构新建 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="external">IRemoteService.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="external">User.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java" target="_blank" rel="external">User.java</a> 文件，并拷贝内容，注意如果需要请修改包名。</p><p>新建服务 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L29" target="_blank" rel="external">RemoteService</a> ，覆盖(Override) <code>onBind()</code> 方法并返回 <code>IRemoteService.Stub</code> 实例 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="external">mBinder</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RemoteService.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = RemoteService.class.getSimpleName();</div><div class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></div><div class="line"><span class="function"><span class="params">                <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            Log.d(TAG, <span class="string">"basicTypes: "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            Log.d(TAG, <span class="string">"addUser: "</span> + user.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBinder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样服务端就实现了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="external">addUser()</a> 方法，当客户端通过远程对象调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L135" target="_blank" rel="external">IRemoteService.Stub.Proxy.addUser()</a> 时，远程对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="external">mRemote</a> 就会通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="external">transact()</a> 发送命令给服务端，服务端收到命令后在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L76" target="_blank" rel="external">Stub.onTransact()</a> 中读取数据并执行 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="external">addUser()</a> 方法。更多细节我们将在 <a href="#3-binder-%E6%A1%86%E6%9E%B6%E5%8F%8A-native-%E5%B1%82">3. Binder 框架及 Native 层</a> 小节讲述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (code) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> TRANSACTION_addUser: &#123;</div><div class="line">            data.enforceInterface(DESCRIPTOR);</div><div class="line">            org.xdty.remoteservice.User _arg0;</div><div class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                _arg0 = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.addUser(_arg0);</div><div class="line">            reply.writeNoException();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-远程服务的获取与使用"><a href="#2-3-远程服务的获取与使用" class="headerlink" title="2.3 远程服务的获取与使用"></a>2.3 远程服务的获取与使用</h3><p>客户端要使用远程服务，需要绑定服务 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L45" target="_blank" rel="external">bindService</a>) 并建立服务连接 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L19" target="_blank" rel="external">ServiceConnection</a>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MainActivity.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">            IRemoteService remoteService = IRemoteService.Stub.asInterface(service);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                remoteService.addUser(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"neo"</span>));</div><div class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent().setComponent(<span class="keyword">new</span> ComponentName(</div><div class="line">                <span class="string">"org.xdty.remoteservice"</span>,</div><div class="line">                <span class="string">"org.xdty.remoteservice.RemoteService"</span>));</div><div class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看出，客户端通过 <code>binderService()</code> 方法，获取远程服务并在服务连接 <code>ServiceConnection</code> 中 <code>onServiceConnected()</code> 回调中得到了 <code>IBinder service</code> 实例， 最后通过上文提到的 <code>IRemoteService.Stub.asInterface(service)</code> 方法得到远程服务 <code>IRemoteService</code> 的实例。通过 <code>IRemoteService.addUser()</code> 方法我们可以像调用本地方法一样调用远程方法。在来看 <code>IRemoteService.addUser()</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> org.xdty.remoteservice.<span class="function">IRemoteService <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">xdty</span>.<span class="title">remoteservice</span>.<span class="title">IRemoteService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</div><div class="line"></div><div class="line">    Proxy(android.os.IBinder remote) &#123;</div><div class="line">        mRemote = remote;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mRemote;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(org.xdty.remoteservice.User user)</span></span></div><div class="line"><span class="function">            <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span> ((user != <span class="keyword">null</span>)) &#123;</div><div class="line">                _data.writeInt(<span class="number">1</span>);</div><div class="line">                user.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                _data.writeInt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, <span class="number">0</span>);</div><div class="line">            _reply.readException();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            _reply.recycle();</div><div class="line">            _data.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到客户端调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L25" target="_blank" rel="external">remoteService.addUser(new User(1, “neo”))</a> 方法实际上是通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="external">IBinder service</a> 实例的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="external">transact()</a> 方法，发送了与服务端约定好的命令 <code>Stub.TRANSACTION_addUser</code>，并将参数按格式打包进 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L137" target="_blank" rel="external">Parcel</a> 对象。</p><p>服务端则在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="external">onTransact()</a> 方法中收到命令后会对命令和参数重新解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IRemoteService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (code) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> TRANSACTION_addUser: &#123;</div><div class="line">            data.enforceInterface(DESCRIPTOR);</div><div class="line">            org.xdty.remoteservice.User _arg0;</div><div class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                _arg0 = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.addUser(_arg0);</div><div class="line">            reply.writeNoException();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到在 <code>onTransact()</code> 中，最终 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="external">this.addUser(_arg0)</a> 调用了上文提到的服务端的实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L19" target="_blank" rel="external">IRemoteService.Stub.addUser()</a> 。</p><p>远程 Binder 对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L42" target="_blank" rel="external">mRemote</a> 是由客户端绑定服务时 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L23" target="_blank" rel="external">onServiceConnected()</a> 返回的。继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1283" target="_blank" rel="external">bindService()</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ContextImpl.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">    warnIfCallingFromSystemProcess();</div><div class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, Process.myUserHandle());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到最后是通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1317#L1320" target="_blank" rel="external">ActivityManagerNative.getDefault().bindService()</a> 来绑定服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bindServiceCommon()</span></div><div class="line"><span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</div><div class="line">    mMainThread.getApplicationThread(), getActivityToken(), service,</div><div class="line">    service.resolveTypeIfNeeded(getContentResolver()),</div><div class="line">    sd, flags, getOpPackageName(), user.getIdentifier());</div><div class="line"></div><div class="line"><span class="comment">// ActivityManagerNative.getDefault().bindService()</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span></div><div class="line"><span class="function"><span class="params">        Intent service, String resolvedType, IServiceConnection connection,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags,  String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">    ...</div><div class="line">    data.writeStrongBinder(connection.asBinder());</div><div class="line">    ...</div><div class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>追踪到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3740" target="_blank" rel="external">ActivityManagerNative.getDefault().bindService()</a> ，可以发现 <code>ActivityManager</code> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3750" target="_blank" rel="external">IServiceConnection</a>也是一个 <code>AIDL</code> 实现。通过它的 <code>ActivityManagerProxy.bindService()</code> 将绑定请求发送给本地层。</p><p>再从 <code>onServiceConnected()</code> 回调追踪， <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1223" target="_blank" rel="external">onServiceConnected()</a> 是由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1175" target="_blank" rel="external">LoadedApk.ServiceDispatcher.doConnected()</a> 回调的。</p><p><em>关于更多的 <code>bindService()</code> 远程服务创建及 <code>ServiceConnection</code> 回调， 请参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6745181" target="_blank" rel="external">Android应用程序绑定服务（bindService）的过程源代码分析</a></em></p><p><em>利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 <a href="https://github.com/xdtianyu/CallerInfo/tree/master/plugin/src/main" target="_blank" rel="external">CallerInfo Plugin</a> 的实现 </em></p><p>从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。</p><h2 id="3-Binder-框架及-Native-层"><a href="#3-Binder-框架及-Native-层" class="headerlink" title="3. Binder 框架及 Native 层"></a>3. Binder 框架及 Native 层</h2><p>Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/Binder.png" alt="Binder框架图片"></p><p>Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 <a href="#4-binder-%E9%A9%B1%E5%8A%A8">4. Binder 驱动</a> 小节详细讲述。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native.png" alt="Binder本地框架图片"></p><p>JNI 的代码位于 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/core/jni" target="_blank" rel="external">frameworks/base/core/jni</a> 目录下，主要是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp" target="_blank" rel="external">android_util_Binder.cpp</a> 文件和头文件 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.h" target="_blank" rel="external">android_util_Binder.h</a></p><p>Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 <code>libandroid_runtime.so</code> 系统库。</p><p>Binder 本地层的代码在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/libs/binder" target="_blank" rel="external">frameworks/native/libs/binder</a> 目录下， 此目录在 Android 系统编译后会生成 <code>libbinder.so</code> 文件，供 JNI 调用。<code>libbinder</code> 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/include/binder" target="_blank" rel="external">frameworks/native/include/binder</a> 目录下。</p><h3 id="3-1-Binder-Native-的入口"><a href="#3-1-Binder-Native-的入口" class="headerlink" title="3.1 Binder Native 的入口"></a>3.1 Binder Native 的入口</h3><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IInterface.cpp#L33" target="_blank" rel="external">IInterface.cpp</a> 是 Binder 本地层入口，与 java 层的 <code>android.os.IInterface</code> 对应，提供 <code>asBinder()</code> 的实现，返回 <code>IBinder</code> 对象。</p><p>在头文件中有两个类 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L50" target="_blank" rel="external">BnInterface (Binder Native Interface)</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L63" target="_blank" rel="external">BpInterface (Binder Proxy Interface)</a>, 对应于 java 层的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="external">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="external">Proxy</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; IInterface::asBinder(<span class="keyword">const</span> IInterface* iface)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (iface == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;IInterface*&gt;(iface)-&gt;onAsBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16&amp; _descriptor);</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp;     <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ----------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>其中 <code>BnInterface</code> 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。<code>BpInterface</code> 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。</p><h3 id="3-2-Binder-本地层的整个函数-方法调用过程"><a href="#3-2-Binder-本地层的整个函数-方法调用过程" class="headerlink" title="3.2 Binder 本地层的整个函数/方法调用过程"></a>3.2 Binder 本地层的整个函数/方法调用过程</h3><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native_stack.png" alt="Binder本地函数调用图"></p><p>1. Java 层 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="external">IRemoteService.Stub.Proxy</a> 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L501" target="_blank" rel="external">android.os.IBinder (实现在 android.os.Binder.BinderProxy)</a> 的 <code>transact()</code> 发送 <code>Stub.TRANSACTION_addUser</code> 命令。</p><p>2. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L507" target="_blank" rel="external">BinderProxy.transact()</a> 进入 native 层。</p><p>3. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="external">jni</a> 转到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="external">android_os_BinderProxy_transact()</a> 函数。</p><p>4. 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1124" target="_blank" rel="external">IBinder-&gt;transact</a> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></div><div class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    IBinder* target = (IBinder*)</div><div class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</div><div class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而 <code>gBinderProxyOffsets.mObject</code> 则是在 java 层调用 <code>IBinder.getContextObject()</code> 时在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L580" target="_blank" rel="external">javaObjectForIBinder</a> 函数中设置的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ...</div><div class="line">    LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</div><div class="line">    <span class="comment">// The proxy holds a reference to the native object.</span></div><div class="line">    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</div><div class="line">    val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L85" target="_blank" rel="external">ProcessState::getContextObject()</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L220" target="_blank" rel="external">ProcessState::getStrongProxyForHandle()</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</div><div class="line">&#123;</div><div class="line">    sp&lt;IBinder&gt; result;</div><div class="line">    ...</div><div class="line">    b = <span class="keyword">new</span> BpBinder(handle); </div><div class="line">    result = b;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可见 <a href="">android_os_BinderProxy_transact()</a> 函数实际上调用的是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L159" target="_blank" rel="external">BpBinder::transact()</a> 函数。</p><p>5. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L164" target="_blank" rel="external">BpBinder::transact()</a> 则又调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L548" target="_blank" rel="external">IPCThreadState::self()-&gt;transact()</a> 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</div><div class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</div><div class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</div><div class="line"></div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</div><div class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</div><div class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</div><div class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (reply) &#123;</div><div class="line">            err = waitForResponse(reply);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&amp;fakeReply);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</div><div class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</div><div class="line">&#123;</div><div class="line">    binder_transaction_data tr;</div><div class="line"></div><div class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> NO_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由函数内容可以看出， 数据再一次通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L904" target="_blank" rel="external">writeTransactionData()</a> 传递给 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L934" target="_blank" rel="external">mOut</a> 进行写入操作。 <code>mOut</code> 是一个 Parcel 对象， 声明在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IPCThreadState.h#L123" target="_blank" rel="external">IPCThreadState.h</a> 文件中。之后则调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L583" target="_blank" rel="external">waitForResponse()</a> 函数。</p><p>6. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L712" target="_blank" rel="external">IPCThreadState::waitForResponse()</a> 在一个 <code>while</code> 循环里不断的调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="external">talkWithDriver()</a> 并检查是否有数据返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint32_t</span> cmd;</div><div class="line">    <span class="keyword">int32_t</span> err;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</div><div class="line">        ...</div><div class="line">        </div><div class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</div><div class="line">            ...</div><div class="line">        </div><div class="line">        <span class="keyword">case</span> BR_REPLY:</div><div class="line">            &#123;</div><div class="line">                binder_transaction_data tr;</div><div class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</div><div class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (reply) &#123;</div><div class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</div><div class="line">                        reply-&gt;ipcSetDataReference(</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</div><div class="line">                            freeBuffer, <span class="keyword">this</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</div><div class="line">                        freeBuffer(<span class="literal">NULL</span>,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</div><div class="line">                            tr.data_size,</div><div class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</div><div class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    freeBuffer(<span class="literal">NULL</span>,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</div><div class="line">                        tr.data_size,</div><div class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</div><div class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">goto</span> finish;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = executeCommand(cmd);</div><div class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>7. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="external">IPCThreadState::talkWithDriver()</a> 函数是真正与 binder 驱动交互的实现。<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="external">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 就是使用系统调用函数 <code>ioctl</code> 向 binder 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -EBADF;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    binder_write_read bwr;</div><div class="line">    </div><div class="line">    <span class="comment">// Is the read buffer empty?</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">    </div><div class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></div><div class="line">    <span class="comment">// from data left in the input buffer and the caller</span></div><div class="line">    <span class="comment">// has requested to read the next data.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">    </div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</div><div class="line"></div><div class="line">    <span class="comment">// This is what we'll read.</span></div><div class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></div><div class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</div><div class="line"></div><div class="line">    bwr.write_consumed = <span class="number">0</span>;</div><div class="line">    bwr.read_consumed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">status_t</span> err;</div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></div><div class="line">        <span class="comment">// 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令</span></div><div class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</div><div class="line">            err = NO_ERROR;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            err = -errno;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        err = INVALID_OPERATION;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</div><div class="line">            err = -EBADF;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</div><div class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</div><div class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                mOut.setDataSize(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</div><div class="line">            mIn.setDataSize(bwr.read_consumed);</div><div class="line">            mIn.setDataPosition(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> NO_ERROR;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L718" target="_blank" rel="external">IPCThreadState::talkWithDriver()</a> ,就将数据发送给了 Binder 驱动。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L723" target="_blank" rel="external">IPCThreadState::waitForResponse()</a> ，可以从 第6步 发现 <code>IPCThreadState</code> 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L787" target="_blank" rel="external">executeCommand(cmd)</a> 函数。</p><p>8. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L947" target="_blank" rel="external">IPCThreadState::executeCommand()</a> 处理 Binder 驱动返回命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</div><div class="line">&#123;</div><div class="line">    BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> BR_TRANSACTION:</div><div class="line">        &#123;</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</div><div class="line">            ...</div><div class="line">            Parcel buffer;</div><div class="line">            buffer.ipcSetDataReference(</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</div><div class="line">                tr.data_size,</div><div class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</div><div class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</div><div class="line">            ...</div><div class="line"></div><div class="line">            Parcel reply;</div><div class="line">            <span class="keyword">status_t</span> error;</div><div class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>9. 可以看出其调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="external">BBinder::transact()</a> 函数，将数据返回给上层。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> BBinder::transact(</div><div class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</div><div class="line">&#123;</div><div class="line">    data.setDataPosition(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</div><div class="line">    <span class="keyword">switch</span> (code) &#123;</div><div class="line">        <span class="keyword">case</span> PING_TRANSACTION:</div><div class="line">            reply-&gt;writeInt32(pingBinder());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            err = onTransact(code, data, reply, flags);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</div><div class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>10. 而这里的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="external">b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags)</a> 中的 <code>b (BBinder)</code> 是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L217" target="_blank" rel="external">JavaBBinder</a> 的实例，所以会调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L247" target="_blank" rel="external">JavaBBinder::onTransact()</a> 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// frameworks/base/core/jni/android_util_Binder.cpp</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</div><div class="line">        ...</div><div class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</div><div class="line">            code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ...</div><div class="line">    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, <span class="string">"execTransact"</span>, <span class="string">"(IJJI)Z"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>11. 可见 JNI 通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L260" target="_blank" rel="external">gBinderOffsets.mExecTransact</a> 最后执行了 <code>android.os.Binder</code> 的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L865" target="_blank" rel="external">execTransact()</a> 方法。</p><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L442" target="_blank" rel="external">execTransact()</a> 方法是 jni 回调的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Entry point from android_util_Binder.cpp's onTransact</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        Parcel data = Parcel.obtain(dataObj);</div><div class="line">        Parcel reply = Parcel.obtain(replyObj);</div><div class="line">        ...</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            res = onTransact(code, data, reply, flags);</div><div class="line">        &#125; </div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>12. 而我们则在服务端 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="external">IRemoteService.Stub</a> 重载了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="external">onTransact()</a> 方法，所以数据最后会回到我们的服务端并执行服务端实现的 <code>addUser()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span></span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">xdty</span>.<span class="title">remoteservice</span>.<span class="title">IRemoteService</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (code) &#123;</div><div class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</div><div class="line">                reply.writeString(DESCRIPTOR);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</div><div class="line">                ...</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> TRANSACTION_addUser: &#123;</div><div class="line">                data.enforceInterface(DESCRIPTOR);</div><div class="line">                org.xdty.remoteservice.User _arg0;</div><div class="line">                <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">                    _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    _arg0 = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.addUser(_arg0);</div><div class="line">                reply.writeNoException();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 <code>BC_TRANSACTION</code> 到 Binder 驱动，服务端进程监听返回的 <code>BR_TRANSACTION</code> 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 <code>BC_REPLY</code> 命令， 客户端监听 <code>BR_REPLY</code> 命令。</p><h3 id="3-3-Binder-设备文件的打开和读写"><a href="#3-3-Binder-设备文件的打开和读写" class="headerlink" title="3.3 Binder 设备文件的打开和读写"></a>3.3 Binder 设备文件的打开和读写</h3><p><strong>1. 设备的打开</strong></p><p>在上一小节中我们看到 JNI 过程中调用了 <code>ProcessState::getContextObject()</code> 函数， 在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="external">ProcessState</a> 初始化时会打开 binder 设备</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ProcessState.cpp</span></div><div class="line">ProcessState::ProcessState()</div><div class="line">    : mDriverFD(open_driver())</div><div class="line">    ...</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L311#L337" target="_blank" rel="external">open_driver()</a> 函数内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ProcessState.cpp</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 打开设备文件</span></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</div><div class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</div><div class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</div><div class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 获取驱动版本</span></div><div class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</div><div class="line">            close(fd);</div><div class="line">            fd = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 检查驱动版本是否一致</span></div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</div><div class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</div><div class="line">            close(fd);</div><div class="line">            fd = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置最多 15 个 binder 线程</span></div><div class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</div><div class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</div><div class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</div><div class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>2. 设备的读写</strong></p><p>打开设备文件后，文件描述符被保存在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="external">mDriverFD</a>， 通过系统调用 <code>ioctl</code> 函数操作 <code>mDriverFD</code> 就可以实现和 binder 驱动的交互。</p><p>对 Binder 设备文件的所有读写及关闭操作则都在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L805" target="_blank" rel="external">IPCThreadState</a> 中，如上一小节提及到的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="external">IPCThreadState::talkWithDriver</a> 函数</p><p><code>talkWithDriver()</code> 函数封装了 <code>BINDER_WRITE_READ</code> 命令，会从 binder 驱动读取或写入封装在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="external">binder_write_read</a> 结构体中的本地或远程对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IPCThreadState.cpp</span></div><div class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</div><div class="line">&#123;   </div><div class="line">    binder_write_read bwr;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 写入数据</span></div><div class="line">    bwr.write_size = outAvail;</div><div class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</div><div class="line"></div><div class="line">    <span class="comment">// 读取数据</span></div><div class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</div><div class="line">        bwr.read_size = mIn.dataCapacity();</div><div class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bwr.read_size = <span class="number">0</span>;</div><div class="line">        bwr.read_buffer = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动</span></div><div class="line">    <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</div><div class="line">        err = NO_ERROR;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。</p><h2 id="4-Binder-驱动"><a href="#4-Binder-驱动" class="headerlink" title="4. Binder 驱动"></a>4. Binder 驱动</h2><p>关于 binder 驱动建议参考另一篇文章 <a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a> <a href="[Android Binder](https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11">原文</a>，本小节仍需要完善。</p><p>Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_reference.png" alt="Binder reference"></p><p>Binder 驱动的代码位于 kernel 代码的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/tree/master/drivers/staging/android" target="_blank" rel="external">drivers/staging/android</a> 目录下。主文件是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="external">binder.h</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c" target="_blank" rel="external">binder.c</a></p><p>进程间传输的数据被称为 Binder 对象，它是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L49" target="_blank" rel="external">flat_binder_object</a>，结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></div><div class="line">    <span class="comment">/* 8 bytes for large_flat_header. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       type;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</div><div class="line"></div><div class="line">    <span class="comment">/* 8 bytes of data. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span>        *binder;    <span class="comment">/* local object */</span></div><div class="line">        <span class="keyword">signed</span> <span class="keyword">long</span> handle;     <span class="comment">/* remote object */</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">/* extra data associated with local object */</span></div><div class="line">    <span class="keyword">void</span>            *cookie;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>其中 类型 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="external">type</a> 描述了 Binder 对象的类型，包含 <code>BINDER</code>(本地对象)、<code>HANDLE</code>(远程对象)、 <code>FD</code> 三大类(五种)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L52" target="_blank" rel="external">flags</a> 则表述了<a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L110" target="_blank" rel="external">传输方式</a>，如异步、无返回等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> transaction_flags &#123;</div><div class="line">    TF_ONE_WAY  = <span class="number">0x01</span>, <span class="comment">/* this is a one-way call: async, no return */</span></div><div class="line">    TF_ROOT_OBJECT  = <span class="number">0x04</span>, <span class="comment">/* contents are the component's root object */</span></div><div class="line">    TF_STATUS_CODE  = <span class="number">0x08</span>, <span class="comment">/* contents are a 32-bit status code */</span></div><div class="line">    TF_ACCEPT_FDS   = <span class="number">0x10</span>, <span class="comment">/* allow replies with file descriptors */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>而 <code>flat_binder_object</code> 中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L55" target="_blank" rel="external">union 联合体</a> 就是要传输的数据，当类型为 <code>BINDER</code> 时， 数据就是一个本地对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L56" target="_blank" rel="external">*binder</a>，而类型为 <code>HANDLE</code> 时，数据则是一个远程对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L57" target="_blank" rel="external">handle</a>。</p><p>当 <code>flat_binder_object</code> 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1671" target="_blank" rel="external">binder_transaction</a> 的实现。</p><p>该如何理解本地 <code>BINDER</code> 对象和远程 <code>HANDLE</code> 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 <code>RemoteService</code> 有个对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="external">mBinder</a>，对于 <code>RemoteService</code> 来说，<code>mBinder</code> 就是一个本地的 <code>BINDER</code> 对象；如果进程 <code>app</code> 通过 Binder 驱动访问 <code>RemoteService</code> 的 <code>mBinder</code> 对象，对于 <code>app</code> 来说， <code>mBinder</code> 就是一个 <code>HANDLE</code>。因此，从根本上来说 <code>handle</code> 和 <code>binder</code> 都指向 <code>RemoteService</code> 的 <code>mBinder</code>。本地对象还可以带有额外的数据，保存在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L61" target="_blank" rel="external">cookie</a> 中。</p><p>Binder 驱动直接操作的最外层数据结构是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L117" target="_blank" rel="external">binder_transaction_data</a>， Binder 对象 <code>flat_binder_object</code> 被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="external">binder_transaction_data</a> 结构体中。</p><p><code>binder_transaction_data</code> 数据结构才是真正传输的数据，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></div><div class="line">    <span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></div><div class="line"><span class="comment">     * identifying the target and contents of the transaction.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">size_t</span>  handle; <span class="comment">/* target descriptor of command transaction */</span></div><div class="line">        <span class="keyword">void</span>    *ptr;   <span class="comment">/* target descriptor of return transaction */</span></div><div class="line">    &#125; target;</div><div class="line">    <span class="keyword">void</span>        *cookie;    <span class="comment">/* target object cookie */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;       <span class="comment">/* transaction command */</span></div><div class="line"></div><div class="line">    <span class="comment">/* General information about the transaction. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</div><div class="line">    <span class="keyword">pid_t</span>       sender_pid;</div><div class="line">    <span class="keyword">uid_t</span>       sender_euid;</div><div class="line">    <span class="keyword">size_t</span>      data_size;  <span class="comment">/* number of bytes of data */</span></div><div class="line">    <span class="keyword">size_t</span>      offsets_size;   <span class="comment">/* number of bytes of offsets */</span></div><div class="line"></div><div class="line">    <span class="comment">/* If this transaction is inline, the data immediately</span></div><div class="line"><span class="comment">     * follows here; otherwise, it ends with a pointer to</span></div><div class="line"><span class="comment">     * the data buffer.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">            <span class="comment">/* transaction data */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *buffer;</div><div class="line">            <span class="comment">/* offsets from buffer to flat_binder_object structs */</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">void</span>  *offsets;</div><div class="line">        &#125; ptr;</div><div class="line">        <span class="keyword">uint8_t</span> buf[<span class="number">8</span>];</div><div class="line">    &#125; data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><code>flat_binder_object</code> 就被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="external">*buffer</a>中，其中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L126" target="_blank" rel="external">unsigned int   code;</a> 则是传输命令，描述了 Binder 对象执行的操作。</p><h3 id="4-1-binder-设备的创建"><a href="#4-1-binder-设备的创建" class="headerlink" title="4.1 binder 设备的创建"></a>4.1 binder 设备的创建</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3747" target="_blank" rel="external">device_initcall()</a> 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></div><div class="line">    .minor = MISC_DYNAMIC_MINOR,</div><div class="line">    <span class="comment">// 设备文件 /dev/binder</span></div><div class="line">    .name = <span class="string">"binder"</span>,</div><div class="line">    <span class="comment">// 设备文件操作</span></div><div class="line">    .fops = &amp;binder_fops</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 注册字符设备</span></div><div class="line">    ret = misc_register(&amp;binder_miscdev);</div><div class="line">    ...</div><div class="line">    <span class="comment">// 调试文件， 在 /sys/kernel/debug/binder 目录下</span></div><div class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</div><div class="line">        debugfs_create_file(<span class="string">"state"</span>,</div><div class="line">                    S_IRUGO,</div><div class="line">                    binder_debugfs_dir_entry_root,</div><div class="line">                    <span class="literal">NULL</span>,</div><div class="line">                    &amp;binder_state_fops);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">device_initcall(binder_init);</div></pre></td></tr></table></figure><p>可以看出 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3704" target="_blank" rel="external">binder_init()</a> 使用 <code>misc_register()</code> 函数创建了 binder 设备。从 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3716" target="_blank" rel="external">misc_register(&amp;binder_miscdev);</a> 及 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3695" target="_blank" rel="external">.name = “binder”</a> 可以看出， binder 向 kernel 注册了一个 <code>/dev/binder</code> 的字符设备，而文件操作都在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="external">binder_fops</a> 结构体中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></div><div class="line">    .owner = THIS_MODULE,</div><div class="line">    .poll = binder_poll,</div><div class="line">    .unlocked_ioctl = binder_ioctl,</div><div class="line">    .mmap = binder_mmap,</div><div class="line">    .open = binder_open,</div><div class="line">    .flush = binder_flush,</div><div class="line">    .release = binder_release,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>从上面 <code>binder_fops</code> 结构体可以看出，主要的操作是 <code>binder_ioctl()</code> <code>binder_mmap()</code> <code>binder_open()</code> 等函数实现的。</p><h3 id="4-2-binder-协议和数据结构"><a href="#4-2-binder-协议和数据结构" class="headerlink" title="4.2 binder 协议和数据结构"></a>4.2 binder 协议和数据结构</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="external">binder.h</a> 文件中定义了 binder 协议和重要的数据结构。</p><p>首先在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="external">enum</a> 中定义了 binder 处理的类型，引用或是句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    BINDER_TYPE_BINDER  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_HANDLE  = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">    BINDER_TYPE_FD      = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>下面这段宏定义则是在 <code>ioctl</code> 函数调用时可用的具体命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ       _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT     _IOW(<span class="meta-string">'b'</span>, 3, int64_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY    _IOW(<span class="meta-string">'b'</span>, 6, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></div></pre></td></tr></table></figure><p>在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L166" target="_blank" rel="external">BinderDriverReturnProtocol</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L254" target="_blank" rel="external">BinderDriverCommandProtocol</a> 中 则分别定义了 客户端调用 和 服务端 返回的命令。</p><h3 id="4-3-binder-驱动文件操作"><a href="#4-3-binder-驱动文件操作" class="headerlink" title="4.3 binder 驱动文件操作"></a>4.3 binder 驱动文件操作</h3><p>上文已经提到，所有的操作定义在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="external">binder_fops</a> 结构体中，下面讲述这些操作。</p><p><strong>设备的打开 - binder_open() 函数</strong></p><p>用户空间在打开 <code>/dev/binder</code> 设备时，驱动会出发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3004" target="_blank" rel="external">binder_open()</a> 函数的响应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 分配 binder_proc 数据结构内存</span></div><div class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    </div><div class="line">    <span class="comment">// 增加当前线程/进程的引用计数并赋值给tsk</span></div><div class="line">    get_task_struct(current);</div><div class="line">    proc-&gt;tsk = current;</div><div class="line">    <span class="comment">// 初始化队列</span></div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</div><div class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</div><div class="line">    proc-&gt;default_priority = task_nice(current);</div><div class="line"></div><div class="line">    binder_lock(__func__);</div><div class="line"></div><div class="line">    <span class="comment">// 增加BINDER_STAT_PROC的对象计数</span></div><div class="line">    binder_stats_created(BINDER_STAT_PROC);</div><div class="line">    <span class="comment">// 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了</span></div><div class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</div><div class="line">    <span class="comment">// 保存进程 id</span></div><div class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</div><div class="line">    <span class="comment">// 驱动文件 private_data 指向 proc</span></div><div class="line">    filp-&gt;private_data = proc;</div><div class="line"></div><div class="line">    binder_unlock(__func__);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>驱动文件释放 - binder_release() 函数</strong></p><p>在用户空间关闭驱动设备文件时，会调用 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3068" target="_blank" rel="external">binder_release()</a> 函数，清理 binder_proc 对象，释放占用的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">binder_defer_work(struct binder_proc *proc, <span class="keyword">enum</span> binder_deferred_state defer)</div><div class="line">&#123;</div><div class="line">    mutex_lock(&amp;binder_deferred_lock);</div><div class="line">    proc-&gt;deferred_work |= defer;</div><div class="line">    <span class="keyword">if</span> (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123;</div><div class="line">        <span class="comment">// 添加到释放队列中</span></div><div class="line">        hlist_add_head(&amp;proc-&gt;deferred_work_node,</div><div class="line">                &amp;binder_deferred_list);</div><div class="line">        queue_work(binder_deferred_workqueue, &amp;binder_deferred_work);</div><div class="line">    &#125;</div><div class="line">    mutex_unlock(&amp;binder_deferred_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>内存映射 - binder_mmap() 函数</strong></p><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2905" target="_blank" rel="external">binder_mmap()</a> 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></div><div class="line">    <span class="comment">// 获得 binder_proc 对象</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 最多只分配 4M 的内存</span></div><div class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</div><div class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</div><div class="line"></div><div class="line">    <span class="comment">// 检查 flags</span></div><div class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</div><div class="line">        ret = -EPERM;</div><div class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</div><div class="line">        <span class="keyword">goto</span> err_bad_arg;</div><div class="line">    &#125;</div><div class="line">    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</div><div class="line"></div><div class="line">    mutex_lock(&amp;binder_mmap_lock);</div><div class="line">    <span class="comment">// 检查是否已经映射</span></div><div class="line">    <span class="keyword">if</span> (proc-&gt;buffer) &#123;</div><div class="line">        ret = -EBUSY;</div><div class="line">        failure_string = <span class="string">"already mapped"</span>;</div><div class="line">        <span class="keyword">goto</span> err_already_mapped;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 申请内核虚拟内存空间</span></div><div class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</div><div class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"get_vm_area"</span>;</div><div class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将申请到的内存地址保存到 binder_proc 对象中</span></div><div class="line">    proc-&gt;buffer = area-&gt;addr;</div><div class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</div><div class="line">    mutex_unlock(&amp;binder_mmap_lock);</div><div class="line"></div><div class="line">    <span class="comment">// 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针</span></div><div class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc page array"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</div><div class="line">    &#125;</div><div class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</div><div class="line">    vma-&gt;vm_private_data = proc;</div><div class="line"></div><div class="line">    <span class="comment">// 分配一个页的物理内存</span></div><div class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        failure_string = <span class="string">"alloc small buf"</span>;</div><div class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 内存提供给 binder_buffer</span></div><div class="line">    buffer = proc-&gt;buffer;</div><div class="line">    <span class="comment">// 初始化 proc-&gt;buffers 链表</span></div><div class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers);</div><div class="line">    <span class="comment">// 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中</span></div><div class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</div><div class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    binder_insert_free_buffer(proc, buffer);</div><div class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</div><div class="line">    barrier();</div><div class="line">    proc-&gt;files = get_files_struct(proc-&gt;tsk);</div><div class="line">    proc-&gt;vma = vma;</div><div class="line">    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>驱动命令接口 - binder_ioctl() 函数</strong></p><p>用户态程序调用 <code>ioctl</code> 系统函数向 <code>/dev/binder</code> 设备发送数据时，会触发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2734" target="_blank" rel="external">binder_ioctl()</a> 函数响应。</p><p>上文数据结构中已经提到了 <code>binder_ioctl</code> 可以处理的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L87" target="_blank" rel="external">命令</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 核心命令，数据的读写</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ       _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></div><div class="line"><span class="comment">// 设置最大线程数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></div><div class="line"><span class="comment">// 设置 context manager</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></div><div class="line"><span class="comment">// 线程退出命令</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></div><div class="line"><span class="comment">// binder 驱动的版本</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</div><div class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</div><div class="line"></div><div class="line">    <span class="comment">// 检查是否有错误</span></div><div class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">goto</span> err_unlocked;</div><div class="line"></div><div class="line">    binder_lock(__func__);</div><div class="line">    <span class="comment">// 获取 binder_thread 对象</span></div><div class="line">    thread = binder_get_thread(proc);</div><div class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</div><div class="line">        ret = -ENOMEM;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></div><div class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr</span></div><div class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 执行写入操作</span></div><div class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                bwr.read_consumed = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 执行读取操作</span></div><div class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</div><div class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</div><div class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</div><div class="line">                    ret = -EFAULT;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 操作完成后将数据返回给用户空间</span></div><div class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</div><div class="line">            ret = -EFAULT;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS:</div><div class="line">        <span class="comment">// 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads</span></div><div class="line">        <span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</div><div class="line">        <span class="comment">// 检查是否已经设置</span></div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</div><div class="line">            ret = -EBUSY;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置 context manager</span></div><div class="line">        ret = security_binder_set_context_mgr(proc-&gt;tsk);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;</div><div class="line">                ret = -EPERM;</div><div class="line">                <span class="keyword">goto</span> err;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            binder_context_mgr_uid = current-&gt;cred-&gt;euid;</div><div class="line">        <span class="comment">// 创建 binder_context_mgr_node 节点</span></div><div class="line">        binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</div><div class="line">            ret = -ENOMEM;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 初始化节点数据</span></div><div class="line">        binder_context_mgr_node-&gt;local_weak_refs++;</div><div class="line">        binder_context_mgr_node-&gt;local_strong_refs++;</div><div class="line">        binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</div><div class="line">        binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BINDER_THREAD_EXIT:</div><div class="line">        <span class="comment">// 线程退出，释放资源</span></div><div class="line">        binder_free_thread(proc, thread);</div><div class="line">        thread = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> BINDER_VERSION:</div><div class="line">        <span class="comment">// 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中</span></div><div class="line">        <span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) &#123;</div><div class="line">            ret = -EINVAL;</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        ret = -EINVAL;</div><div class="line">        <span class="keyword">goto</span> err;</div><div class="line">    &#125;</div><div class="line">    ret = <span class="number">0</span>;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *ptr,</span></span></div><div class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *cookie)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">nodes</span>.<span class="title">rb_node</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 查找要插入节点的父节点</span></div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        parent = *p;</div><div class="line">        node = rb_entry(parent, struct binder_node, rb_node);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</div><div class="line">            p = &amp;(*p)-&gt;rb_left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</div><div class="line">            p = &amp;(*p)-&gt;rb_right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 为要插入节点分配内存空间</span></div><div class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</div><div class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    binder_stats_created(BINDER_STAT_NODE);</div><div class="line">    <span class="comment">// 插入节点</span></div><div class="line">    rb_link_node(&amp;node-&gt;rb_node, parent, p);</div><div class="line">    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    node-&gt;debug_id = ++binder_last_id;</div><div class="line">    node-&gt;proc = proc;</div><div class="line">    node-&gt;ptr = ptr;</div><div class="line">    node-&gt;cookie = cookie;</div><div class="line">    node-&gt;work.type = BINDER_WORK_NODE;</div><div class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</div><div class="line">    INIT_LIST_HEAD(&amp;node-&gt;async_todo);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>BINDER_WRITE_READ 处理过程</strong></p><p>在 binder 本地层中，我们看到在 <code>IPCThreadState::talkWithDriver()</code> 函数中， binder 本地层通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="external">ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 命令的形式，与 binder 驱动交互。</p><p>可以看出 <code>ioctl()</code> 的第三个参数是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L69" target="_blank" rel="external">binder_write_read</a> 结构体</p><p>binder.h 头文件中定义了两个数据类型, 一个是 <code>binder_write_read</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></div><div class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>其中 <code>write_size</code> 和 <code>read_size</code> 表示需要被读写的字节数， <code>write_consumed</code> 和 <code>read_consumed</code> 表示已经被 binder 驱动读写的字节数， <code>write_buffer</code> 和 <code>read_buffer</code> 则是指向被读写数据的指针。</p><p>具体的读写操作被 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1852" target="_blank" rel="external">binder_thread_write</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2266" target="_blank" rel="external">binder_thread_read</a> 实现。</p><p><strong>数据写入 - binder_thread_write() 函数</strong></p><p>将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> cmd;</div><div class="line">    <span class="comment">// 用户空间数据，起始地址和结束地址</span></div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="comment">// 循环读取</span></div><div class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</div><div class="line">        <span class="comment">// 从用户空间获取操作命令</span></div><div class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</div><div class="line">            <span class="comment">// 增加命令计数器</span></div><div class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">        <span class="comment">// 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref</span></div><div class="line">        <span class="keyword">case</span> BC_INCREFS:</div><div class="line">        <span class="keyword">case</span> BC_ACQUIRE:</div><div class="line">        <span class="keyword">case</span> BC_RELEASE:</div><div class="line">        <span class="keyword">case</span> BC_DECREFS: &#123;</div><div class="line">            <span class="keyword">uint32_t</span> target;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *debug_string;</div><div class="line">            </div><div class="line">            <span class="comment">// 获取目标进程节点描述 desc</span></div><div class="line">            <span class="keyword">if</span> (get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">            <span class="comment">// 索描述为 0 表示 context manager 进程</span></div><div class="line">            <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; binder_context_mgr_node &amp;&amp;</div><div class="line">                (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123;</div><div class="line">                <span class="comment">// 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用</span></div><div class="line">                ref = binder_get_ref_for_node(proc,</div><div class="line">                           binder_context_mgr_node);</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                <span class="comment">// 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用</span></div><div class="line">                ref = binder_get_ref(proc, target);</div><div class="line">            <span class="keyword">switch</span> (cmd) &#123;</div><div class="line">            <span class="keyword">case</span> BC_INCREFS:</div><div class="line">                debug_string = <span class="string">"IncRefs"</span>;</div><div class="line">                <span class="comment">// 增加弱引用计数</span></div><div class="line">                binder_inc_ref(ref, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BC_ACQUIRE:</div><div class="line">                debug_string = <span class="string">"Acquire"</span>;</div><div class="line">                <span class="comment">// 增加强引用计数</span></div><div class="line">                binder_inc_ref(ref, <span class="number">1</span>, <span class="literal">NULL</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BC_RELEASE:</div><div class="line">                debug_string = <span class="string">"Release"</span>;</div><div class="line">                <span class="comment">// 减少强引用计数</span></div><div class="line">                binder_dec_ref(ref, <span class="number">1</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> BC_DECREFS:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                debug_string = <span class="string">"DecRefs"</span>;</div><div class="line">                <span class="comment">// 减少弱引用计数</span></div><div class="line">                binder_dec_ref(ref, <span class="number">0</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> BC_INCREFS_DONE:</div><div class="line">        <span class="keyword">case</span> BC_ACQUIRE_DONE: &#123;</div><div class="line">            <span class="keyword">void</span> __user *node_ptr;</div><div class="line">            <span class="keyword">void</span> *cookie;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></div><div class="line">            </div><div class="line">            <span class="comment">// 从用户空间读取 node_ptr</span></div><div class="line">            <span class="keyword">if</span> (get_user(node_ptr, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            <span class="comment">// 从用户空间读取 cookie</span></div><div class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            <span class="comment">// 获得节点</span></div><div class="line">            node = binder_get_node(proc, node_ptr);</div><div class="line">            <span class="comment">// 没有找到则返回</span></div><div class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">                    <span class="string">"%s u%p no match\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    cmd == BC_INCREFS_DONE ?</div><div class="line">                    <span class="string">"BC_INCREFS_DONE"</span> :</div><div class="line">                    <span class="string">"BC_ACQUIRE_DONE"</span>,</div><div class="line">                    node_ptr);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// cookie 不匹配则返回</span></div><div class="line">            <span class="keyword">if</span> (cookie != node-&gt;cookie) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d %s u%p node %d"</span></div><div class="line">                    <span class="string">" cookie mismatch %p != %p\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    cmd == BC_INCREFS_DONE ?</div><div class="line">                    <span class="string">"BC_INCREFS_DONE"</span> : <span class="string">"BC_ACQUIRE_DONE"</span>,</div><div class="line">                    node_ptr, node-&gt;debug_id,</div><div class="line">                    cookie, node-&gt;cookie);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (cmd == BC_ACQUIRE_DONE) &#123;</div><div class="line">                node-&gt;pending_strong_ref = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node-&gt;pending_weak_ref = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 减少节点使用计数</span></div><div class="line">            binder_dec_node(node, cmd == BC_ACQUIRE_DONE, <span class="number">0</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 释放 binder_bffer</span></div><div class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</div><div class="line">            <span class="keyword">void</span> __user *data_ptr;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></div><div class="line"></div><div class="line">            <span class="comment">// 从用户空间获取 data_ptr</span></div><div class="line">            <span class="keyword">if</span> (get_user(data_ptr, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"></div><div class="line">            <span class="comment">// 查找 binder_buffer</span></div><div class="line">            buffer = binder_buffer_lookup(proc, data_ptr);</div><div class="line">            <span class="comment">// 没有找到则返回</span></div><div class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">                    <span class="string">"BC_FREE_BUFFER u%p no match\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 不允许用户释放则返回</span></div><div class="line">            <span class="keyword">if</span> (!buffer-&gt;allow_user_free) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d "</span></div><div class="line">                    <span class="string">"BC_FREE_BUFFER u%p matched "</span></div><div class="line">                    <span class="string">"unreturned buffer\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, data_ptr);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 将 buffer-&gt;transaction 置空</span></div><div class="line">            <span class="keyword">if</span> (buffer-&gt;transaction) &#123;</div><div class="line">                buffer-&gt;transaction-&gt;buffer = <span class="literal">NULL</span>;</div><div class="line">                buffer-&gt;transaction = <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123;</div><div class="line">                <span class="keyword">if</span> (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))</div><div class="line">                    buffer-&gt;target_node-&gt;has_async_transaction = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 释放 binder_buffer 对象</span></div><div class="line">            trace_binder_transaction_buffer_release(buffer);</div><div class="line">            binder_transaction_buffer_release(proc, buffer, <span class="literal">NULL</span>);</div><div class="line">            binder_free_buf(proc, buffer);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// binder 数据传递处理</span></div><div class="line">        <span class="keyword">case</span> BC_TRANSACTION:</div><div class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></div><div class="line"></div><div class="line">            <span class="comment">// 从用户空间拷贝 binder_transaction_data 对象</span></div><div class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line">            <span class="comment">// 实际的传输函数，在下文讲解</span></div><div class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态</span></div><div class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123;</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"after BC_ENTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span>) &#123;</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_REGISTER_LOOPER called "</span></div><div class="line">                    <span class="string">"without request\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                proc-&gt;requested_threads--;</div><div class="line">                proc-&gt;requested_threads_started++;</div><div class="line">            &#125;</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态</span></div><div class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</div><div class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</div><div class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></div><div class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></div><div class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid);</div><div class="line">            &#125;</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态</span></div><div class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</div><div class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知</span></div><div class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</div><div class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</div><div class="line">            <span class="keyword">uint32_t</span> target;</div><div class="line">            <span class="keyword">void</span> __user *cookie;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></div><div class="line">            </div><div class="line">            <span class="comment">// 从用户空间获取 binder_ref 描述 desc</span></div><div class="line">            <span class="keyword">if</span> (get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">            <span class="comment">// 从用户空间获取 cookie</span></div><div class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            <span class="comment">// 获取 binder_ref 引用</span></div><div class="line">            ref = binder_get_ref(proc, target);</div><div class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d %s "</span></div><div class="line">                    <span class="string">"invalid ref %d\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid,</div><div class="line">                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?</div><div class="line">                    <span class="string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :</div><div class="line">                    <span class="string">"BC_CLEAR_DEATH_NOTIFICATION"</span>,</div><div class="line">                    target);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123;</div><div class="line">                <span class="keyword">if</span> (ref-&gt;death) &#123;</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">                        <span class="string">"d BC_REQUEST_DEATH_NOTI"</span></div><div class="line">                        <span class="string">"FICATION death notific"</span></div><div class="line">                        <span class="string">"ation already set\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 为 binder_ref_death 对象分配内存空间</span></div><div class="line">                death = kzalloc(<span class="keyword">sizeof</span>(*death), GFP_KERNEL);</div><div class="line">                <span class="keyword">if</span> (death == <span class="literal">NULL</span>) &#123;</div><div class="line">                    thread-&gt;return_error = BR_ERROR;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 初始化 binder_ref_death 对象</span></div><div class="line">                binder_stats_created(BINDER_STAT_DEATH);</div><div class="line">                INIT_LIST_HEAD(&amp;death-&gt;work.entry);</div><div class="line">                death-&gt;cookie = cookie;</div><div class="line">                ref-&gt;death = death;</div><div class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == <span class="literal">NULL</span>) &#123;</div><div class="line">                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</div><div class="line">                    <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</div><div class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);</div><div class="line">                        <span class="comment">// 唤醒目标进程</span></div><div class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (ref-&gt;death == <span class="literal">NULL</span>) &#123;</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">                        <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">                        <span class="string">"CATION death notificat"</span></div><div class="line">                        <span class="string">"ion not active\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                death = ref-&gt;death;</div><div class="line">                <span class="keyword">if</span> (death-&gt;cookie != cookie) &#123;</div><div class="line">                    binder_user_error(<span class="string">"binder: %d:%"</span></div><div class="line">                        <span class="string">"d BC_CLEAR_DEATH_NOTIFI"</span></div><div class="line">                        <span class="string">"CATION death notificat"</span></div><div class="line">                        <span class="string">"ion cookie mismatch "</span></div><div class="line">                        <span class="string">"%p != %p\n"</span>,</div><div class="line">                        proc-&gt;pid, thread-&gt;pid,</div><div class="line">                        death-&gt;cookie, cookie);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 将 ref-&gt;death 置空</span></div><div class="line">                ref-&gt;death = <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">if</span> (list_empty(&amp;death-&gt;work.entry)) &#123;</div><div class="line">                    death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">                    <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</div><div class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</div><div class="line">                        <span class="comment">// 唤醒目标进程</span></div><div class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);</div><div class="line">                    death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BC_DEAD_BINDER_DONE: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></div><div class="line">            <span class="keyword">void</span> __user *cookie;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span> = <span class="title">NULL</span>;</span></div><div class="line">            <span class="comment">// 从用户空间获取 cookie</span></div><div class="line">            <span class="keyword">if</span> (get_user(cookie, (<span class="keyword">void</span> __user * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line"></div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123;</div><div class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">tmp_death</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">binder_ref_death</span>, <span class="title">work</span>);</span></div><div class="line">                <span class="keyword">if</span> (tmp_death-&gt;cookie == cookie) &#123;</div><div class="line">                    death = tmp_death;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (death == <span class="literal">NULL</span>) &#123;</div><div class="line">                binder_user_error(<span class="string">"binder: %d:%d BC_DEAD"</span></div><div class="line">                    <span class="string">"_BINDER_DONE %p not found\n"</span>,</div><div class="line">                    proc-&gt;pid, thread-&gt;pid, cookie);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            list_del_init(&amp;death-&gt;work.entry);</div><div class="line">            <span class="comment">// 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span></div><div class="line">            <span class="keyword">if</span> (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) &#123;</div><div class="line">                death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</div><div class="line">                <span class="keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</div><div class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</div><div class="line">                    <span class="comment">// 唤醒目标进程</span></div><div class="line">                    wake_up_interruptible(&amp;proc-&gt;wait);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> -EINVAL;</div><div class="line">        &#125;</div><div class="line">        *consumed = ptr - buffer;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>binder_transaction() 函数</strong></p><p>在上文处理 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2041" target="_blank" rel="external">BC_TRANSACTION</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2042" target="_blank" rel="external">BC_REPLY</a> 时，调用了 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1417" target="_blank" rel="external">binder_transaction()</a> 函数。我们继续追踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></div><div class="line">    <span class="keyword">size_t</span> *offp, *off_end;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></div><div class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        <span class="comment">// BC_REPLY 处理流程</span></div><div class="line">        <span class="comment">// 得到 binder_transaction 对象</span></div><div class="line">        in_reply_to = thread-&gt;transaction_stack;</div><div class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_empty_call_stack;</div><div class="line">        &#125;</div><div class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</div><div class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</div><div class="line">        <span class="comment">// 获取目标线程</span></div><div class="line">        target_thread = in_reply_to-&gt;from;</div><div class="line">        target_proc = target_thread-&gt;proc;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// BC_TRANSACTION 处理流程</span></div><div class="line">        <span class="comment">// 查找目标节点</span></div><div class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</div><div class="line">            struct binder_ref *ref;</div><div class="line">            <span class="comment">// 获取 binder_ref 对象</span></div><div class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</div><div class="line">            target_node = ref-&gt;node;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 索引为 0 则返回 context manager</span></div><div class="line">            target_node = binder_context_mgr_node;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 得到目标进程</span></div><div class="line">        target_proc = target_node-&gt;proc;</div><div class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></div><div class="line">            tmp = thread-&gt;transaction_stack;</div><div class="line">            <span class="keyword">while</span> (tmp) &#123;</div><div class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</div><div class="line">                    <span class="comment">// 获得目标线程</span></div><div class="line">                    target_thread = tmp-&gt;from;</div><div class="line">                tmp = tmp-&gt;from_parent;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置要处理的目标进程或目标线程任务</span></div><div class="line">    <span class="keyword">if</span> (target_thread) &#123;</div><div class="line">        target_list = &amp;target_thread-&gt;todo;</div><div class="line">        target_wait = &amp;target_thread-&gt;wait;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        target_list = &amp;target_proc-&gt;todo;</div><div class="line">        target_wait = &amp;target_proc-&gt;wait;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 为 binder_transaction 对象分配内存空间</span></div><div class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</div><div class="line"></div><div class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</div><div class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line"></div><div class="line">    <span class="comment">// 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。</span></div><div class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</div><div class="line">        t-&gt;from = thread;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        t-&gt;from = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 设置 binder_transaction 对象</span></div><div class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</div><div class="line">    t-&gt;to_proc = target_proc;</div><div class="line">    t-&gt;to_thread = target_thread;</div><div class="line">    t-&gt;code = tr-&gt;code;</div><div class="line">    t-&gt;flags = tr-&gt;flags;</div><div class="line">    t-&gt;priority = task_nice(current);</div><div class="line"></div><div class="line">    <span class="comment">// 为 binder_buffer 分配内存空间</span></div><div class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</div><div class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</div><div class="line">    <span class="comment">// 设置 binder_buffer</span></div><div class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</div><div class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</div><div class="line">    t-&gt;buffer-&gt;transaction = t;</div><div class="line">    t-&gt;buffer-&gt;target_node = target_node;</div><div class="line">    <span class="keyword">if</span> (target_node)</div><div class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</div><div class="line"></div><div class="line">    <span class="comment">// 从用户空间拷贝数据到 binder_buffer</span></div><div class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</div><div class="line">        return_error = BR_FAILED_REPLY;</div><div class="line">        <span class="keyword">goto</span> err_copy_data_failed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</div><div class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></div><div class="line">        <span class="comment">// 为 flat_binder_object 赋值</span></div><div class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</div><div class="line">        <span class="comment">// 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE</span></div><div class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></div><div class="line">            <span class="comment">// 获取 binder_node 节点</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></div><div class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</div><div class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</div><div class="line">                <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</div><div class="line">                    return_error = BR_FAILED_REPLY;</div><div class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</div><div class="line">                &#125;</div><div class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</div><div class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</div><div class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取 binder_ref 对象</span></div><div class="line">            ref = binder_get_ref_for_node(target_proc, node);</div><div class="line">            <span class="comment">// 转换类型</span></div><div class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</div><div class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</div><div class="line">            fp-&gt;handle = ref-&gt;desc;</div><div class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</div><div class="line">                       &amp;thread-&gt;todo);</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</div><div class="line">            <span class="comment">// 获取 binder_ref 对象</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span>*<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></div><div class="line">            <span class="comment">// 转换类型</span></div><div class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</div><div class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</div><div class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</div><div class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</div><div class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</div><div class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                struct binder_ref *new_ref;</div><div class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</div><div class="line">                fp-&gt;handle = new_ref-&gt;desc;</div><div class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 文件类型</span></div><div class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</div><div class="line">            <span class="keyword">int</span> target_fd;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></div><div class="line">            <span class="comment">// 获得文件对象</span></div><div class="line">            file = fget(fp-&gt;handle);</div><div class="line">            <span class="comment">// 分配一个新的文件描述符</span></div><div class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</div><div class="line">            task_fd_install(target_proc, target_fd, file);</div><div class="line">            fp-&gt;handle = target_fd;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            return_error = BR_FAILED_REPLY;</div><div class="line">            <span class="keyword">goto</span> err_bad_object_type;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (reply) &#123;</div><div class="line">        <span class="comment">// BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象</span></div><div class="line">        binder_pop_transaction(target_thread, in_reply_to);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</div><div class="line">        <span class="comment">// 同步状态(双向)需要设置回复</span></div><div class="line">        t-&gt;need_reply = <span class="number">1</span>;</div><div class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</div><div class="line">        thread-&gt;transaction_stack = t;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 异步传输不需要设置回复</span></div><div class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) &#123;</div><div class="line">            target_list = &amp;target_node-&gt;async_todo;</div><div class="line">            target_wait = <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</div><div class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</div><div class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</div><div class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</div><div class="line">    <span class="keyword">if</span> (target_wait)</div><div class="line">        <span class="comment">// 唤醒目标线程</span></div><div class="line">        wake_up_interruptible(target_wait);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>数据读取 - binder_thread_read() 函数</strong></p><p>用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></div><div class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</div><div class="line">    <span class="keyword">void</span> __user *end = buffer + size;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_for_proc_work;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 第一次操作时向用户空间返回 BR_NOOP 命令</span></div><div class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">retry:</div><div class="line">    <span class="comment">// 获取将要处理的任务</span></div><div class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</div><div class="line">                list_empty(&amp;thread-&gt;todo);</div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</div><div class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</div><div class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</div><div class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></div><div class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></div><div class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</div><div class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</div><div class="line">            wait_event_interruptible(binder_user_error_wait,</div><div class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        binder_set_nice(proc-&gt;default_priority);</div><div class="line">        <span class="keyword">if</span> (non_block) &#123;</div><div class="line">            <span class="comment">// 非阻塞且没有数据则返回 EAGAIN</span></div><div class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="comment">// 阻塞则进入睡眠状态，等待可操作的任务</span></div><div class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (non_block) &#123;</div><div class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</div><div class="line">                ret = -EAGAIN;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    binder_lock(__func__);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (wait_for_proc_work)</div><div class="line">        proc-&gt;ready_threads--;</div><div class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">uint32_t</span> cmd;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></div><div class="line"></div><div class="line">        <span class="comment">// 获取 binder_work 对象</span></div><div class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</div><div class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</div><div class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></div><div class="line">                <span class="keyword">goto</span> retry;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</div><div class="line">            <span class="comment">// 获取 binder_transaction 对象</span></div><div class="line">            t = container_of(w, struct binder_transaction, work);</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</div><div class="line">            cmd = BR_TRANSACTION_COMPLETE;</div><div class="line">            <span class="comment">// 返回 BR_TRANSACTION_COMPLETE 命令</span></div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line"></div><div class="line">            binder_stat_br(proc, thread, cmd);</div><div class="line"></div><div class="line">            <span class="comment">// 从 work 链表中删除并释放内存</span></div><div class="line">            list_del(&amp;w-&gt;entry);</div><div class="line">            kfree(w);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_NODE: &#123;</div><div class="line">            <span class="comment">// 获得 binder_node 节点</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">container_of</span>(<span class="title">w</span>, <span class="title">struct</span> <span class="title">binder_node</span>, <span class="title">work</span>);</span></div><div class="line">            <span class="keyword">uint32_t</span> cmd = BR_NOOP;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *cmd_name;</div><div class="line">            <span class="comment">// 根据节点类型，增加/获取、减少/释放节点索引</span></div><div class="line">            <span class="keyword">int</span> strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs;</div><div class="line">            <span class="keyword">int</span> weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong;</div><div class="line">            <span class="comment">// 构造 BR_* 命令</span></div><div class="line">            <span class="keyword">if</span> (weak &amp;&amp; !node-&gt;has_weak_ref) &#123;</div><div class="line">                cmd = BR_INCREFS;</div><div class="line">                cmd_name = <span class="string">"BR_INCREFS"</span>;</div><div class="line">                node-&gt;has_weak_ref = <span class="number">1</span>;</div><div class="line">                node-&gt;pending_weak_ref = <span class="number">1</span>;</div><div class="line">                node-&gt;local_weak_refs++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strong &amp;&amp; !node-&gt;has_strong_ref) &#123;</div><div class="line">                cmd = BR_ACQUIRE;</div><div class="line">                cmd_name = <span class="string">"BR_ACQUIRE"</span>;</div><div class="line">                node-&gt;has_strong_ref = <span class="number">1</span>;</div><div class="line">                node-&gt;pending_strong_ref = <span class="number">1</span>;</div><div class="line">                node-&gt;local_strong_refs++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strong &amp;&amp; node-&gt;has_strong_ref) &#123;</div><div class="line">                cmd = BR_RELEASE;</div><div class="line">                cmd_name = <span class="string">"BR_RELEASE"</span>;</div><div class="line">                node-&gt;has_strong_ref = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!weak &amp;&amp; node-&gt;has_weak_ref) &#123;</div><div class="line">                cmd = BR_DECREFS;</div><div class="line">                cmd_name = <span class="string">"BR_DECREFS"</span>;</div><div class="line">                node-&gt;has_weak_ref = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 向用户空间返回命令</span></div><div class="line">            <span class="keyword">if</span> (cmd != BR_NOOP) &#123;</div><div class="line">                <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">                    <span class="keyword">return</span> -EFAULT;</div><div class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">                <span class="keyword">if</span> (put_user(node-&gt;ptr, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                    <span class="keyword">return</span> -EFAULT;</div><div class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">                <span class="keyword">if</span> (put_user(node-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                    <span class="keyword">return</span> -EFAULT;</div><div class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line"></div><div class="line">                binder_stat_br(proc, thread, cmd);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                list_del_init(&amp;w-&gt;entry);</div><div class="line">                <span class="keyword">if</span> (!weak &amp;&amp; !strong) &#123;</div><div class="line">                    rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</div><div class="line">                    kfree(node);</div><div class="line">                    binder_stats_deleted(BINDER_STAT_NODE);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</div><div class="line">        <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></div><div class="line">            <span class="keyword">uint32_t</span> cmd;</div><div class="line"></div><div class="line">            <span class="comment">// 获取 binder_ref_death 对象</span></div><div class="line">            death = container_of(w, struct binder_ref_death, work);</div><div class="line">            <span class="comment">// 构造返回命令</span></div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</div><div class="line">                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                cmd = BR_DEAD_BINDER;</div><div class="line">            <span class="comment">// 向用户空间返回命令</span></div><div class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">            <span class="comment">// 将 cookie 返回给用户空间</span></div><div class="line">            <span class="keyword">if</span> (put_user(death-&gt;cookie, (<span class="keyword">void</span> * __user *)ptr))</div><div class="line">                <span class="keyword">return</span> -EFAULT;</div><div class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">            binder_stat_br(proc, thread, cmd);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123;</div><div class="line">                list_del(&amp;w-&gt;entry);</div><div class="line">                kfree(death);</div><div class="line">                binder_stats_deleted(BINDER_STAT_DEATH);</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);</div><div class="line">            <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)</div><div class="line">                <span class="keyword">goto</span> done; <span class="comment">/* DEAD_BINDER notifications can cause transactions */</span></div><div class="line">        &#125; <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!t)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</div><div class="line">            <span class="comment">// 获得 binder_node 节点</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></div><div class="line">            <span class="comment">// 将数据封装到 binder_transaction_data 对象</span></div><div class="line">            tr.target.ptr = target_node-&gt;ptr;</div><div class="line">            tr.cookie =  target_node-&gt;cookie;</div><div class="line">            t-&gt;saved_priority = task_nice(current);</div><div class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</div><div class="line">                !(t-&gt;flags &amp; TF_ONE_WAY))</div><div class="line">                binder_set_nice(t-&gt;priority);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</div><div class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</div><div class="line">                binder_set_nice(target_node-&gt;min_priority);</div><div class="line">            <span class="comment">// 设置返回的命令类型</span></div><div class="line">            cmd = BR_TRANSACTION;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tr.target.ptr = <span class="literal">NULL</span>;</div><div class="line">            tr.cookie = <span class="literal">NULL</span>;</div><div class="line">            cmd = BR_REPLY;</div><div class="line">        &#125;</div><div class="line">        tr.code = t-&gt;code;</div><div class="line">        tr.flags = t-&gt;flags;</div><div class="line">        tr.sender_euid = t-&gt;sender_euid;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</div><div class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></div><div class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</div><div class="line">                            current-&gt;nsproxy-&gt;pid_ns);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tr.sender_pid = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</div><div class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</div><div class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</div><div class="line">                    proc-&gt;user_buffer_offset;</div><div class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</div><div class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</div><div class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">        <span class="comment">// 拷贝 binder_transaction_data 对象到用户空间</span></div><div class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</div><div class="line">            <span class="keyword">return</span> -EFAULT;</div><div class="line">        ptr += <span class="keyword">sizeof</span>(tr);</div><div class="line"></div><div class="line">        binder_stat_br(proc, thread, cmd);</div><div class="line"></div><div class="line">        <span class="comment">// 移除 binder_transaction 并释放空间</span></div><div class="line">        list_del(&amp;t-&gt;work.entry);</div><div class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</div><div class="line">        <span class="comment">// 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象</span></div><div class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</div><div class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</div><div class="line">            t-&gt;to_thread = thread;</div><div class="line">            thread-&gt;transaction_stack = t;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</div><div class="line">            kfree(t);</div><div class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。</p><h2 id="5-Binder-与系统服务"><a href="#5-Binder-与系统服务" class="headerlink" title="5. Binder 与系统服务"></a>5. Binder 与系统服务</h2><h3 id="5-1-Context-getSystemService"><a href="#5-1-Context-getSystemService" class="headerlink" title="5.1 Context.getSystemService()"></a>5.1 Context.getSystemService()</h3><p>Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.Class&lt;T" target="_blank" rel="external">服务</a>) 主要有 <code>WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager</code></p><p>我们可以通过 <code>Context.getSystemService(String name)</code> 来获取 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String" target="_blank" rel="external">服务</a>)。</p><p>例如 可以通过如下方法从 xml 中插入新的视图</p><pre><code>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);inflater.inflate(R.layout.view, root, true);</code></pre><h3 id="5-2-Context-getSystemService-源码分析"><a href="#5-2-Context-getSystemService-源码分析" class="headerlink" title="5.2 Context.getSystemService() 源码分析"></a>5.2 Context.getSystemService() 源码分析</h3><p>追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1364" target="_blank" rel="external">ContextImpl</a> <code>getSystemService()</code> 源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L719" target="_blank" rel="external">SystemServiceRegistry</a> 源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Gets a system service from a given context.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>追踪 <code>SYSTEM_SERVICE_FETCHERS</code> 可以发现在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L318" target="_blank" rel="external">SystemServiceRegistry</a> 静态区中注册了几乎所有的系统服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div><div class="line"></div><div class="line">registerService(Context.LOCATION_SERVICE, LocationManager.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LocationManager&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LocationManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocationManager(ctx, ILocationManager.Stub.asInterface(b));</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure><p>上面代码片断中，<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L322" target="_blank" rel="external">PhoneLayoutInflater</a> 最终回到了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/view/LayoutInflater.java#L204" target="_blank" rel="external">LayoutInflater</a>。而 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/LocationManager.java#L315" target="_blank" rel="external">LocationManager</a> 则是对 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/ILocationManager.aidl#L39" target="_blank" rel="external">ILocationManager</a> 的封装。可以发现，在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/location/java/android/location" target="_blank" rel="external">frameworks/base/location/java/android/location</a> 包下含有大量的 AIDL 文件。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L49" target="_blank" rel="external">ServiceManager.getService(Context.LOCATION_SERVICE)</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> sServiceManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Find the service manager</span></div><div class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</div><div class="line">    <span class="keyword">return</span> sServiceManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns a reference to a service with the given name.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the service to get</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        IBinder service = sCache.get(name);</div><div class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> service;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面代码片断可以看出，<code>ServiceManager</code> 会从 <code>sCache</code> 缓存或 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="external">IServiceManager</a> 中查找服务并返回一个 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L85" target="_blank" rel="external">IBinder</a> 对象。这个 <code>IBinder</code> 就是一个远程对象，可以通过它与其他进程交互。 </p><p>继续深入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L55" target="_blank" rel="external">getIServiceManager().getService(name)</a> , 进入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="external">ServiceManagerNative</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Cast a Binder object into a service manager interface, generating</span></div><div class="line"><span class="comment"> * a proxy if needed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    IServiceManager in =</div><div class="line">        (IServiceManager)obj.queryLocalInterface(descriptor);</div><div class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> in;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</div><div class="line">        mRemote = remote;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mRemote;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</div><div class="line">        data.writeString(name);</div><div class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        IBinder binder = reply.readStrongBinder();</div><div class="line">        reply.recycle();</div><div class="line">        data.recycle();</div><div class="line">        <span class="keyword">return</span> binder;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> IBinder mRemote;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上边代码片断可以看到，<code>ServiceManager.getIServiceManager()</code> 返回的是一个 <code>ServiceManagerProxy</code>, 而 <code>ServiceManager.getService()</code> 则是在 <code>ServiceManagerProxy</code> 中通过 <code>ServiceManager</code> 的远程 <code>Binder</code> 对象 <code>mRemote</code>，操作 <code>Parcel</code> 数据，调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L223" target="_blank" rel="external">IBinder.transact(int code, Parcel data, Parcel reply, int flags)</a> 方法来发送请求，并通过 <code>reply.readStrongBinder()</code> 返回了要查找的服务的远程对象。</p><p>可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。</p><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。</p><p>2. 上层的 <code>android.os.Binder</code> 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。</p><p>3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 <code>transact</code> 和 <code>onTransact</code> 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><a href="http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/" target="_blank" rel="external">Android Binder机制</a></p><p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android进程间通信（IPC）机制Binder</a></p><p><a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" target="_blank" rel="external">Android Binder</a></p><p><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Android_Architecture_Binder.pdf" target="_blank" rel="external">Android Architecture Binder</a></p><p><a href="http://liuxiangtian.github.io/2016/01/07/AIDL%E4%B8%8EBinder%E6%A1%86%E6%9E%B6%E6%B5%85%E8%B0%88/" target="_blank" rel="external">AIDL与Binder框架浅谈</a></p><p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">Binder框架解析</a></p><p><a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf" target="_blank" rel="external">Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013</a></p><p><a href="https://www.youtube.com/watch?v=NWhyADzgoiI" target="_blank" rel="external">Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video)</a></p><p><a href="http://blog.csdn.net/u010961631/article/details/20479507" target="_blank" rel="external">Binder源码分析之驱动层（原）</a></p><p><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a></p><p><a href="http://blog.csdn.net/qq429205464/article/details/7822442" target="_blank" rel="external">构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解</a></p><p><a href="http://blog.csdn.net/21cnbao/article/details/8087354" target="_blank" rel="external">Service与Android系统设计（7）— Binder驱动</a></p><p><a href="https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11" target="_blank" rel="external">Android Binder</a></p><p><a href="http://www.cnblogs.com/zhangxinyan/p/3487889.html" target="_blank" rel="external">Binder机制，从Java到C （7. Native Service）</a></p><hr><p><strong>待补充的内容</strong></p><p>1. 客户端 bindService() 流程及源码分析</p><p>2. Binder Native 层其他源码文件分析</p><p>3. 系统服务（SystemService）详细列表及在本地层的源码分析</p><p>4. SystemManager 源码分析</p><p>5. 完善 binder 驱动内容，补充关系图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;forked from &lt;a href=&quot;https://github.com/xdtianyu/SourceAnalysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xdtianyu/SourceAnalysis&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Binder" scheme="https://yangxiaoge.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android O上手体验</title>
    <link href="https://yangxiaoge.github.io/2017/05/19/Android-O%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://yangxiaoge.github.io/2017/05/19/Android-O上手体验/</id>
    <published>2017-05-19T13:34:15.000Z</published>
    <updated>2017-09-20T09:55:11.016Z</updated>
    
    <content type="html"><![CDATA[<p>2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 <a href="http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="external">stormzhang</a> （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。<br>有几个重要的事件：Google AI，Android O，Kotlin，等等<br>本文重点是 Android O 的上手视频，迫不及待的把测试机 Nexus 5X 刷成了 Android 0，<a href="https://developer.android.com/preview/download.html" target="_blank" rel="external">Android O 系统映像文件下载</a>，官网介绍特性：<a href="https://developer.android.com/preview/index.html" target="_blank" rel="external">Android O 新特性介绍</a>。</p><p><strong>上手视频：</strong><br><!--<video height="800" controls>    <source src="/img/video/Android8.0device-2017-05-19-131435.mp4"></video>--><br><!--宽占满，高度自适应。 poster 预加载显示的图像--></p><video height="700" id="video" controls preload="none" poster="/img/video/Android_O_Preload.png"><br>      <source id="mp4" src="/img/video/Android8.0device-2017-05-19-131435.mp4" type="video/mp4"><br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 &lt;a href=&quot;http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-3972
      
    
    </summary>
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/categories/Android-O/"/>
    
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/tags/Android-O/"/>
    
  </entry>
  
  <entry>
    <title>Android输入法加密研究</title>
    <link href="https://yangxiaoge.github.io/2017/05/09/Android%E8%BE%93%E5%85%A5%E6%B3%95%E5%8A%A0%E5%AF%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://yangxiaoge.github.io/2017/05/09/Android输入法加密研究/</id>
    <published>2017-05-09T09:51:03.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>近期接到一个微信，QQ 聊天时加密文字的需求。<br>我当时的心情是这样的：<br><img src="/img/Android输入法加密研究/kidding_me.png" width="150" alt="are you kidding me?" align="center"></p><h2 id="开源项目入手"><a href="#开源项目入手" class="headerlink" title="开源项目入手"></a>开源项目入手</h2><p>冷静下来，细细思考，要不开发一个输入法？我这是要挑战搜狗输入法一个团队吗，不现实呀！然后就找到了 Goolge 开源的 PinyinIME（Android 4.4.4）。<br>毕竟输入法将输入的文字设置到编辑框要走 BaseInputConnection 中 commitText 方法，那么我就想在这个地方动手脚呗。嗯，说干就干，我就撸了一下 PinyinIME 项目中的代码，实现效果如下：(加密后的文字后面我加了一个 “中” 字)<br><img src="/img/Android输入法加密研究/撸了个加密.png" width="350" alt="加密前后" align="center"></p><p>哎呦，看着也还凑活哈。嗯，然后打开搜狗，百度输入法一看，用户就不乐意了，你家输入法真挫！一怒之下不用了。虽然这是个笑话，但是开发输入法代价太大了，毕竟要大量时间，人力。</p><h2 id="源码分析入手"><a href="#源码分析入手" class="headerlink" title="源码分析入手"></a>源码分析入手</h2><p>所以啊，我想要不从系统层入手？（<a href="https://developer.android.com/reference/android/inputmethodservice/InputMethodService.html?hl=zh-cn" target="_blank" rel="external">查了下 Api</a>）</p><ul><li><p><code>frameworks/base/...</code> 下有个类 <code>InputMethodManager</code> (输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的 context 中，用来沟通管理所有进程间交互的全局系统服务。) 中有个方法 showSoftInput (View view, int flags, ResultReceiver resultReceiver)。 注意到一个 view 参数，此参数就是输入框（微信，QQ，等输入框，webview除外）的 View，既然有了 view，那么我就可以 getText，setText 等等操作。<br>我将 view 中的内容 Toast 出来效果如下：<br><img src="/img/Android输入法加密研究/input_method2.png" width="350" alt="InputMethodManager中获取输入框对象，随时可以获取文本" align="center"></p></li><li><p><code>InputMethodService</code>，每个<code>输入法 App</code> 应用都是继承自它！那么就可以对它的生命周期下手了。输入法显示的时候开启一个自定义的服务（有悬浮窗的），输入法关闭的时候结束服务并且释放相应的静态变量。重点就在于生命周期的研究！</p></li><li><p>目的是，将 <code>InputMethodManager</code> 中的 编辑框 View 对象存起来，然后在 InputMethodService 中启动的服务 暂且叫做 <code>MyFloatEncryService</code> 中获取这个 View，之后就直接可以 get，set 加密了。</p></li></ul><p>实现方案在开发中，后续补充~~~ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期接到一个微信，QQ 聊天时加密文字的需求。&lt;br&gt;我当时的心情是这样的：&lt;br&gt;&lt;img src=&quot;/img/Android输入法加密研究/kidding_me.png&quot; width=&quot;150&quot; alt=&quot;are you kidding me?&quot; align=&quot;cent
      
    
    </summary>
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/categories/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译</title>
    <link href="https://yangxiaoge.github.io/2017/05/04/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>https://yangxiaoge.github.io/2017/05/04/Android源码编译/</id>
    <published>2017-05-04T11:40:24.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）</p><ul><li><code>source build/envsetup.sh</code></li><li><code>lunch</code> (我的项目中选了 79)</li><li><code>make -j8</code>（第一次编译耗时 2 小时，机器性能好的可以 j32 等等）<blockquote><p>Android 编译命令 <a href="http://www.cnblogs.com/ifzy/p/3854560.html" target="_blank" rel="external">make -j8 -k 2&gt;&amp;1 | tee build.log</a> 解释: 其中 make 是编译命令，-j8 这里的 8 指的是线程数量，就是开启几个线程去编译这个工程，一般会是 CPU 核心数的 2 倍, 开多的话电脑会卡死。-k 2 是标准错误，&amp;1 是标准输出，2&gt;&amp;1 意思就是将标准错误输出到标准输出中。如果没有 2&gt;&amp;1，只会有标准输出，没有错误；tee 的作用同时输出到控制台和文件，make &gt; build.log  是将所有标准输出到这个文件中，并没有定义标准错误应该是定义到了标准输出，也就是说如果 make 执行出现错误，那么就不会写到 build.log 中，而是输出到屏幕上，2&gt;&amp;1 是错误和结果都重定向到 build.log 中！可以到根目录看到 build.log。</p></blockquote></li><li>模块编译，节约时间(比方说我修改了 frameworks/base 下的某个文件直接编译这个模块就行)<ul><li><code>mmm frameworks/base</code> （单独编译某个模块）</li><li><code>make snod</code> （重新打包 Android 系统镜像文件 system.img， 这个不要忘！）<blockquote><p>编译源码等指令可以看老罗的 <a href="http://0xcc0xcd.com/p/books/978-7-121-18108-5/c161.php" target="_blank" rel="external">Android 系统源代码情景分析教程</a></p></blockquote></li></ul></li></ul><p>刷机</p><ul><li><a href="https://share.weiyun.com/aef417d93a44dce31802087732ac4d8b" target="_blank" rel="external">刷机工具下载</a><br><img src="/img/刷机工具.png" alt="4个刷机工具"></li><li>安装下载的工具</li><li>打开 SP_Flash_Tool_exe_Windows_v5.1644.00.000\flash_tool.exe<br><img src="/img/flash_tool.png" alt="flash_tool"></li></ul><p>刷机开始</p><ul><li><code>MTK 刷机</code>（KONKAS6 代码）使用 <code>Smart Phone Flash Tool</code> 工具： 注意 KONKA 手机关机即可，首先选中 <code>Scatter-loading File</code> 这行的 <code>choose</code> ，然后<code>右击计算机</code>选择<code>映射网络驱动器</code>输入 <code>\\192.168.20.220\share</code>（这个是 <code>ubuntu</code> 共享的文件夹），然后进入对于源码目录找到 <code>KONKAS6\alps\out\target\product\kon6753_66c_s6_m0\MT6753_Android_scatter.txt</code></li><li><code>原生 AOSP</code> 用 Nexus 刷机（AOSP-6.0.1_r17 代码）：注意手机关机进入 <code>fastboot</code> 界面，进入编译生成的目录下 <code>begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/out/target/product/bullhead$</code>，然后依次刷入如下命令：<ul><li>sudo fastboot flash system system.img</li><li>sudo fastboot flash recovery recovery.img</li><li>sudo fastboot flash vendor vendor.img</li><li>sudo fastboot flash cache cache.img</li><li>sudo fastboot flash userdata userdata.img</li><li>sudo fastboot reboot 最后一步，重启手机。</li></ul></li><li>刷机录像：注意，gif 最后点击 <code>download</code> 之后再用 usb 连接关机的 KONKA 手机<br><img src="/img/MTK刷机录制.gif" alt="MTK刷机录制"></li></ul><p><code>Attention</code>： /home/begoit/temp/KONKAS6/alps/packages/apps/Provision/src/com/android/provision/DefaultActivity.java (注释 onCreate 中的部分代码，略去登录注册等功能)</p><p><strong>打 Patch 包</strong>（将 A 项目的提交打 Patch 导入到 B 项目中） <code>2017-9-18 18:14:57</code> add</p><ol><li><code>git format-patch -1</code>（-1 指最近一次 Git 提交） - A 项目根目录，生成 Patch 包</li><li>将生成的 <code>0001-.patch</code> 拷贝到 B 项目根目录下</li><li><code>git am 0001-.patch</code> - B 项目根目录打入 Patch 包</li></ol><p><strong>源码代码提示的命令</strong> <code>2017-6-13 15:46:06</code> add<br>运行 <code>source build/envsetup.sh</code><br><code>mmm development/tools/idegen/</code><br><code>sh ./development/tools/idegen/idegen.sh</code> （三行全选运行），会在项目的更目录下会生成 <code>android.ipr</code>，用 <code>andorid studio</code> 打开这个文件，源码代码就有提示了!</p><p><strong>内置 apk</strong> <code>2017-6-27 11:08:49</code> add</p><ul><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/begoit 路径下将需要的 apk(TopActivity.apk) 安装包放进来</li><li>在上述路径下 Android.mk 文件中将 apk 信息加进来（这个模仿其他的内置apk）</li><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/full_kon6753_66c_s6_m0.mk 文件中增加 <code>TopActivity \</code></li><li>如果 apk 中有 so 库那么需要加别的东西，目前没有用到，可自行 google</li><li>以上操作完成之后需要重新编译项目</li></ul><p><strong>加快编译速度</strong> <code>2017-6-30 17:46:53</code> add<br><code>prebuilts/misc/linux-x86/ccache/ccache -M 50G</code> 设置 cache 缓存为 50 G</p><p>如下是编译的录屏, 临时弄个 <code>枪火</code> 先占坑，视频抽空录制（视频太大暂不录制）。<br>以下是哔哩哔哩的 html5 播放视频，参考文章：<a href="http://login926.github.io/2016/12/24/Bilibilihtml5Player/" target="_blank" rel="external">http://login926.github.io/2016/12/24/Bilibilihtml5Player/</a> </p><iframe src="https://www.bilibili.com/html/html5player.html?cid=5465980&aid=3444552" width="640" height="480" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe><!--宽占满，高度自适应。 poster 预加载显示的图像--><!--<video width="100%" height="auto" id="video" controls="" preload="none"       poster="http://media.w3.org/2010/05/sintel/poster.png">      <source id="mp4" src="http://cn-fjxm2-dx-v-03.acgvideo.com/vg1/f/84/5465980-1.mp4?expires=1494488400&platform=html5&ssig=sFyLhO5klFhNKadv0P9gtA&oi=1968780062&nfa=fkYkF/LEe5xFyJPq/bZ9eQ==&dynamic=1&hfa=2066162576" type="video/mp4">      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg"></video>--><p><strong>未完待续。。。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;source build/envsetup.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lunch&lt;/code&gt; (我的项目中选
      
    
    </summary>
    
      <category term="Android源码" scheme="https://yangxiaoge.github.io/categories/Android%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://yangxiaoge.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《Android开发艺术探索》读书笔记 (1)</title>
    <link href="https://yangxiaoge.github.io/2017/03/03/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AFnotes1/"/>
    <id>https://yangxiaoge.github.io/2017/03/03/Android开发艺术notes1/</id>
    <published>2017-03-03T13:14:14.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<center><font color="SkyBlue" size="6px"><strong>重拾课本, 温故Android开发艺术探索!</strong></font></center><p>本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。<br><a href="https://github.com/singwhatiwanna/android-art-res" target="_blank" rel="external">书中源码地址 Github</a></p><h2 id="第1章-Activity的生命周期和启动模式"><a href="#第1章-Activity的生命周期和启动模式" class="headerlink" title="第1章 Activity的生命周期和启动模式"></a>第1章 Activity的生命周期和启动模式</h2><h3 id="1-1-Activity生命周期全面分析"><a href="#1-1-Activity生命周期全面分析" class="headerlink" title="1.1 Activity生命周期全面分析"></a>1.1 Activity生命周期全面分析</h3><h4 id="1-1-1-典型情况下生命周期分析"><a href="#1-1-1-典型情况下生命周期分析" class="headerlink" title="1.1.1 典型情况下生命周期分析"></a>1.1.1 典型情况下生命周期分析</h4><ul><li>通常, <code>Activity</code>从<code>invisible</code>(即onStop)到<code>visible</code>(即onStart)时, <code>onRestart</code>方法就会被调用。</li><li>点击home键或者打开新<code>Activity</code>时, <code>onPause -&gt; onStop</code>, 如果按Home键回来回掉是: <code>onRestart -&gt;  onStart　-&gt;　onResume</code> ; 如果新<code>Activity</code>主题是透明的时, 只有<code>onPause</code>, 所以当用户返回<code>原来的Activity</code>时, 回掉过程是: <code>onRestart -&gt; onStart -&gt; onResume</code> (看<a href="/img/Activity金字塔型的生命周期图.png">Activity生命周期图</a>就知道了)。<a id="more"></a></li><li>分析生命周期图, 可知<code>onStart</code>和<code>onStop</code>对应(可见到不可见性), <code>onPause</code>和<code>onResume</code>对应(是否位于前台)。</li></ul><h4 id="1-1-2-异常生命周期分析"><a href="#1-1-2-异常生命周期分析" class="headerlink" title="1.1.2 异常生命周期分析"></a>1.1.2 异常生命周期分析</h4><ul><li>如果应用长时间处于<code>stopped</code>状态并且此时系统<code>内存极为紧张</code>的时候，系统就会回收Activity，此时系统在<code>回收之前</code>会回调<code>onSaveInstanceState</code>方法来保存应用的数据Bundle。当该Activity重新创建的时候，保存的Bundle数据就会传递到<code>onRestoreSaveInstanceState</code>方法和<code>onCreate</code>方法中，这就是onCreate方法中Bundle savedInstanceState参数的来源（onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原）。详情可以参考<a href="https://hujiaweibujidao.github.io/blog/2015/11/28/android-heroes-reading-notes-4/" target="_blank" rel="external">Android群英传_第八章 Activity和Activity调用栈分析</a></li><li>配置android:configChanges=”xxx”属性, 防止<code>Activity</code>随着<code>orientation</code>,<code>local</code>,<code>keyboardHidden</code>发生变化时重新创建。</li></ul><h3 id="1-2-Activity的启动模式"><a href="#1-2-Activity的启动模式" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h3><p>应用内的Activity是被任务栈Task来管理的，一个Task中的Activity可以来自不同的应用，同一个应用的Activity也可能不在同一个Task中。默认情况下，任务栈依据栈的后进先出原则管理Activity，但是Activity可以设置一些“特权”打破默认的规则，主要是通过在AndroidManifest文件中的属性<code>android:launchMode</code>或者通过<code>Intent的flag</code>来设置。</p><p><code>standard</code>：默认的启动模式，该模式下会生成一个新的Activity，同时将该Activity实例压入到栈中（不管该Activity是否已经存在在Task栈中，都是采用new操作）。例如： 栈中顺序是A B C D ，此时D通过Intent跳转到A，那么栈中结构就变成 A B C D A，点击返回按钮的 显示顺序是 D C B A，依次摧毁。</p><p><code>singleTop</code>：在singleTop模式下，如果当前Activity D位于栈顶，此时通过Intent跳转到它本身的Activity（即D），那么不会重新创建一个新的D实例（走onNewIntent()），所以栈中的结构依旧为A B C D，如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个activity。</p><p><code>singleTask</code>：在singleTask模式下，Task栈中只能有一个对应Activity的实例。例如：现在栈的结构为A B C D，此时D通过Intent跳转到B（走onNewIntent()），则栈的结构变成了：A B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法。通常应用于首页，首页肯定得在栈底部，也只能在栈底部。</p><p><code>singleInstance</code>：singleInstance模式下会将打开的Activity压入一个新建的任务栈中。例如：Task栈1中结构为：A B C，C通过Intent跳转到了D（D的启动模式为singleInstance），那么则会新建一个Task 栈2，栈1中结构依旧为A B C，栈2中结构为D，此时屏幕中显示D，之后D通过Intent跳转到D，栈2中不会压入新的D，所以2个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的启动模式在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C，此时点击返回按钮，还是在C，栈1的结构变为A B C，而不会回到D。</p><h3 id="1-3-Intent-Flag启动模式"><a href="#1-3-Intent-Flag启动模式" class="headerlink" title="1.3 Intent Flag启动模式"></a>1.3 Intent Flag启动模式</h3><ul><li><code>Intent.FLAG_ACTIVITY_NEW_TASK</code>：使用一个新的task来启动Activity，一般用在service中启动Activity的场景，因为service中并不存在Activity栈。 </li><li><code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>：类似<code>andoid:launchMode=&quot;singleTop&quot;</code> </li><li><code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>：类似<code>andoid:launchMode=&quot;singleTask&quot;</code></li><li><code>Intent.FLAG_ACTIVITY_NO_HISTORY</code>：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在task栈中。例如A B，在B中以这种模式启动C，C再启动D，则当前的task栈变成A B D。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;SkyBlue&quot; size=&quot;6px&quot;&gt;&lt;strong&gt;重拾课本, 温故Android开发艺术探索!&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。&lt;br&gt;&lt;a href=&quot;https://github.com/singwhatiwanna/android-art-res&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书中源码地址 Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;第1章-Activity的生命周期和启动模式&quot;&gt;&lt;a href=&quot;#第1章-Activity的生命周期和启动模式&quot; class=&quot;headerlink&quot; title=&quot;第1章 Activity的生命周期和启动模式&quot;&gt;&lt;/a&gt;第1章 Activity的生命周期和启动模式&lt;/h2&gt;&lt;h3 id=&quot;1-1-Activity生命周期全面分析&quot;&gt;&lt;a href=&quot;#1-1-Activity生命周期全面分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 Activity生命周期全面分析&quot;&gt;&lt;/a&gt;1.1 Activity生命周期全面分析&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-典型情况下生命周期分析&quot;&gt;&lt;a href=&quot;#1-1-1-典型情况下生命周期分析&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 典型情况下生命周期分析&quot;&gt;&lt;/a&gt;1.1.1 典型情况下生命周期分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通常, &lt;code&gt;Activity&lt;/code&gt;从&lt;code&gt;invisible&lt;/code&gt;(即onStop)到&lt;code&gt;visible&lt;/code&gt;(即onStart)时, &lt;code&gt;onRestart&lt;/code&gt;方法就会被调用。&lt;/li&gt;
&lt;li&gt;点击home键或者打开新&lt;code&gt;Activity&lt;/code&gt;时, &lt;code&gt;onPause -&amp;gt; onStop&lt;/code&gt;, 如果按Home键回来回掉是: &lt;code&gt;onRestart -&amp;gt;  onStart　-&amp;gt;　onResume&lt;/code&gt; ; 如果新&lt;code&gt;Activity&lt;/code&gt;主题是透明的时, 只有&lt;code&gt;onPause&lt;/code&gt;, 所以当用户返回&lt;code&gt;原来的Activity&lt;/code&gt;时, 回掉过程是: &lt;code&gt;onRestart -&amp;gt; onStart -&amp;gt; onResume&lt;/code&gt; (看&lt;a href=&quot;/img/Activity金字塔型的生命周期图.png&quot;&gt;Activity生命周期图&lt;/a&gt;就知道了)。
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="https://yangxiaoge.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://yangxiaoge.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 OkHttp 源码</title>
    <link href="https://yangxiaoge.github.io/2017/03/02/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/03/02/OkHttp源码分析/</id>
    <published>2017-03-02T15:29:20.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载 <a href="https://blog.fangjie.info/2017/03/05/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">JayFang-OkHttp源码分析</a></p></blockquote><p><code>OkHttp3</code>是<code>Square</code>出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的，还有著名的<code>Retrofit</code>也是基于OkHttp封装的。</p><h2 id="OkHttp的基本使用"><a href="#OkHttp的基本使用" class="headerlink" title="OkHttp的基本使用"></a>OkHttp的基本使用</h2><a id="more"></a><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(ENDPOINT)</div><div class="line">    .build();</div><div class="line"><span class="comment">//同步请求    </span></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="comment">//异步请求</span></div><div class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>最基本的用法就是先创建一个OkHttpClient，然后build出一个Requset对象，最后发送请求，可以是同步请求，也可以是异步请求。使用起来很简单，但背后是怎么实现的，下面从源码层面来分析下。</p><h2 id="OkHttp-调用流程"><a href="#OkHttp-调用流程" class="headerlink" title="OkHttp 调用流程"></a>OkHttp 调用流程</h2><p>OkHttp内部调用流程图<br><img src="/img/okhttp/1.jpg" alt=""></p><h3 id="第一步-new-OkHttpClient-Builder"><a href="#第一步-new-OkHttpClient-Builder" class="headerlink" title="第一步: new OkHttpClient(Builder)"></a>第一步: new OkHttpClient(Builder)</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OkHttpClient.java</span></div><div class="line"><span class="keyword">public</span> OkHttpClient() &#123;</div><div class="line">    <span class="keyword">this</span>(new Builder());</div><div class="line">&#125;</div><div class="line">OkHttpClient(Builder builder) &#123;</div><div class="line">    <span class="keyword">this</span>.dispatcher = builder.dispatcher;</div><div class="line">    <span class="keyword">this</span>.proxy = builder.proxy;</div><div class="line">    <span class="keyword">this</span>.protocols = builder.protocols;</div><div class="line">    <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</div><div class="line">    <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);</div><div class="line">    <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);</div><div class="line">    ......</div><div class="line">    <span class="keyword">this</span>.readTimeout = builder.readTimeout;</div><div class="line">    <span class="keyword">this</span>.writeTimeout = builder.writeTimeout;</div><div class="line">    <span class="keyword">this</span>.pingInterval = builder.pingInterval;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里创建了一个默认的OkHttpCient.Builder，用于配置各种参数。</p><h3 id="第二步-okhttpclient-newCall-request"><a href="#第二步-okhttpclient-newCall-request" class="headerlink" title="第二步:okhttpclient.newCall(request)"></a>第二步:okhttpclient.newCall(request)</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OkHttpClient.java</span></div><div class="line">@Override </div><div class="line"><span class="keyword">public</span> Call newCall(Request request) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//RealCall.java</span></div><div class="line">RealCall(OkHttpClient <span class="keyword">client</span>, Request originalRequest, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">client</span> = <span class="keyword">client</span>;</div><div class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(<span class="keyword">client</span>, forWebSocket);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里用request对象创建了一个RealCall对象，把一些参数传到RealCall。</p><h3 id="第三步-execute-or-enqueue"><a href="#第三步-execute-or-enqueue" class="headerlink" title="第三步:execute() or enqueue()"></a>第三步:execute() or enqueue()</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RealCall.java</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="keyword">public</span> <span class="function">Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">  executed = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">captureCallStackTrace();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">  <span class="comment">//核心的函数</span></div><div class="line">  Response result = getResponseWithInterceptorChain();</div><div class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同步请求，很直接就调用到了最核心的函数getResponseWithInterceptorChain()。再看下异步请求。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RealCall.java</span></div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">      executed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    captureCallStackTrace();</div><div class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>而异步请求，将用户接口的responseCallback对象封装成一个AsyncCall对象提交给Dispather来处理，这里的AsyncCall是RealCall的一个内部类。再看下这个Dispather怎么处理这个AsyncCall的。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Dispatcher.java</span></div><div class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> enqueue(AsyncCall <span class="keyword">call</span>) &#123;</div><div class="line"><span class="keyword">if</span> (runningAsyncCalls.<span class="keyword">size</span>() &lt; maxRequests &amp;&amp; runningCallsForHost(<span class="keyword">call</span>) &lt; maxRequestsPerHost) &#123;</div><div class="line">  runningAsyncCalls.add(<span class="keyword">call</span>);</div><div class="line">  executorService().execute(<span class="keyword">call</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  readyAsyncCalls.add(<span class="keyword">call</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Dispather管理了一些请求队列，如果正在执行的异步请求没有达到上限，就直接将这个请求提交给线程池，否则加入到等待队列中。而且这里直接把AsyncCall的对象给了线程池，其实这个AsyncCall就是一个Runnable的实现类。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RealCall.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Callback</span> responseCallback;</div><div class="line"></div><div class="line">    <span class="type">AsyncCall</span>(<span class="type">Callback</span> responseCallback) &#123;</div><div class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</div><div class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="keyword">protected</span> void execute() &#123;</div><div class="line">      boolean signalledCallback = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="type">Response</span> response = getResponseWithInterceptorChain();</div><div class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">          signalledCallback = <span class="literal">true</span>;</div><div class="line">          responseCallback.onFailure(<span class="type">RealCall</span>.<span class="keyword">this</span>, <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Canceled"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          signalledCallback = <span class="literal">true</span>;</div><div class="line">          responseCallback.onResponse(<span class="type">RealCall</span>.<span class="keyword">this</span>, response);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</div><div class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">          <span class="comment">// Do not signal the callback twice!</span></div><div class="line">          <span class="type">Platform</span>.get().log(<span class="type">INFO</span>, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          responseCallback.onFailure(<span class="type">RealCall</span>.<span class="keyword">this</span>, e);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p><code>AsyncCall</code>父类的<code>run()</code>方法会调用抽象方法<code>execute()</code>，也就是将在Dispather里的线程池执行AsyncCall对象的时候，就会执行到<code>execute()</code>，在这个方法里同样调用了核心的网络请求方法<code>getResponseWithInterceptorChain()</code>。<br>而且在<code>execute()</code>里会回调用户接口<code>responseCallback</code>的回调方法。注意:这里的回调是在非主线程直接回调的，也就是在Android里使用的话要注意这里面不能直接更新UI操作。<br>至此，同步请求和异步请求最终都是调用的<code>getResponseWithInterceptorChain()</code>;来发送网络请求，只是异步请求涉及到一些线程池操作，包括请求的队列管理、调度。</p><h3 id="第四步-getResponseWithInterceptorChain"><a href="#第四步-getResponseWithInterceptorChain" class="headerlink" title="第四步:getResponseWithInterceptorChain()"></a>第四步:getResponseWithInterceptorChain()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RealCall.java</span></div><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span>(<span class="params"></span>) throws IOException </span>&#123;</div><div class="line"><span class="comment">// Build a full stack of interceptors.</span></div><div class="line">List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">interceptors.addAll(client.interceptors());</div><div class="line">interceptors.<span class="keyword">add</span>(retryAndFollowUpInterceptor);</div><div class="line">interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line"><span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">  interceptors.addAll(client.networkInterceptors());</div><div class="line">&#125;</div><div class="line">interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">    interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line"><span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个方法里就是添加了一些拦截器，然后启动一个拦截器调用链，拦截器递归调用之后最后返回请求的响应Response。这里的拦截器分层的思想就是借鉴的网络里的分层模型的思想。请求从最上面一层到最下一层，响应从最下一层到最上一层，每一层只负责自己的任务，对请求或响应做自己负责的那块的修改。</p><p><code>Q1</code>: 这里为什么每次都重新创建<code>RealInterceptorChain</code>对象，为什么不直接复用上一层的<code>RealInterceptorChain</code>对象？(文末给出答案)</p><h2 id="OkHttp拦截器分层结构"><a href="#OkHttp拦截器分层结构" class="headerlink" title="OkHttp拦截器分层结构"></a>OkHttp拦截器分层结构</h2><p><img src="/img/okhttp/2.jpg" alt=""><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RealInterceptorChain.java</span></div><div class="line"><span class="keyword">public</span> Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</div><div class="line">  Connection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line"><span class="keyword">if</span> (index &gt;= interceptors.<span class="keyword">size</span>()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">calls++;</div><div class="line">......</div><div class="line">RealInterceptorChain <span class="keyword">next</span> = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">    interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">Interceptor interceptor = interceptors.get(index);</div><div class="line">Response response = interceptor.intercept(<span class="keyword">next</span>);</div><div class="line">...</div><div class="line"><span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>RealInterceptorChain的<code>proceed()</code>，每次重新创建一个<code>RealInterceptorChain</code>对象，然后调用下一层的拦截器的<code>interceptor.intercept()</code>方法。<br>每一个拦截器的<code>intercept()</code>方法都是这样的模型<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="keyword">public</span> <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line">    <span class="comment">// 1、该拦截器在Request阶段负责的事情</span></div><div class="line"></div><div class="line">    <span class="comment">// 2、调用RealInterceptorChain.proceed()，其实是递归调用下一层拦截器的intercept方法</span></div><div class="line">    response = ((RealInterceptorChain) chain).<span class="keyword">proceed</span>(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">//3、该拦截器在Response阶段负责的事情，然后返回到上一层拦截器的 response阶段</span></div><div class="line">    <span class="keyword">return</span>  response;     </div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>这差不多就是OkHttp的分层拦截器模型，借鉴了网络里的OSI七层模型的思想。最底层是CallServerInterceptor，类比网络里的物理层。OkHttp还支持用户自定义拦截器，插入到最顶层和CallServerInterceptor上一层的位置。比如官方写了一个Logging Interceptor，用于打印网络请求日志的拦截器。</p><h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Request userRequest = chain.request();</div><div class="line">Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line"><span class="comment">// Request阶段</span></div><div class="line">RequestBody body = userRequest.body();</div><div class="line"><span class="keyword">if</span> (body != <span class="built_in">null</span>) &#123;</div><div class="line">  MediaType contentType = body.contentType();</div><div class="line">    <span class="params">...</span><span class="params">...</span></div><div class="line">  long contentLength = body.contentLength();</div><div class="line">  <span class="keyword">if</span> (contentLength != <span class="number">-1</span>) &#123;</div><div class="line">    requestBuilder.<span class="keyword">header</span>(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</div><div class="line">    requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    requestBuilder.<span class="keyword">header</span>(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</div><div class="line">    requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (userRequest.<span class="keyword">header</span>(<span class="string">"Connection"</span>) == <span class="built_in">null</span>) &#123;</div><div class="line">  requestBuilder.<span class="keyword">header</span>(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">    <span class="params">...</span>..</div><div class="line">Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line"><span class="comment">// Response阶段</span></div><div class="line">    <span class="params">...</span>..</div><div class="line"><span class="keyword">if</span> (transparentGzip</div><div class="line">    &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.<span class="keyword">header</span>(<span class="string">"Content-Encoding"</span>))</div><div class="line">    &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</div><div class="line">  GzipSource responseBody = <span class="literal">new</span> GzipSource(networkResponse.body().source());</div><div class="line">  Headers strippedHeaders = networkResponse.headers().newBuilder()</div><div class="line">      .removeAll(<span class="string">"Content-Encoding"</span>)</div><div class="line">      .removeAll(<span class="string">"Content-Length"</span>)</div><div class="line">      .build();</div><div class="line">  responseBuilder.headers(strippedHeaders);</div><div class="line">  responseBuilder.body(<span class="literal">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>BridgeInterceptor拦截器在Request阶段，将用户的配置信息，重新创建Request.Builder对象，重新build出Request对象，并添加一些请求头，比如:host，content-length，keep-alive等。<br>BridgeInterceptor在Response阶段做gzip解压操作。</p><h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>CacheInterceptor拦截器在Request阶段判断该请求是否有缓存，是否需要重新请求，如果不需要重新请求，直接从缓存里取出内容，封装一个Response返回，不需要再调用下一层。<br>CacheInterceptor拦截器在Response阶段，就是把下面一层的Response做缓存。</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//ConnectInterceptor.java</div><div class="line">RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">Request request = realChain.request();</div><div class="line">StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">// We need the network to satisfy this request. Possibly for validating a conditional GET.</div><div class="line">boolean doExtensiveHealthChecks = !request.method().equals(<span class="string">"<span class="keyword">GET</span>"</span>);</div><div class="line">HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">RealConnection connection = streamAllocation.connection();</div><div class="line">return realChain.proceed(request, streamAllocation, httpCodec, connection);</div></pre></td></tr></table></figure><p>ConnectInterceptor拦截器只在Request阶段建立连接，Response阶段直接把下一层的Response返回给上一层。再看下建立连接的过程。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> HttpCodec <span class="keyword">new</span><span class="type">Stream</span>(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</div><div class="line">....</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</div><div class="line">      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</div><div class="line">  HttpCodec resultCodec = resultConnection.<span class="keyword">new</span><span class="type">Codec</span>(client, <span class="built_in">this</span>);</div><div class="line">......</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RouteException</span>(e);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>findHealthyConnection()函数寻找一条健康的网络连接，其内部主要调用了findConnection()。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> RealConnection findConnection(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</div><div class="line">  <span class="keyword">boolean</span> connectionRetryEnabled) <span class="keyword">throws</span> IOException &#123;</div><div class="line">Route selectedRoute;</div><div class="line"><span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line"> .....</div><div class="line">  <span class="comment">// Attempt to get a connection from the pool.</span></div><div class="line">  Internal.instance.get(connectionPool, address, <span class="keyword">this</span>);</div><div class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> connection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  selectedRoute = route;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// If we need a route, make one. This is a blocking operation.</span></div><div class="line"><span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</div><div class="line">  selectedRoute = routeSelector.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible for</span></div><div class="line"><span class="comment">// an asynchronous cancel() to interrupt the handshake we're about to do.</span></div><div class="line">RealConnection result;</div><div class="line"><span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">  route = selectedRoute;</div><div class="line">  refusedStreamCount = <span class="number">0</span>;</div><div class="line">  result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</div><div class="line">  acquire(result);</div><div class="line">  <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></div><div class="line">result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</div><div class="line">routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">Socket socket = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">  <span class="comment">// Pool the connection.</span></div><div class="line">  Internal.instance.put(connectionPool, result);</div><div class="line"> .....</div><div class="line">&#125;</div><div class="line">closeQuietly(socket);</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里面大概就是从连接池里去找已有的网络连接，如果有，则复用，减少三次握手；没有的话，则创建一个RealConnection对象，三次握手，建立连接，然后将连接放到连接池。具体的内部connect过程，就不深入了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>ConnectionPool</code>最多支持保持5个地址的连接keep-alive，每个keep-alive 5分钟，并有异步线程循环清理无效的连接。</p><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Override </div><div class="line"><span class="keyword">public</span> <span class="built_in">Response</span> intercept(Chain chain) throws IOException &#123;</div><div class="line">...</div><div class="line">httpCodec.writeRequestHeaders(<span class="built_in">request</span>);</div><div class="line"><span class="built_in">Response</span>.Builder responseBuilder = <span class="literal">null</span>;</div><div class="line"><span class="keyword">if</span> (HttpMethod.permitsRequestBody(<span class="built_in">request</span>.method()) &amp;&amp; <span class="built_in">request</span>.body() != <span class="literal">null</span>) &#123;</div><div class="line">  ......</div><div class="line">  <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</div><div class="line">    Sink requestBodyOut = httpCodec.createRequestBody(<span class="built_in">request</span>, <span class="built_in">request</span>.body().contentLength());</div><div class="line">    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">    <span class="built_in">request</span>.body().writeTo(bufferedRequestBody);</div><div class="line">    bufferedRequestBody.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">httpCodec.finishRequest();</div><div class="line"><span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</div><div class="line">  responseBuilder = httpCodec.readResponseHeaders(<span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">Response</span> <span class="built_in">response</span> = responseBuilder</div><div class="line">    .<span class="built_in">request</span>(<span class="built_in">request</span>)</div><div class="line">    .handshake(streamAllocation.connection().handshake())</div><div class="line">    .sentRequestAtMillis(sentRequestMillis)</div><div class="line">    .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="built_in">int</span> code = <span class="built_in">response</span>.code();</div><div class="line">.....</div><div class="line">return <span class="built_in">response</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CallServerInterceptor 精简出来的代码就是writeRequestHeaders()，flushRequest()，finishRequest()，发送请求，然后readResponseHeaders，openResponseBody读取response。<br>CallServerInterceptor底层的IO流读写依赖于Square自家的Okio项目，HttpCodec是封装的IO编码和解码的实现。</p><p>至此，OkHttp中几个核心的拦截器就到此为止了，OkHttp最精髓的部分也就体现在这个拦截器上。最后补充几个关于OkHttp的面试问题。</p><ul><li>OkHttp是如何做链路复用？</li><li>OkHttp的Intereptor能不能取消一个request？<br>这两个问题在分析源码之后应该很容易回答了。</li></ul><p>回答上面留的一个问题:<br>每次重新创建一个<code>RealInterceptorChain</code>对象，因为这里是递归调用，在调用下一层拦截器的interupter()方法的时候，本层的 response阶段还没有执行完成，如果复用<code>RealInterceptorChain</code>对象，必然导致下一层修改<code>RealInterceptorChain</code>，所以需要重新创建<code>RealInterceptorChain</code>对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载 &lt;a href=&quot;https://blog.fangjie.info/2017/03/05/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JayFang-OkHttp源码分析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;OkHttp3&lt;/code&gt;是&lt;code&gt;Square&lt;/code&gt;出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的，还有著名的&lt;code&gt;Retrofit&lt;/code&gt;也是基于OkHttp封装的。&lt;/p&gt;
&lt;h2 id=&quot;OkHttp的基本使用&quot;&gt;&lt;a href=&quot;#OkHttp的基本使用&quot; class=&quot;headerlink&quot; title=&quot;OkHttp的基本使用&quot;&gt;&lt;/a&gt;OkHttp的基本使用&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="OkHttp" scheme="https://yangxiaoge.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Java与Android知识点</title>
    <link href="https://yangxiaoge.github.io/2017/02/28/Java%E4%B8%8EAndroid%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yangxiaoge.github.io/2017/02/28/Java与Android知识点/</id>
    <published>2017-02-28T09:13:42.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<center><font color="SkyBlue" size="6px"><strong>持续更行中</strong></font></center><h2 id="1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h2><p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。<br><code>String str = new String(“hello”);</code><br>上面的语句中 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p><h2 id="2-重写equals方法时-为什么也需要重写hashCode方法。"><a href="#2-重写equals方法时-为什么也需要重写hashCode方法。" class="headerlink" title="2. 重写equals方法时,为什么也需要重写hashCode方法。"></a>2. 重写equals方法时,为什么也需要重写hashCode方法。</h2><a id="more"></a><ul><li><p>1、重写equals方法时需要重写hashCode方法，主要是针对Map、Set等集合类型的使用；</p><ul><li><p>a: Map、Set等集合类型存放的对象必须是唯一的；</p></li><li><p>b: 集合类判断两个对象是否相等，是先判断equals是否相等，如果equals返回TRUE，还要再判断HashCode返回值是否ture,只有两者都返回ture,才认为该两个对象是相等的。</p></li></ul></li><li><p>2、由于Object的hashCode返回的是对象的hash值，所以即使equals返回TRUE，集合也可能判定两个对象不等，所以必须重写hashCode方法，以保证当equals返回TRUE时，hashCode也返回Ture，这样才能使得集合中存放的对象唯一。</p></li></ul><h2 id="3-Android-中的Dalvik和ART是什么，有啥区别？"><a href="#3-Android-中的Dalvik和ART是什么，有啥区别？" class="headerlink" title="3. Android 中的Dalvik和ART是什么，有啥区别？"></a>3. <a href="http://www.jianshu.com/p/58f817d176b7" target="_blank" rel="external">Android 中的Dalvik和ART是什么，有啥区别？</a></h2><p>答: 在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率。在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p><h2 id="4-Glide-Picasso原理"><a href="#4-Glide-Picasso原理" class="headerlink" title="4. Glide, Picasso原理?"></a>4. Glide, Picasso原理?</h2><h2 id="5-事件传递机制-参考郭霖事件分发博客"><a href="#5-事件传递机制-参考郭霖事件分发博客" class="headerlink" title="5. 事件传递机制?(参考郭霖事件分发博客)"></a>5. 事件传递机制?(参考<a href="http://blog.csdn.net/guolin_blog/article/details/9097463/" target="_blank" rel="external">郭霖事件分发博客</a>)</h2><h2 id="6-Okhttp原理解析-优点"><a href="#6-Okhttp原理解析-优点" class="headerlink" title="6. Okhttp原理解析,优点"></a>6. <a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">Okhttp原理解析,优点</a></h2><p>答: 总结: <code>OkHttpClient</code> 实现 <code>Call.Factory</code>，负责为 <code>Request</code> 创建 <code>Call</code>；<br><code>RealCall</code> 为具体的 <code>Call</code> 实现，其 <code>enqueue()</code> 异步接口通过 <code>Dispatcher</code> 利用 <code>ExecutorService</code> 实现，而最终进行网络请求时和同步 <code>execute()</code> 接口一致，都是通过 <code>getResponseWithInterceptorChain()</code> 函数实现；<br><code>getResponseWithInterceptorChain()</code> 中利用 <code>Interceptor</code> 链条，分层实现缓存、透明压缩、网络 IO 等功能；</p><h2 id="7-内存泄漏全解析"><a href="#7-内存泄漏全解析" class="headerlink" title="7. 内存泄漏全解析"></a>7. <a href="http://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650238704&amp;idx=1&amp;sn=ad334840afdc2d9bdb8215e9f942e54e&amp;scene=0#wechat_redirect" target="_blank" rel="external">内存泄漏全解析</a></h2><h2 id="8-热修复有所了解"><a href="#8-热修复有所了解" class="headerlink" title="8. 热修复有所了解?"></a>8. <a href="http://mp.weixin.qq.com/s/GuzbU1M1LY1VKmN7PyVbHQ" target="_blank" rel="external">热修复有所了解?</a></h2><h2 id="9-路由了解吗-routerSDK"><a href="#9-路由了解吗-routerSDK" class="headerlink" title="9. 路由了解吗?routerSDK"></a>9. 路由了解吗?<a href="https://github.com/Jomes/routerSDK" target="_blank" rel="external">routerSDK</a></h2><h2 id="10-foreach原理"><a href="#10-foreach原理" class="headerlink" title="10. foreach原理"></a>10. <a href="http://blog.csdn.net/cq1982/article/details/49121879" target="_blank" rel="external">foreach原理</a></h2><p>答: foreach语法最终被编译器转为了对Iterator.next()的调用。而作为使用者的我们，jdk并没用向我们暴露这些细节，我们甚至不需要知道Iterator的存在，认识到jdk的强大之处了吧。</p><h2 id="11-EventBus-源码解析"><a href="#11-EventBus-源码解析" class="headerlink" title="11. EventBus 源码解析"></a>11. <a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">EventBus 源码解析</a></h2><p>答: <a href="http://www.jianshu.com/p/e41e580eff10" target="_blank" rel="external">总结:</a> 底层也是回掉实现。优点：EventBus是很好地替代了回调的功能，松耦合，使用简单。缺点：只要用得一多，那消息类的数量必然是会爆炸性增长，调试的时候除非熟悉整块逻辑，不然不跑起来你是没办法了解Subscribe的方法的数据来源。</p><h2 id="12-Android进程保活的套路-文中源码"><a href="#12-Android进程保活的套路-文中源码" class="headerlink" title="12. Android进程保活的套路 - 文中源码"></a>12. <a href="http://www.jianshu.com/p/1da4541b70ad" target="_blank" rel="external">Android进程保活的套路</a> - <a href="https://github.com/herojing/KeepProcessLive" target="_blank" rel="external">文中源码</a></h2><p>答: 1,开启一个像素的Activity(手Q) 2,前台服务 3,相互唤醒 4,JobSheduler 5,粘性服务&amp;与系统服务捆绑<br><a href="http://www.jianshu.com/p/89f19d67b348" target="_blank" rel="external">常被问的问题- Android 进程不死从3个层面入手</a>, <a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577617&amp;idx=1&amp;sn=623256a2ff94641036a6c9eea17baab8&amp;scene=0#wechat_redirect" target="_blank" rel="external">腾讯Bugly保活文章</a></p><h2 id="13-ButterKnife工作流程"><a href="#13-ButterKnife工作流程" class="headerlink" title="13. ButterKnife工作流程"></a>13. <a href="http://bxbxbai.github.io/2016/03/12/how-butterknife-works/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">ButterKnife工作流程</a></h2><p>答:当你编译你的Android工程时，ButterKnife工程中 ButterKnifeProcessor 类的 process() 方法会执行以下操作：</p><ul><li>开始它会扫描Java代码中所有的ButterKnife注解 @Bind 、 @OnClick 、 @OnItemClicked 等</li><li>当它发现一个类中含有任何一个注解时， ButterKnifeProcessor 会帮你生成一个Java类，名字类似 <classname>$$ViewBinder ，这个新生成的类实现了 ViewBinder<t> 接口</t></classname></li><li>这个 ViewBinder 类中包含了所有对应的代码，比如 @Bind 注解对应 findViewById() , @OnClick 对应了 view.setOnClickListener() 等等</li><li>最后当Activity启动 ButterKnife.bind(this) 执行时，ButterKnife会去加载对应的 ViewBinder 类调用它们的 bind() 方法</li></ul><h2 id="14-RxJava-amp-Retrofit结合的最佳实践-封装的思想值得学习-Retrofit"><a href="#14-RxJava-amp-Retrofit结合的最佳实践-封装的思想值得学习-Retrofit" class="headerlink" title="14. RxJava &amp; Retrofit结合的最佳实践- 封装的思想值得学习!!!, Retrofit"></a>14. <a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="external">RxJava &amp; Retrofit结合的最佳实践- 封装的思想值得学习!!!</a>, <a href="http://bxbxbai.github.io/2015/12/13/retrofit2/" target="_blank" rel="external">Retrofit</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;SkyBlue&quot; size=&quot;6px&quot;&gt;&lt;strong&gt;持续更行中&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;

&lt;h2 id=&quot;1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。&quot;&gt;&lt;a href=&quot;#1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。&quot; class=&quot;headerlink&quot; title=&quot;1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。&quot;&gt;&lt;/a&gt;1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。&lt;/h2&gt;&lt;p&gt;答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。&lt;br&gt;&lt;code&gt;String str = new String(“hello”);&lt;/code&gt;&lt;br&gt;上面的语句中 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。&lt;/p&gt;
&lt;h2 id=&quot;2-重写equals方法时-为什么也需要重写hashCode方法。&quot;&gt;&lt;a href=&quot;#2-重写equals方法时-为什么也需要重写hashCode方法。&quot; class=&quot;headerlink&quot; title=&quot;2. 重写equals方法时,为什么也需要重写hashCode方法。&quot;&gt;&lt;/a&gt;2. 重写equals方法时,为什么也需要重写hashCode方法。&lt;/h2&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yangxiaoge.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Java" scheme="https://yangxiaoge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Eshop-RN 成功运行爬坑记录</title>
    <link href="https://yangxiaoge.github.io/2017/02/09/Eshop-RN-%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://yangxiaoge.github.io/2017/02/09/Eshop-RN-成功运行爬坑记录/</id>
    <published>2017-02-09T15:21:42.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先上图片"><a href="#先上图片" class="headerlink" title="先上图片"></a>先上图片</h2><p><img src="/img/Eshop成功运行.png" alt="终端及代码图"><br><a id="more"></a><br><img src="/img/eshop-nexus5X截图.png" alt="Nexus 5X真机图"></p><h2 id="问题总结-持续更新ing"><a href="#问题总结-持续更新ing" class="headerlink" title="问题总结(持续更新ing)"></a>问题总结(持续更新ing)</h2><ul><li><code>npm install</code> 要保证网络畅通</li><li><a href="https://nodejs.org/en/" target="_blank" rel="external"><code>node</code></a>版本尽量用官方<a href="https://nodejs.org/en/" target="_blank" rel="external">推荐版本</a>, 或者低版本(之前由于我用了v7.4.0版本,导致运行报错等各种奇葩问题。 降级到v6.9.5之后就解决了)</li><li>Git拉去新工程之后最好先删除<code>node_modules</code>,再运行<code>npm install</code></li><li>more</li></ul><h2 id="附上RN学习思维导图"><a href="#附上RN学习思维导图" class="headerlink" title="附上RN学习思维导图"></a>附上RN学习思维导图</h2><p><img src="/img/RN学习指南.png" alt="RN学习指南"></p><h2 id="RN组件可用属性整理"><a href="#RN组件可用属性整理" class="headerlink" title="RN组件可用属性整理"></a>RN组件可用属性整理</h2><p>图片来源 <a href="http://www.jianshu.com/p/fa0874be0827" target="_blank" rel="external">给所有开发者的React Native详细入门指南（第一阶段）</a>文中Demo地址 <a href="https://github.com/MarnoDev/HelloRN/blob/master/RN%E7%BB%84%E4%BB%B6%E5%8F%AF%E7%94%A8%E5%B1%9E%E6%80%A7%E6%95%B4%E7%90%86.xlsx" target="_blank" rel="external">RN组件可用属性整理.xlsx</a><br><img src="/img/RN组件可用属性整理.png" alt="Nexus 5X真机图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先上图片&quot;&gt;&lt;a href=&quot;#先上图片&quot; class=&quot;headerlink&quot; title=&quot;先上图片&quot;&gt;&lt;/a&gt;先上图片&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/Eshop成功运行.png&quot; alt=&quot;终端及代码图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://yangxiaoge.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://yangxiaoge.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结</title>
    <link href="https://yangxiaoge.github.io/2016/12/30/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://yangxiaoge.github.io/2016/12/30/2016年终总结/</id>
    <published>2016-12-30T11:12:34.000Z</published>
    <updated>2017-09-20T09:55:11.016Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~</p><p>掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活，但是相比之下我还是喜欢踏实的工作，花着自己辛苦挣来的工资，很开心！</p><p>下面说说毕业后在<code>软创</code>学到的东西吧, 软创是我毕业来的第一家公司,主要学习的知识点方向有两个: Android, Birt(报表,涉及数据库的CRUD知识点)。</p><p>概括一下Android的学习，毕竟这是我个人爱好的！（当然，今年IT也面临了<code>寒冬</code>，不过也不用恐慌，做好自己！！！）<br><a id="more"></a><br>在2016年里完成的项目：</p><ul><li>1、<a href="https://play.google.com/store/apps/details?id=com.ztesoft.zsmart.datamall.app.ghana" target="_blank" rel="external">My Busy 4G</a>  </li><li>2、<a href="https://play.google.com/store/apps/details?id=mm.com.mptvas" target="_blank" rel="external">MPT 4U</a></li></ul><p>经历过第一个公司级别的项目<code>My Busy 4G</code>之后，最大收获就是：个人水平能力得到了很大的提升，尤其是同事们都很热心！还有一个收获就是：学习方法！<br><code>举个栗子</code>：新下来一个需求，首先要考虑的是项目中是否有可以复用的业务模块，组件等等（模块化开发的重要性！），其次就是要利用好搜索引擎（Google），Github，Stack Overflow，CSDN等。<br>当然有时候我还需要自己造轮子（心平气和，不浮躁，孰能生巧）。在软创这一年里我的技术可以说是飞速提升，受益良多！</p><p>在这一年里，我很庆幸，我养成了一个习惯：每天早上在公司班车上都要阅读几篇公众号的文章，然后看看新闻。</p><p>感谢有几位交心好友，祝前程似锦，愿友谊长存！</p><p>最后，祝我的家人，亲朋在新的一年身体健康，工作顺利，鸡年大吉~</p><p>2017 Fighting！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~&lt;/p&gt;
&lt;p&gt;掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活，但是相比之下我还是喜欢踏实的工作，花着自己辛苦挣来的工资，很开心！&lt;/p&gt;
&lt;p&gt;下面说说毕业后在&lt;code&gt;软创&lt;/code&gt;学到的东西吧, 软创是我毕业来的第一家公司,主要学习的知识点方向有两个: Android, Birt(报表,涉及数据库的CRUD知识点)。&lt;/p&gt;
&lt;p&gt;概括一下Android的学习，毕竟这是我个人爱好的！（当然，今年IT也面临了&lt;code&gt;寒冬&lt;/code&gt;，不过也不用恐慌，做好自己！！！）&lt;br&gt;
    
    </summary>
    
      <category term="个人总结" scheme="https://yangxiaoge.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="https://yangxiaoge.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://yangxiaoge.github.io/2016/12/29/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangxiaoge.github.io/2016/12/29/JavaScript学习笔记/</id>
    <published>2016-12-29T09:34:01.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="廖雪峰-js教程"><a href="#廖雪峰-js教程" class="headerlink" title="廖雪峰 js教程"></a>廖雪峰 js教程</h1><blockquote><p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000" target="_blank" rel="external">JavaScript教程</a></p></blockquote><p>我的练习基本是按着教程敲了一遍.  用的Chrome调试窗口,很方便!</p><p><strong>以下是笔记</strong></p><h2 id="javascript的五种基本数据类型"><a href="#javascript的五种基本数据类型" class="headerlink" title="javascript的五种基本数据类型"></a>javascript的五种基本数据类型</h2><p>基本数据类型: Undefined，Null，Boolean，Number和String; 此外还含有一种复杂数据类型—Object<br><a id="more"></a></p><h2 id="if判断-传参传的非boolean类型"><a href="#if判断-传参传的非boolean类型" class="headerlink" title="if判断,传参传的非boolean类型"></a>if判断,传参传的非boolean类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'123'</span>;</div><div class="line"><span class="keyword">if</span> (s.length) &#123; <span class="comment">// 条件计算结果为3</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"你好啊"</span>); <span class="comment">//打印结果为你好啊</span></div><div class="line">&#125;</div><div class="line">原因: JavaScript把<span class="literal">null</span>、<span class="literal">undefined</span>、<span class="number">0</span>、<span class="literal">NaN</span>和空字符串<span class="string">''</span>视为<span class="literal">false</span>，其他值一概视为<span class="literal">true</span>，因此上述代码条件判断的结果是<span class="literal">true</span>。</div></pre></td></tr></table></figure><h2 id="Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。"><a href="#Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。" class="headerlink" title="Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。"></a>Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Map([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Adam'</span>, <span class="number">85</span>]]);</div><div class="line">m.<span class="keyword">get</span>(<span class="string">'Michael'</span>); <span class="comment">// 95</span></div><div class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Set();</div><div class="line">s.<span class="keyword">add</span>(<span class="number">1</span>); <span class="comment">// Set &#123;1&#125;</span></div><div class="line">s.<span class="keyword">add</span>(<span class="number">2</span>); <span class="comment">// Set &#123;1, 2&#125;</span></div><div class="line">s.<span class="keyword">add</span>(<span class="number">3</span>); <span class="comment">// Set &#123;1, 2,3&#125;</span></div><div class="line">s.delete(<span class="number">3</span>); <span class="comment">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure><h2 id="ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。"><a href="#ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。" class="headerlink" title="ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。"></a>ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：</span></div><div class="line"><span class="comment">//forEach()方法是ES5.1标准引入的</span></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(element, index, array)</span> </span>&#123;</div><div class="line">    <span class="comment">// element: 指向当前元素的值</span></div><div class="line">    <span class="comment">// index: 指向当前索引</span></div><div class="line">    <span class="comment">// array: 指向Array对象本身</span></div><div class="line">    alert(element);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">或者:</div><div class="line"><span class="comment">//由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：</span></div><div class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">a.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;</div><div class="line">    alert(element);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array："><a href="#JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：" class="headerlink" title="JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array："></a>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">arguments</span>，你可以获得调用者传入的所有参数</div><div class="line">实际上<span class="built_in">arguments</span>最常用于判断传入参数的个数。你可能会看到这样的写法：</div><div class="line"><span class="comment">// foo(a[, b], c)</span></div><div class="line"><span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">        <span class="comment">// 实际拿到的参数是a和b，c为undefined</span></div><div class="line">        c = b; <span class="comment">// 把b赋给c</span></div><div class="line">        b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">要把中间的参数b变为“可选”参数，就只能通过<span class="built_in">arguments</span>判断，然后重新调整参数并赋值。</div></pre></td></tr></table></figure><h2 id="高阶函数-高阶函数英文叫Higher-order-function"><a href="#高阶函数-高阶函数英文叫Higher-order-function" class="headerlink" title="高阶函数, 高阶函数英文叫Higher-order function"></a>高阶函数, 高阶函数英文叫Higher-order function</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function string2int(s) &#123;</div><div class="line">    return s.split(&apos;&apos;).map(strNum =&gt; strNum * 1).reduce((x, y) =&gt; x * 10 + y)</div><div class="line">&#125;</div><div class="line">string2int(&apos;12345&apos;)</div></pre></td></tr></table></figure><h2 id="细细理解-map-reduce-filter-的区别"><a href="#细细理解-map-reduce-filter-的区别" class="headerlink" title="细细理解 map(), reduce(), filter()的区别"></a>细细理解 map(), reduce(), filter()的区别</h2><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">如果不知道<span class="built_in">sort</span>()方法的默认排序规则，直接对数字排序，绝对栽进坑里！</div><div class="line">幸运的是，<span class="built_in">sort</span>()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</div><div class="line">var arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.<span class="built_in">sort</span>(<span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">20</span>]</div><div class="line"></div><div class="line">var arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</div><div class="line">arr.<span class="built_in">sort</span>(<span class="function"><span class="keyword">function</span> <span class="params">(s1, s2)</span></span> &#123;</div><div class="line">    x1 = s1.toUpperCase();</div><div class="line">    x2 = s2.toUpperCase();</div><div class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (x1 &gt; x2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); // [<span class="string">'apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>]</div><div class="line"></div><div class="line">最后友情提示，<span class="built_in">sort</span>()方法会直接对Array进行修改，它返回的结果仍是当前Array：</div></pre></td></tr></table></figure><h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(arr)</span> &#123;</span></div><div class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> &#123;</span></div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="built_in">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 15</span></div><div class="line"></div><div class="line">如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span><span class="params">(arr)</span> &#123;</span></div><div class="line">    var <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></div><div class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> &#123;</span></div><div class="line">            <span class="keyword">return</span> x + y;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</div><div class="line">var f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></div><div class="line">调用函数f时，才真正计算求和的结果：</div><div class="line">f(); <span class="comment">// 15</span></div><div class="line"></div><div class="line">在这个例子中，我们在函数lazy_sum中又定义了函数<span class="built_in">sum</span>，并且，内部函数<span class="built_in">sum</span>可以引用外部函数lazy_sum的参数和局部变量，</div><div class="line">当lazy_sum返回函数<span class="built_in">sum</span>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</div></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">x =&gt; x * x</div><div class="line"></div><div class="line">上面的箭头函数相当于：</div><div class="line"></div><div class="line">function (x) &#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">箭头函数有两种格式，一种像上面的，只包含一个表达式，连&#123; ... &#125;和<span class="keyword">return</span>都省略掉了。还有一种可以包含多条语句，这时候就不能省略&#123; ... &#125;和<span class="keyword">return</span>：</div><div class="line">x =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> - x * x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">用generator改写如下：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span><span class="params">(max)</span></span> &#123;</div><div class="line">    var</div><div class="line">        t,</div><div class="line">        a = <span class="number">0</span>,</div><div class="line">        b = <span class="number">1</span>,</div><div class="line">        n = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (n &lt; <span class="built_in">max</span>) &#123;</div><div class="line">        <span class="built_in">yield</span> a;</div><div class="line">        t = a + b;</div><div class="line">        a = b;</div><div class="line">        b = t;</div><div class="line">        n ++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line">直接调用试试：</div><div class="line"></div><div class="line">fib(<span class="number">5</span>); // fib &#123;<span class="string">[[GeneratorStatus]]</span>: <span class="string">"suspended"</span>, <span class="string">[[GeneratorReceiver]]</span>: Window&#125;</div><div class="line">直接调用一个generator和调用函数不一样，fib(<span class="number">5</span>)仅仅是创建了一个generator对象，还没有去执行它。</div><div class="line"></div><div class="line">调用generator对象有两个方法，一是不断地调用generator对象的<span class="built_in">next</span>()方法：</div><div class="line"></div><div class="line">var f = fib(<span class="number">5</span>);</div><div class="line">f.<span class="built_in">next</span>(); // &#123;value: <span class="number">0</span>, done: <span class="literal">false</span>&#125;</div><div class="line">f.<span class="built_in">next</span>(); // &#123;value: <span class="number">1</span>, done: <span class="literal">false</span>&#125;</div><div class="line">f.<span class="built_in">next</span>(); // &#123;value: <span class="number">1</span>, done: <span class="literal">false</span>&#125;</div><div class="line">f.<span class="built_in">next</span>(); // &#123;value: <span class="number">2</span>, done: <span class="literal">false</span>&#125;</div><div class="line">f.<span class="built_in">next</span>(); // &#123;value: <span class="number">3</span>, done: <span class="literal">true</span>&#125;</div><div class="line"><span class="built_in">next</span>()方法会执行generator的代码，然后，每次遇到<span class="built_in">yield</span> x;就返回一个对象&#123;value: x, done: <span class="literal">true</span>/<span class="literal">false</span>&#125;，然后“暂停”。返回的value就是<span class="built_in">yield</span>的返回值，done表示这个generator是否已经执行结束了。如果done为<span class="literal">true</span>，则value就是<span class="keyword">return</span>的返回值。</div><div class="line"></div><div class="line">当执行到done为<span class="literal">true</span>时，这个generator对象就已经全部执行完毕，不要再继续调用<span class="built_in">next</span>()了。</div></pre></td></tr></table></figure><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">总结一下，有这么几条规则需要遵守：</div><div class="line"></div><div class="line">不要使用<span class="keyword">new</span> <span class="built_in">Number</span>()、<span class="keyword">new</span> <span class="built_in">Boolean</span>()、<span class="keyword">new</span> <span class="built_in">String</span>()创建包装对象；</div><div class="line"></div><div class="line">用<span class="built_in">parseInt</span>()或<span class="built_in">parseFloat</span>()来转换任意类型到<span class="built_in">number</span>；</div><div class="line"></div><div class="line">用<span class="built_in">String</span>()来转换任意类型到<span class="built_in">string</span>，或者直接调用某个对象的toString()方法；</div><div class="line"></div><div class="line">通常不必把任意类型转换为<span class="built_in">boolean</span>再判断，因为可以直接写<span class="keyword">if</span> (myVar) &#123;...&#125;；</div><div class="line"></div><div class="line"><span class="keyword">typeof</span>操作符可以判断出<span class="built_in">number</span>、<span class="built_in">boolean</span>、<span class="built_in">string</span>、<span class="function"><span class="keyword">function</span>和<span class="title">undefined</span>；</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">判断<span class="title">Array</span>要使用<span class="title">Array</span>.<span class="title">isArray</span>(<span class="params">arr</span>)；</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">判断<span class="title">null</span>请使用<span class="title">myVar</span> === <span class="title">null</span>；</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">判断某个全局变量是否存在用<span class="title">typeof</span> <span class="title">window</span>.<span class="title">myVar</span> === '<span class="title">undefined</span>'；</span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">函数内部判断某个变量是否存在用<span class="title">typeof</span> <span class="title">myVar</span> === '<span class="title">undefined</span>'。</span></div></pre></td></tr></table></figure><h2 id="RegExp-正则表达式"><a href="#RegExp-正则表达式" class="headerlink" title="RegExp (正则表达式)"></a>RegExp (正则表达式)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：</div><div class="line"></div><div class="line"><span class="string">'00\d'</span>可以匹配<span class="string">'007'</span>，但无法匹配<span class="string">'00A'</span>；</div><div class="line"></div><div class="line"><span class="string">'\d\d\d'</span>可以匹配<span class="string">'010'</span>；</div><div class="line"></div><div class="line"><span class="string">'\w\w'</span>可以匹配<span class="string">'js'</span>；</div><div class="line"></div><div class="line">.可以匹配任意字符，所以：</div><div class="line"></div><div class="line"><span class="string">'js.'</span>可以匹配<span class="string">'jsp'</span>、<span class="string">'jss'</span>、<span class="string">'js!'</span>等等。</div><div class="line"></div><div class="line">JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：</div><div class="line">var s=<span class="string">'zhuzhuyang, xiaoyang, feiyang'</span>;</div><div class="line">var reg = <span class="regexp">/[a-zA-Z]+yang/g</span>;</div><div class="line"></div><div class="line">reg.exec(s); <span class="regexp">//</span>[<span class="string">'zhuzhuyang'</span>]</div><div class="line">reg.lastIndex; <span class="regexp">//</span><span class="number">10</span></div><div class="line"></div><div class="line">reg.exec(s); <span class="regexp">//</span>[<span class="string">'xiaoyang'</span>]</div><div class="line">reg.lastIndex; <span class="regexp">//</span><span class="number">20</span></div><div class="line"></div><div class="line">reg.exec(s); <span class="regexp">//</span>[<span class="string">'feiyang'</span>]</div><div class="line">reg.lastIndex; <span class="regexp">//</span><span class="number">29</span></div><div class="line"></div><div class="line">reg.exec(s); <span class="regexp">//</span> null，直到结束仍没有匹配到</div></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">在<span class="number">2002</span>年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了<span class="built_in">JSON</span>这种超轻量级的数据交换格式。</div><div class="line"></div><div class="line">道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的<span class="built_in">JSON</span>实际上是JavaScript的一个子集。在<span class="built_in">JSON</span>中，一共就这么几种数据类型：</div><div class="line"></div><div class="line"><span class="built_in">number</span>：和JavaScript的<span class="built_in">number</span>完全一致；</div><div class="line"><span class="built_in">boolean</span>：就是JavaScript的<span class="literal">true</span>或<span class="literal">false</span>；</div><div class="line"><span class="built_in">string</span>：就是JavaScript的<span class="built_in">string</span>；</div><div class="line"><span class="literal">null</span>：就是JavaScript的<span class="literal">null</span>；</div><div class="line">array：就是JavaScript的<span class="built_in">Array</span>表示方式——[]；</div><div class="line">object：就是JavaScript的&#123; ... &#125;表示方式。</div></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var xiaoming = &#123;</div><div class="line">    name: '小明',</div><div class="line">    age: <span class="number">14</span>,</div><div class="line">    gender: <span class="literal">true</span>,</div><div class="line">    height: <span class="number">1.65</span>,</div><div class="line">    grade: null,</div><div class="line">    <span class="symbol">'middle</span>-school': '\<span class="string">"W3C\"</span> Middle School',</div><div class="line">    skills: [<span class="symbol">'JavaScript</span>', <span class="symbol">'Java</span>', <span class="symbol">'Python</span>', <span class="symbol">'Lisp</span>']</div><div class="line">&#125;;</div><div class="line">JSON.stringify(xiaoming); // '&#123;<span class="string">"name"</span>:<span class="string">"小明"</span>,<span class="string">"age"</span>:<span class="number">14</span>,<span class="string">"gender"</span>:<span class="literal">true</span>,<span class="string">"height"</span>:<span class="number">1.65</span>,<span class="string">"grade"</span>:null,<span class="string">"middle-school"</span>:<span class="string">"\"</span>W3C\<span class="string">" Middle School"</span>,<span class="string">"skills"</span>:[<span class="string">"JavaScript"</span>,<span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"Lisp"</span>]&#125;'</div><div class="line"></div><div class="line">要输出得好看一些，可以加上参数，按缩进输出：</div><div class="line"></div><div class="line">JSON.stringify(xiaoming, null, '  ');</div><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"小明"</span>,</div><div class="line">  <span class="string">"age"</span>: <span class="number">14</span>,</div><div class="line">  <span class="string">"gender"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"height"</span>: <span class="number">1.65</span>,</div><div class="line">  <span class="string">"grade"</span>: null,</div><div class="line">  <span class="string">"middle-school"</span>: <span class="string">"\"</span>W3C\<span class="string">" Middle School"</span>,</div><div class="line">  <span class="string">"skills"</span>: [</div><div class="line">    <span class="string">"JavaScript"</span>,</div><div class="line">    <span class="string">"Java"</span>,</div><div class="line">    <span class="string">"Python"</span>,</div><div class="line">    <span class="string">"Lisp"</span></div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">更多JSON用法可以看廖雪峰教程</div></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Student = &#123;</div><div class="line">    name: <span class="string">'Robot'</span>,</div><div class="line">    height: <span class="number">1.2</span>,</div><div class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.__proto__ = Student;</div><div class="line"></div><div class="line">注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：</div><div class="line"></div><div class="line">xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用：</div></pre></td></tr></table></figure></p><p><img src="http://www.liaoxuefeng.com/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l" alt=""><br><code>请注意</code>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.<strong>proto</strong>去改变一个对象的原型，并且，低版本的IE也无法使用<strong>proto</strong>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型对象:</span></div><div class="line"><span class="keyword">var</span> Student = &#123;</div><div class="line">    name: <span class="string">'Robot'</span>,</div><div class="line">    height: <span class="number">1.2</span>,</div><div class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">    <span class="comment">// 初始化新对象:</span></div><div class="line">    s.name = name;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">'小明'</span>);</div><div class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;廖雪峰-js教程&quot;&gt;&lt;a href=&quot;#廖雪峰-js教程&quot; class=&quot;headerlink&quot; title=&quot;廖雪峰 js教程&quot;&gt;&lt;/a&gt;廖雪峰 js教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的练习基本是按着教程敲了一遍.  用的Chrome调试窗口,很方便!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是笔记&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;javascript的五种基本数据类型&quot;&gt;&lt;a href=&quot;#javascript的五种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;javascript的五种基本数据类型&quot;&gt;&lt;/a&gt;javascript的五种基本数据类型&lt;/h2&gt;&lt;p&gt;基本数据类型: Undefined，Null，Boolean，Number和String; 此外还含有一种复杂数据类型—Object&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://yangxiaoge.github.io/categories/JavaScript/"/>
    
    
      <category term="前端开发" scheme="https://yangxiaoge.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://yangxiaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flow.ci持续集成</title>
    <link href="https://yangxiaoge.github.io/2016/12/07/flow.ci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://yangxiaoge.github.io/2016/12/07/flow.ci持续集成/</id>
    <published>2016-12-07T14:19:05.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来<code>给自己定个长期目标</code>， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。</p><p><strong>言归正传</strong><br>其实获得<a href="http://dashboard.flow.ci/" target="_blank" rel="external">FlowCi</a>测试资格已经好几个月了， 一直没有去使用它， <a href="http://dashboard.flow.ci/" target="_blank" rel="external">FlowCi</a>功能非常强大。 之前我用的是<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="external">daocloud</a>持续集成博客, 不过今天发现持续集成失败了， 发现是<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="external">daocloud</a>升级了， 集成的配置文件需要修改， 我就乘此机会转投<a href="http://dashboard.flow.ci/" target="_blank" rel="external">FlowCi</a>的怀抱中了 O(∩_∩)O哈哈~<br>那么 怎么使用 FlowCi 为 Hexo博客持续集成呢？<br><a id="more"></a></p><blockquote><p>PS: (2016-12-8 09:31:50 add) 强迫症的我还是把<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="external">daocloud</a>持续集成搞好了(^o^)/~, 不过我还是用FlowCi吧, 尝试新工具哈哈~~<br><em>啪啪打脸~~</em> flowci hook push不及时, 有时候coding源码修改了,但是都不push消息给flowci,所以博客有时候并没有自动集成o(╯□╰)o</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fai7qzz2unj216v0edgmw.jpg" alt="create project"></p><h2 id="选择代码仓库"><a href="#选择代码仓库" class="headerlink" title="选择代码仓库"></a>选择代码仓库</h2><p> 这里取决于hexo博客源文件存放在哪里了 github, coding等…<br><img src="http://ww2.sinaimg.cn/mw1024/c05ae6b6gw1fai7ue4f1vj217c0ei0tv.jpg" alt="select the code repository"></p><h2 id="创建新的工作流"><a href="#创建新的工作流" class="headerlink" title="创建新的工作流"></a>创建新的工作流</h2><p> 之前有简单的步骤就省略了…</p><p> <img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fai89o501cj216z0kj76h.jpg" alt="Workflow select"></p><p> 工作流选择, <code>Nodejs</code>(Hexo编译所需环境)，版本选择了最新的<code>v6.6.0</code>, 当然还有其他的, <code>Python</code>, <code>Android</code>, <code>Php</code>等。<br> 后面我会尝试使用<code>Android持续集成</code>，也会写相应文章。</p><h2 id="触发器-什么时候自动集成"><a href="#触发器-什么时候自动集成" class="headerlink" title="触发器(什么时候自动集成)"></a>触发器(什么时候自动集成)</h2><p> 设置 触发器-push-正则匹配-master, 意思就是当 hexo博客git的master源文件改变时, 就会触发FlowCi的持续集成!</p><h2 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a>自定义脚本</h2><p>这里的 <code>.daocloud文件夹</code>(文件夹随便怎么命名)是用来存放<code>id_rsa</code>的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 安装Hexo命令行工具</span></div><div class="line">flow_cmd <span class="string">"npm install hexo-cli -g"</span> --<span class="built_in">echo</span></div><div class="line"></div><div class="line"><span class="comment"># 准备并安装私钥</span></div><div class="line">flow_cmd <span class="string">"cp .daocloud/id_rsa ."</span> --<span class="built_in">echo</span>  </div><div class="line">flow_cmd <span class="string">"chmod 600 ./id_rsa"</span> --<span class="built_in">echo</span>  </div><div class="line">flow_cmd <span class="string">"eval <span class="variable">$(ssh-agent)</span>"</span> --<span class="built_in">echo</span>  </div><div class="line">flow_cmd <span class="string">"ssh-add ./id_rsa"</span> --<span class="built_in">echo</span></div><div class="line"></div><div class="line"><span class="comment"># 执行Hexo生成和发布</span></div><div class="line"></div><div class="line">flow_cmd <span class="string">"hexo clean"</span> --<span class="built_in">echo</span>  </div><div class="line">flow_cmd <span class="string">"hexo g"</span> --<span class="built_in">echo</span>  </div><div class="line">flow_cmd <span class="string">"hexo d"</span> --<span class="built_in">echo</span></div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw1024/c05ae6b6gw1fai8ir2iphj217j0kv77e.jpg" alt="custom script"></p><h1 id="添加FlowCi的-RSA公匙到github以及coding-授予读写权限"><a href="#添加FlowCi的-RSA公匙到github以及coding-授予读写权限" class="headerlink" title="添加FlowCi的 RSA公匙到github以及coding(授予读写权限)"></a>添加FlowCi的 RSA公匙到github以及coding(授予读写权限)</h1><p><img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fajdovw24yj21640e4wh4.jpg" alt="RSA公匙配置"></p><h1 id="快去提交代码吧"><a href="#快去提交代码吧" class="headerlink" title="快去提交代码吧"></a>快去提交代码吧</h1><p>我是单独在coding建了一个新的仓库存放博客源文件,<a href="https://coding.net/u/yangxiaoge/p/yangxiaoge-CI" target="_blank" rel="external">yangxiaoge-CI</a><br>之后只要往<code>yangxiaoge-CI</code>仓库中提交或者增删改查时, <code>FlowCi</code>会自动集成并发布到<a href="https://coding.net/u/yangxiaoge/p/yangxiaoge" target="_blank" rel="external">yangxiaoge</a>编译后的博客地址中!<br><strong>binggo!!!</strong>坐等集成好,登录网站查看变动吧！是不是很爽😏 , 跨PC更新博客也更方便啦~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来&lt;code&gt;给自己定个长期目标&lt;/code&gt;， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;言归正传&lt;/strong&gt;&lt;br&gt;其实获得&lt;a href=&quot;http://dashboard.flow.ci/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlowCi&lt;/a&gt;测试资格已经好几个月了， 一直没有去使用它， &lt;a href=&quot;http://dashboard.flow.ci/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlowCi&lt;/a&gt;功能非常强大。 之前我用的是&lt;a href=&quot;https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;daocloud&lt;/a&gt;持续集成博客, 不过今天发现持续集成失败了， 发现是&lt;a href=&quot;https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;daocloud&lt;/a&gt;升级了， 集成的配置文件需要修改， 我就乘此机会转投&lt;a href=&quot;http://dashboard.flow.ci/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FlowCi&lt;/a&gt;的怀抱中了 O(∩_∩)O哈哈~&lt;br&gt;那么 怎么使用 FlowCi 为 Hexo博客持续集成呢？&lt;br&gt;
    
    </summary>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Hexo" scheme="https://yangxiaoge.github.io/tags/Hexo/"/>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>mock数据</title>
    <link href="https://yangxiaoge.github.io/2016/11/08/Fiddler%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82mock%E5%81%87%E6%95%B0%E6%8D%AE/"/>
    <id>https://yangxiaoge.github.io/2016/11/08/Fiddler拦截请求mock假数据/</id>
    <published>2016-11-08T10:44:59.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fiddler抓包拦截"><a href="#Fiddler抓包拦截" class="headerlink" title="Fiddler抓包拦截"></a>Fiddler抓包拦截</h2><p><img src="/img/fiddler mock.png" alt="看图一目了然"></p><h2 id="Easy-Mock"><a href="#Easy-Mock" class="headerlink" title="Easy Mock"></a><a href="https://easy-mock.com/" target="_blank" rel="external">Easy Mock</a></h2><p><img src="/img/easy-mock.png" alt="easy-mock"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Fiddler抓包拦截&quot;&gt;&lt;a href=&quot;#Fiddler抓包拦截&quot; class=&quot;headerlink&quot; title=&quot;Fiddler抓包拦截&quot;&gt;&lt;/a&gt;Fiddler抓包拦截&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/fiddler mock.png&quot; a
      
    
    </summary>
    
      <category term="mock" scheme="https://yangxiaoge.github.io/categories/mock/"/>
    
    
      <category term="Fiddler" scheme="https://yangxiaoge.github.io/tags/Fiddler/"/>
    
      <category term="mock" scheme="https://yangxiaoge.github.io/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄漏总结</title>
    <link href="https://yangxiaoge.github.io/2016/10/10/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://yangxiaoge.github.io/2016/10/10/Android内存泄漏总结/</id>
    <published>2016-10-10T13:29:20.000Z</published>
    <updated>2017-09-20T09:55:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。</p><p>我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。</p><a id="more"></a><h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p><ul><li><p>静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p></li><li><p>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p></li><li><p>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p></li></ul><h2 id="栈与堆的区别："><a href="#栈与堆的区别：" class="headerlink" title="栈与堆的区别："></a>栈与堆的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p><p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p><p>举个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>;</div><div class="line">    Sample mSample1 = <span class="keyword">new</span> Sample();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</div><div class="line">        Sample mSample2 = <span class="keyword">new</span> Sample();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sample mSample3 = <span class="keyword">new</span> Sample();</div></pre></td></tr></table></figure><p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。<br>mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</p><p>结论：</p><p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</p><p>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p><p>了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。</p><h2 id="Java是如何管理内存"><a href="#Java是如何管理内存" class="headerlink" title="Java是如何管理内存"></a>Java是如何管理内存</h2><p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p><p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p><p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。<br>以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p><p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/1.gif" alt=""></p><p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p><h2 id="什么是Java中的内存泄露"><a href="#什么是Java中的内存泄露" class="headerlink" title="什么是Java中的内存泄露"></a>什么是Java中的内存泄露</h2><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p><p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p><p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/2.gif" alt=""></p><p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p><p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p><p>同样给出一个 Java 内存泄漏的典型例子，</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">    <span class="keyword">Object</span> o = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">    v.<span class="built_in">add</span>(o);</div><div class="line">    o = <span class="keyword">null</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p><p><strong>详细Java中的内存泄漏</strong></p><p>1.Java内存回收机制</p><p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 </p><p>2.Java内存泄漏引起的原因</p><p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j</p><p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p><p>1、静态集合类引起内存泄漏：</p><p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 </p><p>例如</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Static Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">Object</span> o = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">v.<span class="built_in">add</span>(o);</div><div class="line">o = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p><p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p><p>例如：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</div><div class="line">&#123;</div><div class="line">Set&lt;Person&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;Person&gt;();</div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"唐僧"</span>,<span class="string">"pwd1"</span>,<span class="number">25</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="string">"pwd2"</span>,<span class="number">26</span>);</div><div class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="string">"pwd3"</span>,<span class="number">27</span>);</div><div class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(p1);</div><div class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(p2);</div><div class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(p3);</div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"总共有:"</span>+<span class="built_in">set</span>.<span class="built_in">size</span>()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:3 个元素!</span></div><div class="line">p3.setAge(<span class="number">2</span>); <span class="comment">//修改p3的年龄,此时p3元素对应的hashcode值发生改变</span></div><div class="line"></div><div class="line"><span class="built_in">set</span>.remove(p3); <span class="comment">//此时remove不掉，造成内存泄漏</span></div><div class="line"></div><div class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(p3); <span class="comment">//重新添加，居然添加成功</span></div><div class="line">System.out.<span class="built_in">println</span>(<span class="string">"总共有:"</span>+<span class="built_in">set</span>.<span class="built_in">size</span>()+<span class="string">" 个元素!"</span>); <span class="comment">//结果：总共有:4 个元素!</span></div><div class="line"><span class="keyword">for</span> (Person person : <span class="built_in">set</span>)</div><div class="line">&#123;</div><div class="line">System.out.<span class="built_in">println</span>(person);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>3、监听器</p><p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p><p>4、各种连接 </p><p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p><p>5、内部类和外部模块的引用</p><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b);<br>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p><p>6、单例模式 </p><p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</div><div class="line">B.getInstance().setA(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">....</div><div class="line">&#125;</div><div class="line"><span class="comment">//B类采用单例模式</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></div><div class="line"><span class="keyword">private</span> A a;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> B instance=<span class="keyword">new</span> B();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> B <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.a=a;</div><div class="line">&#125;</div><div class="line"><span class="comment">//getter...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p><h2 id="Android中常见的内存泄漏汇总"><a href="#Android中常见的内存泄漏汇总" class="headerlink" title="Android中常见的内存泄漏汇总"></a>Android中常见的内存泄漏汇总</h2><hr><h3 id="集合类泄漏"><a href="#集合类泄漏" class="headerlink" title="集合类泄漏"></a>集合类泄漏</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。</p><h3 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h3><p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class AppManager &#123;</div><div class="line">private static AppManager instance;</div><div class="line">private Context context;</div><div class="line">private AppManager(Context context) &#123;</div><div class="line">this.context = context;</div><div class="line">&#125;</div><div class="line">public static AppManager getInstance(Context context) &#123;</div><div class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</div><div class="line">instance = new AppManager(context);</div><div class="line">&#125;</div><div class="line">return instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p><p>1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</p><p>2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</p><p>正确的方式应该改为下面这种方式：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class AppManager &#123;</div><div class="line">private<span class="keyword"> static</span> AppManager instance;</div><div class="line">private Context context;</div><div class="line">private AppManager(Context context) &#123;</div><div class="line">this.context = context.getApplicationContext();// 使用Application 的context</div><div class="line">&#125;</div><div class="line">public<span class="keyword"> static</span> AppManager getInstance(Context context) &#123;</div><div class="line">if (instance == null) &#123;</div><div class="line">instance =<span class="built_in"> new </span>AppManager(context);</div><div class="line">&#125;</div><div class="line">return instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者这样写，连 Context 都不用传进来了：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，</div><div class="line"></div><div class="line"><span class="keyword">.</span>..</div><div class="line"></div><div class="line">context = getApplicationContext();</div><div class="line"></div><div class="line"><span class="keyword">.</span>..</div><div class="line">   /**</div><div class="line">     * 获取全局的context</div><div class="line">     * @return 返回全局context对象</div><div class="line">     */</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Context getContext()&#123;</div><div class="line">       <span class="built_in"> return </span>context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public class AppManager &#123;</div><div class="line">private<span class="keyword"> static</span> AppManager instance;</div><div class="line">private Context context;</div><div class="line">private AppManager() &#123;</div><div class="line">this.context = MyApplication.getContext();// 使用Application 的context</div><div class="line">&#125;</div><div class="line">public<span class="keyword"> static</span> AppManager getInstance() &#123;</div><div class="line">if (instance == null) &#123;</div><div class="line">instance =<span class="built_in"> new </span>AppManager();</div><div class="line">&#125;</div><div class="line">return instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="匿名内部类-非静态内部类和异步线程"><a href="#匿名内部类-非静态内部类和异步线程" class="headerlink" title="匿名内部类/非静态内部类和异步线程"></a>匿名内部类/非静态内部类和异步线程</h3><p>非静态内部类创建静态实例造成的内存泄漏</p><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">setContentView(<span class="type">R</span>.layout.activity_main);</div><div class="line"><span class="keyword">if</span>(mManager == <span class="literal">null</span>)&#123;</div><div class="line">mManager = <span class="keyword">new</span> <span class="type">TestResource</span>();</div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：</p><p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p><p><img src="http://img.blog.csdn.net/20151123144226349?spm=5176.100239.blogcont.9.CtU1c4" alt="Context的应用场景"></p><p>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">...</div><div class="line"><span class="type">Runnable</span> ref1 = <span class="keyword">new</span> <span class="type">MyRunable</span>();</div><div class="line"><span class="type">Runnable</span> ref2 = <span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    public void run() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e?spm=5176.100239.blogcont.10.CtU1c4" alt=""></p><p>可以看到，ref1没什么特别的。</p><p>但ref2这个匿名类的实现对象里面多了一个引用：</p><p>this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。</p><h3 id="Handler-造成的内存泄漏"><a href="#Handler-造成的内存泄漏" class="headerlink" title="Handler 造成的内存泄漏"></a>Handler 造成的内存泄漏</h3><p>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p><p>由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakyHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line"><span class="comment">// Post a message and delay its execution for 10 minutes.</span></div><div class="line">mLeakyHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">&#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="comment">// Go back to the previous Activity.</span></div><div class="line">finish();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。</p><p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Instances of static inner classes do not hold an implicit</span></div><div class="line"><span class="comment">   * reference to their outer class.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WeakReference</span>&lt;<span class="type">SampleActivity</span>&gt; mActivity;</div><div class="line"></div><div class="line">    public <span class="type">MyHandler</span>(<span class="type">SampleActivity</span> activity) &#123;</div><div class="line">      mActivity = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="type">SampleActivity</span>&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    public void handleMessage(<span class="type">Message</span> msg) &#123;</div><div class="line">      <span class="type">SampleActivity</span> activity = mActivity.get();</div><div class="line">      <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Instances of anonymous classes do not hold an implicit</span></div><div class="line"><span class="comment">   * reference to their outer class when they are "static".</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">Runnable</span> sRunnable = <span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      public void run() &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    <span class="comment">// Post a message and delay its execution for 10 minutes.</span></div><div class="line">    mHandler.postDelayed(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Go back to the previous Activity.</span></div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p><p>前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。</p><p>Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。</p><p><img src="https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg" alt=""></p><p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p><p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</p><p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：</p><p>首先定义一个HashMap，保存软引用对象。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">private</span> <span class="meta">Map</span> &lt;<span class="keyword">String, </span>SoftReference&lt;<span class="keyword">Bitmap&gt;&gt; </span>imageCache = new HashMap &lt;<span class="keyword">String, </span>SoftReference&lt;<span class="keyword">Bitmap&gt;&gt; </span>()<span class="comment">;</span></div></pre></td></tr></table></figure><p>再来定义一个方法，保存Bitmap的软引用到HashMap。</p><p><img src="https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg" alt=""></p><p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</p><p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p><p>ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p><p>下面几个方法都可以移除 Message：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacks</span><span class="params">(Runnable r, Object token)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span></span>;</div></pre></td></tr></table></figure><h3 id="尽量避免使用-static-成员变量"><a href="#尽量避免使用-static-成员变量" class="headerlink" title="尽量避免使用 static 成员变量"></a>尽量避免使用 static 成员变量</h3><p>如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。</p><p>这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。</p><p>这里修复的方法是：</p><p>不要在类初始时初始化静态成员。可以考虑lazy初始化。<br>架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p><h3 id="避免-override-finalize"><a href="#避免-override-finalize" class="headerlink" title="避免 override finalize()"></a>避免 override finalize()</h3><p>1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是：<br>        虚拟机调用GC的时间不确定<br>        Finalize daemon线程被调度到的时间不确定</p><p>2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：</p><p>含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。</p><p>3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。</p><h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h3><p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p><h3 id="一些不良代码造成的内存压力"><a href="#一些不良代码造成的内存压力" class="headerlink" title="一些不良代码造成的内存压力"></a>一些不良代码造成的内存压力</h3><p>有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p><p>比如：<br>        Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。<br>        构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</p><p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p><pre><code>将内部类改为静态内部类静态内部类中使用弱引用来引用外部类的成员变量</code></pre><p>Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.</p><p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</p><p>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p><p>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。</p><blockquote><p><a href="https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md" target="_blank" rel="external">原文链接</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。&lt;/p&gt;
&lt;p&gt;我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="内存泄漏" scheme="https://yangxiaoge.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>有人向我反馈了一个bug</title>
    <link href="https://yangxiaoge.github.io/2016/09/23/%E6%9C%89%E4%BA%BA%E5%90%91%E6%88%91%E5%8F%8D%E9%A6%88%E4%BA%86%E4%B8%80%E4%B8%AAbug/"/>
    <id>https://yangxiaoge.github.io/2016/09/23/有人向我反馈了一个bug/</id>
    <published>2016-09-23T12:55:26.000Z</published>
    <updated>2017-09-20T09:55:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>本文原文地址 : <a href="http://www.midaoi.com/2015/08/28/bug/" target="_blank" rel="external">Midaoi小站</a></p><blockquote><p>前言</p></blockquote><p>这篇文章非常有意思！ </p><blockquote><p><a href="http://www.reddit.com/r/ProgrammerHumor/comments/2spd2s/when_someone_gives_you_a_bug_long/" target="_blank" rel="external">英文原文 →</a></p></blockquote><a id="more"></a><p>//我是一个Android开发者，但我想这个故事对任何开发者都会引起共鸣的</p><p>有人向你反馈了一个 bug。 “26 楼会议室的灯亮着。它需要被熄灭。”bug 的备注里写道“你应该能在 5 分钟内搞定，只要按一下开关就好了。“ 你去了 26 楼的会议室。灯的确亮着，但房间里没有灯的开关。</p><p>所以，你准备安装一个。但设计师说，它会破坏房间的美感。另外，墙壁是混凝土。你需要合适的工具才能安装开关。但是，没有人会批准购买这些工具。如果没有合适的工具，安装开关将需要两天。他们希望你现在就能把灯关上，因为他们害怕 CEO 可能心血来潮决定去 26 楼逛逛，并恰好路过了会议室，问为什么灯是亮着的。</p><p>现在你不断地收到邮件，询问为什么会议室的灯还是亮着的。现在你不得不群发一封邮件说明情况，几人开始了一个恐慌的电子邮件链。</p><p>你知道，如果你期待着问题能够被邮件讨论解决（而不实际做点什么），这个问题永远也不会得到修复。bug 系统里，这个 bug 归你处理，而且它的最后期限就是今天。如果问题没有解决，会有麻烦的是你。所以，你设法进到了 26 楼走廊的天花板里，找到了会议室灯的电线，一刀切断。问题解决了。</p><p>为了平息在电子邮件链里的恐慌，你(再次群发邮件)说明了你是如何解决问题的。</p><p>邮箱安静了一阵。当它再次响个不停的时候，每个人都在担心，现在会议室的灯无法开启和关闭。如果 CEO 想在那里开会怎么办？因此，他们要求你“把灯的电线牵引到地下室去”。当有人需要开关灯时，他们会通知你到地下室去，连接或断开电线。</p><p>你抗议这个荒谬的解决方案。你的上司说，“是的，我知道这不理想。但它是现在唯一的解决方案。“</p><p>这时，你面临着选择。你可以照着他们说的做，或者辞职以示抗议，另谋高就。但你知道，一旦你开始了新的工作，新的他们很可能也会要求你做这么白痴的事，如果不是更白痴的话。</p><p>你把 26 楼的电线牵引到了地下室。当你进入地下室后，发现已经有几十条电线挂在墙上，你知道你不是一个人，也知道了这个白痴想法是从哪来的。你调整好了电线，尽人事地贴上标记，默默地向下一个可能处理它的哥们道歉。</p><p>终于，你回到了你的办公桌，你收到了一个新的 report。 QA 重新开启了 bug。bug 描述里说“房间还是亮着。”</p><p>你回到 26 楼的会议室。灯是灭着的。你返回办公桌前，关闭了 bug，注明你已经亲自检查过了。</p><p>QA 再次重新开启了 bug。“房间还亮着”bug 描述里坚持。再次亲眼确认灯泡灭着后，你将情况汇报给了上司。他建议你去地下室检查电线。你抗议说你正直盯盯地看着灯，它就是灭着的。 “我知道，但去检查一下。这样一来你就可以告诉 QA 你确认了所有流程。”</p><p>你叹了口气，前往地下室。果然，电线没有连接，切口两端都好好地被包裹着。它们不可能以任何你能理解的方式导电。</p><p>你向 QA 反馈，你检查了电线，它们没有连接着，你正看着灯泡，它是熄灭的。</p><p>“我不是指灯泡，”QA 说。 “bug 里描述的是房间里的光。房间现在仍然不够暗。你应该拉下百叶窗。“<br>你回应说百叶窗不归你管，bug 描述的是灯光。</p><p>QA 不相信你，发出一组电子邮件，询问 bug 是否包含百叶窗拉下的问题。</p><p>你很是等待了一会，邮箱又一次响起了。 </p><p>“从理论上说，”他们问，“如果光太亮或太暗的话，在 26 楼会议室开会的人能自由拉上或拉下百叶窗吗？”</p><p>是的，他们可以，你回复。 “任何一个普通人都能做到吗？他们就不需要你做了吗？“是的，任何普通人。不，他们不会需要你。任何人都可以做到这一点。 “太好了。那么，灯光问题暂时到此为止。我会安排如何处理百叶窗的会议。“</p><p>bug 被关闭了。现在，CEO，可能从所有关于 26 楼会议室的讨论中感觉到了什么，希望在那里开会。你收到了几封希望开灯的惊慌失措的邮件。</p><p>你去了地下室，连上电线，并返回办公桌。你的收件箱多了 32 个新的消息。 “出问题了-灯还是熄灭的!”“有个问题-没有灯光!” “你收到我们发的邮件了吗？等等等等。</p><p>第 32 封邮件说道:“没事-灯亮了。”</p><p>这个(指 32 封邮件)过程，或多或少地，在开关灯时反复发生。</p><p>如果要说有什么好消息的话，那就是在会议结束后，大家甚至都忘记了 26 楼有个会议室，你也不需要对它做任何处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文原文地址 : &lt;a href=&quot;http://www.midaoi.com/2015/08/28/bug/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Midaoi小站&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章非常有意思！ &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.reddit.com/r/ProgrammerHumor/comments/2spd2s/when_someone_gives_you_a_bug_long/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;英文原文 →&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="bug小场景" scheme="https://yangxiaoge.github.io/categories/bug%E5%B0%8F%E5%9C%BA%E6%99%AF/"/>
    
    
      <category term="article" scheme="https://yangxiaoge.github.io/tags/article/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用工具</title>
    <link href="https://yangxiaoge.github.io/2016/09/21/Windows%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://yangxiaoge.github.io/2016/09/21/Windows常用工具/</id>
    <published>2016-09-21T15:24:00.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先申明本文转载， 本文由 <a href="http://michaelxiang.me/" target="_blank" rel="external">Michael翔</a> 创作， 基于原文有所改动 !</p></blockquote><p>总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯：</p><hr><a id="more"></a><h2 id="Windowns常用软件"><a href="#Windowns常用软件" class="headerlink" title="Windowns常用软件"></a>Windowns常用软件</h2><h2 id="录制Gif工具"><a href="#录制Gif工具" class="headerlink" title="录制Gif工具"></a>录制Gif工具</h2><p><a href="http://www.cockos.com/licecap/" target="_blank" rel="external">LICEcap录制Gif工具</a><br><a href="https://screentogif.codeplex.com/" target="_blank" rel="external">ScreenToGif</a> 工具相当不错，而且是绿色软件，真良心~~</p><h2 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h2><p><a href="http://www.faststone.org/" target="_blank" rel="external">FastStoneImageViewer</a> 免费软件，好用到爆！没广告！功能齐全！不光能看图，还能修图！<br><del>Picasa3 Google的图片管理软件(已经停止服务了)</del><br><a href="https://photos.google.com/" target="_blank" rel="external">Photos</a> Google 相册照片服务 (本人iPhone6内存16G伤不起(；′⌒`), 果断备份到Google Photos了!!!)</p><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p><a href="http://www.appinn.com/listary/" target="_blank" rel="external">Listary</a> 小众软件介绍，超级好用的文件搜索工具，按下快捷键，随时搜索<br><a href="http://www.voidtools.com/" target="_blank" rel="external">Everything</a> 也是传说中的文档搜索神器！其他功能有待开发……<br><!-- more --></p><h2 id="文件整理"><a href="#文件整理" class="headerlink" title="文件整理"></a>文件整理</h2><p><a href="http://www.softpedia.com/get/PORTABLE-SOFTWARE/System/File-management/Portable-Q-Dir.shtml" target="_blank" rel="external">Q-Dir</a> 有时候需要在文件夹之间移动文件，这时候，这个整理神器就能派上用场了！<br><a href="http://cn.ejie.me/" target="_blank" rel="external">Clover 3</a> 这款文件夹体验跟浏览器一样，不会有多窗口，不会杂乱无章 ! — <em>个人目前在用</em></p><h2 id="pdf查看"><a href="#pdf查看" class="headerlink" title="pdf查看"></a>pdf查看</h2><p><a href="http://www.foxitsoftware.cn/downloads/" target="_blank" rel="external">福昕pdf阅读正版</a><br><a href="http://pic.2345.com/" target="_blank" rel="external">2345看图王</a> 你没看错，2345就是这么强大~</p><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><p><a href="http://www.potplayer.org/" target="_blank" rel="external">PotPlayer</a> 厌烦了暴风一打开就是广告，发现了这款播放器，没广告！能力出色！</p><h2 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h2><p><a href="http://www.flvcd.com/" target="_blank" rel="external">硕鼠</a> <em>有的也不能下载了，比如优酷</em>    视频下载神器！为了下载PC上的网易公开课发现的工具，很多视频网站都能下载！</p><h2 id="同步盘"><a href="#同步盘" class="headerlink" title="同步盘"></a>同步盘</h2><p><a href="https://c-t.yunpan.360.cn/" target="_blank" rel="external">360云盘</a><br><a href="https://pan.baidu.com/" target="_blank" rel="external">百度云</a><br>这两款同步盘真是给我带来了很大的便利，安全性啥的也不用去较真，非得整啥Dropbox(需要梯子)，毕竟自己也没啥重要隐私文件……</p><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p><a href="http://www.softpedia.com/dyn-search.php?search_term=unlocker+" target="_blank" rel="external">Unlocker下载</a> 当你重命名或删除一个文件/文件夹时，Windows 弹出对话框提示你“无法删除 xxx:它正在被其它用户/程序使用!”，怎么办?<br>其实<code>腾讯电脑管家</code>的 <strong>文件粉碎</strong> 功能也可以 — <em>个人在用</em></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 很占内存，但启动速度、标签、扩展同步等真是做的棒！一个账号，走遍天下~安利下知乎上的总结的<a href="http://zhuanlan.zhihu.com/michael-xox/20356820" target="_blank" rel="external">Chrome扩展</a> ~~需要更多的插件可以去知乎搜索下</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><a href="https://www.yinxiang.com/" target="_blank" rel="external">印象笔记</a> 很棒！裁剪、搜索、标签等细节功能做的很到位！简洁大气的风格，很喜欢。— 目前在用<br><a href="http://www.wiz.cn/" target="_blank" rel="external">为知笔记</a> 国内良心笔记公司，做的也很棒！代码高亮、Markdown等等都一应俱全，还有丰富的插件~</p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>搜狗输入法 哈哈，没看错！就是它！安装截图扩展之后，快捷键就能截图，哪个电脑都ok，多方便！<a href="http://michaelxiang.me/2015/12/28/tools-sougoupinyin/" target="_blank" rel="external">搜狗输入法技巧总结</a></p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>这个就比较多了， 目前在用 Gmail，126，QQ等</p><h2 id="小众软件"><a href="#小众软件" class="headerlink" title="小众软件"></a>小众软件</h2><p><a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="external">Wgesture</a> 用惯浏览器鼠标手势的同志，这个绝对是你们的福利！全局鼠标手势！！！</p><h2 id="加密工具"><a href="#加密工具" class="headerlink" title="加密工具"></a>加密工具</h2><p><a href="http://www.wisecleaner.com/wise-folder-hider-free.html" target="_blank" rel="external">Wise Folder Hider Free</a> 隐私文件怎么保存？这个获奖无数的工具，免费版足够用啦！</p><hr><h2 id="Windows下的开发工具"><a href="#Windows下的开发工具" class="headerlink" title="Windows下的开发工具"></a>Windows下的开发工具</h2><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><a href="http://cmder.net/" target="_blank" rel="external">cmder</a> 如果厌倦了Windows下控制台丑陋不方便的样子，可以试试这个。</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>Sublime Text<br>Notepad++<br>Atom</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>说到IDE当然离不开 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">jetbrains全家桶</a> 良心公司，学生党免费！前提是要有<strong>教育邮箱</strong>~<br>jetbrains全家桶: IntelliJ IDEA，PhpStorm，WebStorm，Pycharm -python开发，Android Studio也是它家提供支持的，等等<br>Redo python调试很方便，界面有点类似R-studio、<br>PyScripter python开发</p><h2 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h2><p>做完一个Coder，<a href="https://6d1b.cc" target="_blank" rel="external">ss</a>都懂的吧，学习工作专用，再配合Google搜索 (某度要慎重使用！)，效率大大提升~~</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续~~"></a>未完待续~~</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首先申明本文转载， 本文由 &lt;a href=&quot;http://michaelxiang.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Michael翔&lt;/a&gt; 创作， 基于原文有所改动 !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯：&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="工具" scheme="https://yangxiaoge.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yangxiaoge.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>daocloud持续集成个人博客</title>
    <link href="https://yangxiaoge.github.io/2016/09/20/daocloud%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yangxiaoge.github.io/2016/09/20/daocloud持续集成个人博客/</id>
    <published>2016-09-20T13:46:54.000Z</published>
    <updated>2017-09-20T09:55:11.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>详情见我基友<a href="http://littlefisher.coding.me" target="_blank" rel="external">littlefisher</a>的文章:  <a href="http://littlefisher.coding.me/2016/09/20/Hexo%20+%20DaoCloud%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" target="_blank" rel="external">Hexo + DaoCloud 持续集成</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;详情见我基友&lt;a href=&quot;http://littlefisher.coding.me&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;littlefisher&lt;/a&gt;的文章:  &lt;a href=&quot;http://littlefis
      
    
    </summary>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Hexo" scheme="https://yangxiaoge.github.io/tags/Hexo/"/>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>我的演说</title>
    <link href="https://yangxiaoge.github.io/2016/09/20/%E6%88%91%E7%9A%84%E6%BC%94%E8%AF%B4/"/>
    <id>https://yangxiaoge.github.io/2016/09/20/我的演说/</id>
    <published>2016-09-20T09:16:59.000Z</published>
    <updated>2017-09-20T09:55:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>此文是一个演示ppt的demo,只要打开网页就能随时随地展示!</p><blockquote><p>使用的是<a href="https://huangxuan.me/about/" target="_blank" rel="external">黄玄</a>开发的<a href="http://yanshuo.io/" target="_blank" rel="external">演说</a>在线工具</p></blockquote><h2 id="Watch-Fullscreen-→"><a href="#Watch-Fullscreen-→" class="headerlink" title="Watch Fullscreen →"></a><a href="/img/我的演说.html">Watch Fullscreen →</a></h2><p><img src="/img/演说Test.png" alt="你可以通过扫描二维码在手机上观看"></p><p style="text-align:center;"><br>   你可以通过扫描二维码在手机上观看<br></p><p><br></p><h3 id="上一张ubuntu的图片"><a href="#上一张ubuntu的图片" class="headerlink" title="上一张ubuntu的图片"></a>上一张ubuntu的图片</h3><p><img src="/img/ubuntu.png" alt="ubuntu"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此文是一个演示ppt的demo,只要打开网页就能随时随地展示!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用的是&lt;a href=&quot;https://huangxuan.me/about/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;黄玄&lt;/a&gt;开发的&lt;a 
      
    
    </summary>
    
      <category term="在线PPT" scheme="https://yangxiaoge.github.io/categories/%E5%9C%A8%E7%BA%BFPPT/"/>
    
    
      <category term="演说" scheme="https://yangxiaoge.github.io/tags/%E6%BC%94%E8%AF%B4/"/>
    
  </entry>
  
</feed>
