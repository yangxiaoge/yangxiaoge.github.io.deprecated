<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>珠珠のBlog</title>
  <icon>https://www.gravatar.com/avatar/4ec65d784d203bac0fd2da7375835dff</icon>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangxiaoge.github.io/"/>
  <updated>2019-03-14T01:40:22.198Z</updated>
  <id>https://yangxiaoge.github.io/</id>
  
  <author>
    <name>Bruce Yang</name>
    <email>yang.jianan0926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter 状态管理 - BLoC</title>
    <link href="https://yangxiaoge.github.io/2019/03/14/2019-3-14-Flutter-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Bloc/"/>
    <id>https://yangxiaoge.github.io/2019/03/14/2019-3-14-Flutter-状态管理-Bloc/</id>
    <published>2019-03-14T09:20:49.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p><code>BLoC</code> 是 Google 提出的一种全新的<code>状态管理</code>方案。<a href="https://juejin.im/post/5b97fa0d5188255c5546dcf8" target="_blank" rel="noopener">Scoped Model</a>，<a href="https://juejin.im/post/5c6d4b52f265da2dc675b407" target="_blank" rel="noopener">Provide</a>等也是目前比较流行的状态管理方案。</p><h2 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h2><p>Flutter 自身已经为我们提供了状态管理 <code>Stateful widget</code>，在 stateful widget 中，我们 widget 的描述信息被放进了 State，<br>而 stateful widget 只是持有一些 immutable 的数据以及创建它的状态而已。它的所有成员变量都应该是 final 的，当状态发生变化的时候，<br>我们需要通知视图重新绘制，这个过程就是 setState。这看上去很不错，我们改变状态的时候 <code>setState</code> 一下就可以了。<br>在我们一开始构建应用的时候，也许很简单，我们这时候可能并不需要状态管理。<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/setState%E7%AE%80%E5%8D%95%E5%9E%8B.png" alt><br>但是随着功能的增加，你的应用程序将会有几十个甚至上百个状态。这个时候你的应用应该会是这样！<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/setState%E5%A4%8D%E6%9D%82%E5%9E%8B.png" alt><br>一旦当 app 的交互变得复杂，setState 出现的次数便会显著增加，每次 setState 都会重新调用 build 方法，这势必对于性能以及代码的可阅读性带来一定的影响。<br>能不能不使用 setState 就能刷新页面呢？如何在多个页面中共享状态？我们希望有一种更加强大的方式，来管理我们的状态。</p><h2 id="BLoC-是什么"><a href="#BLoC-是什么" class="headerlink" title="BLoC 是什么"></a>BLoC 是什么</h2><p><code>BLoC</code> 是一种利用 <code>Reactive Programming（响应式编程）</code> 方式构建应用的方法，这是一个由流构成的完全异步的世界。<br><img src="https://raw.githubusercontent.com/yangxiaoge/PersonResources/master/flutter/bloc.png" alt></p><ol><li>用 StreamBuilder 包裹有状态的部件，streambuilder 将会监听一个流</li><li>这个流来自于 BLoC</li><li>有状态小部件中的数据来自于监听的流。</li><li>用户交互手势被检测到，产生了事件。例如按了一下按钮。</li><li>调用 bloc 的功能来处理这个事件</li><li>在 bloc 中处理完毕后将会吧最新的数据 add 进流的 sink 中</li><li>StreamBuilder 监听到新的数据，产生一个新的 snapshot，并重新调用 build 方法</li><li>Widget 被重新构建</li></ol><p>BLoC 能够允许我们完美的分离业务逻辑！再也不用考虑什么时候需要刷新屏幕了，一切交给 StreamBuilder 和 BLoC! 和 StatefulWidget 说拜拜！！</p><p>BLoC 代表业务逻辑组件（<code>Business Logic Component</code>），由来自 Google 的两位工程师 Paolo Soares 和 Cong Hui 设计，并在 2018 年 DartConf 期间（2018 年 1 月 23 日至 24 日）首次展示。<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DPLHln7wHgPE" target="_blank" rel="noopener">点击观看 Youtube 视频。</a></p><blockquote><p>作者：Vadaski<br>链接：<a href="https://juejin.im/post/5bb6f344f265da0aa664d68a" target="_blank" rel="noopener">https://juejin.im/post/5bb6f344f265da0aa664d68a</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;BLoC&lt;/code&gt; 是 Google 提出的一种全新的&lt;code&gt;状态管理&lt;/code&gt;方案。&lt;a href=&quot;https://juejin.im/post/5b97fa0d5188255c5546dcf8&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter_Go 代码开发规范 - alibaba</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Flutter_Go 代码开发规范/</id>
    <published>2019-02-28T10:27:22.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">Flutter Go 开发规范第一版</a></li><li>原文作者：<a href="https://github.com/alibaba" target="_blank" rel="noopener">alibaba</a></li></ul></blockquote><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="标识符三种类型"><a href="#标识符三种类型" class="headerlink" title="标识符三种类型"></a>标识符三种类型</h3><h4 id="大驼峰"><a href="#大驼峰" class="headerlink" title="大驼峰"></a>大驼峰</h4><p>类、枚举、typedef和类型参数</p><pre><code>  class SliderMenu { ... }  class HttpRequest { ... }  typedef Predicate = bool Function&lt;T&gt;(T value);</code></pre><p>包括用于元数据注释的类</p><pre><code>  class Foo {    const Foo([arg]);  }  @Foo(anArg)  class A { ... }  @Foo()  class B { ... }</code></pre><h4 id="使用小写加下划线来命名库和源文件"><a href="#使用小写加下划线来命名库和源文件" class="headerlink" title="使用小写加下划线来命名库和源文件"></a>使用小写加下划线来命名库和源文件</h4><pre><code>  library peg_parser.source_scanner;  import &#39;file_system.dart&#39;;  import &#39;slider_menu.dart&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  library pegparser.SourceScanner;  import &#39;file-system.dart&#39;;  import &#39;SliderMenu.dart&#39;;</code></pre><h4 id="使用小写加下划线来命名导入前缀"><a href="#使用小写加下划线来命名导入前缀" class="headerlink" title="使用小写加下划线来命名导入前缀"></a>使用小写加下划线来命名导入前缀</h4><pre><code>  import &#39;dart:math&#39; as math;  import &#39;package:angular_components/angular_components&#39;      as angular_components;  import &#39;package:js/js.dart&#39; as js;</code></pre><p>不推荐如下写法：</p><pre><code>  import &#39;dart:math&#39; as Math;  import &#39;package:angular_components/angular_components&#39;      as angularComponents;  import &#39;package:js/js.dart&#39; as JS;</code></pre><h4 id="使用小驼峰法命名其他标识符"><a href="#使用小驼峰法命名其他标识符" class="headerlink" title="使用小驼峰法命名其他标识符"></a>使用小驼峰法命名其他标识符</h4><pre><code>  var item;  HttpRequest httpRequest;  void align(bool clearItems) {    // ...  }</code></pre><h4 id="优先使用小驼峰法作为常量命名"><a href="#优先使用小驼峰法作为常量命名" class="headerlink" title="优先使用小驼峰法作为常量命名"></a>优先使用小驼峰法作为常量命名</h4><pre><code>  const pi = 3.14;  const defaultTimeout = 1000;  final urlScheme = RegExp(&#39;^([a-z]+):&#39;);  class Dice {    static final numberGenerator = Random();  }</code></pre><p>不推荐如下写法：</p><pre><code>  const PI = 3.14;  const DefaultTimeout = 1000;  final URL_SCHEME = RegExp(&#39;^([a-z]+):&#39;);  class Dice {    static final NUMBER_GENERATOR = Random();  }</code></pre><h4 id="不使用前缀字母"><a href="#不使用前缀字母" class="headerlink" title="不使用前缀字母"></a>不使用前缀字母</h4><p>因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。</p><pre><code>  defaultTimeout</code></pre><p>不推荐如下写法：</p><pre><code>  kDefaultTimeout</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p><h4 id="在其他引入之前引入所需的dart库"><a href="#在其他引入之前引入所需的dart库" class="headerlink" title="在其他引入之前引入所需的dart库"></a>在其他引入之前引入所需的dart库</h4><pre><code>  import &#39;dart:async&#39;;  import &#39;dart:html&#39;;  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;</code></pre><h4 id="在相对引入之前先引入在包中的库"><a href="#在相对引入之前先引入在包中的库" class="headerlink" title="在相对引入之前先引入在包中的库"></a>在相对引入之前先引入在包中的库</h4><pre><code>  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;  import &#39;util.dart&#39;;</code></pre><h4 id="第三方包的导入先于其他包"><a href="#第三方包的导入先于其他包" class="headerlink" title="第三方包的导入先于其他包"></a>第三方包的导入先于其他包</h4><pre><code>  import &#39;package:bar/bar.dart&#39;;  import &#39;package:foo/foo.dart&#39;;  import &#39;package:my_package/util.dart&#39;;</code></pre><h4 id="在所有导入之后，在单独的部分中指定导出"><a href="#在所有导入之后，在单独的部分中指定导出" class="headerlink" title="在所有导入之后，在单独的部分中指定导出"></a>在所有导入之后，在单独的部分中指定导出</h4><pre><code>  import &#39;src/error.dart&#39;;  import &#39;src/foo_bar.dart&#39;;  export &#39;src/error.dart&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  import &#39;src/error.dart&#39;;  export &#39;src/error.dart&#39;;  import &#39;src/foo_bar.dart&#39;;</code></pre><h3 id="所有流控制结构，请使用大括号"><a href="#所有流控制结构，请使用大括号" class="headerlink" title="所有流控制结构，请使用大括号"></a>所有流控制结构，请使用大括号</h3><p>这样做可以避免悬浮的else问题</p><pre><code>  if (isWeekDay) {    print(&#39;Bike to work!&#39;);  } else {    print(&#39;Go dancing or read a book!&#39;);  }</code></pre><h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号</p><pre><code>  if (arg == null) return defaultValue;</code></pre><p>如果流程体超出了一行需要分划请使用大括号：</p><pre><code>  if (overflowChars != other.overflowChars) {    return overflowChars &lt; other.overflowChars;  }</code></pre><p>不推荐如下写法：</p><pre><code>  if (overflowChars != other.overflowChars)    return overflowChars &lt; other.overflowChars;</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="要像句子一样格式化"><a href="#要像句子一样格式化" class="headerlink" title="要像句子一样格式化"></a>要像句子一样格式化</h3><p>除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。</p><pre><code>  greet(name) {    // Assume we have a valid name.    print(&#39;Hi, $name!&#39;);  }</code></pre><p>不推荐如下写法：</p><pre><code>  greet(name) {    /* Assume we have a valid name. */    print(&#39;Hi, $name!&#39;);  }</code></pre><p>可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用//</p><h3 id="Doc注释"><a href="#Doc注释" class="headerlink" title="Doc注释"></a>Doc注释</h3><p>使用///文档注释来记录成员和类型。</p><p>使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。</p><pre><code>  /// The number of characters in this chunk when unsplit.  int get length =&gt; ...</code></pre><blockquote><p>由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/<strong>…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/</strong>和<em>/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用</em>标记列表项的项目符号列表。</p></blockquote><h3 id="考虑为私有api编写文档注释"><a href="#考虑为私有api编写文档注释" class="headerlink" title="考虑为私有api编写文档注释"></a>考虑为私有api编写文档注释</h3><p>Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员</p><h4 id="用一句话总结开始doc注释"><a href="#用一句话总结开始doc注释" class="headerlink" title="用一句话总结开始doc注释"></a>用一句话总结开始doc注释</h4><p>以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。</p><pre><code>/// Deletes the file at [path] from the file system.void delete(String path) {  ...}</code></pre><p>不推荐如下写法：</p><pre><code>  /// Depending on the state of the file system and the user&#39;s permissions,  /// certain operations may or may not be possible. If there is no file at  /// [path] or it can&#39;t be accessed, this function throws either [IOError]  /// or [PermissionError], respectively. Otherwise, this deletes the file.  void delete(String path) {    ...  }</code></pre><h4 id="“doc注释”的第一句话分隔成自己的段落"><a href="#“doc注释”的第一句话分隔成自己的段落" class="headerlink" title="“doc注释”的第一句话分隔成自己的段落"></a>“doc注释”的第一句话分隔成自己的段落</h4><p>在第一个句子之后添加一个空行，把它分成自己的段落</p><pre><code>  /// Deletes the file at [path].  ///  /// Throws an [IOError] if the file could not be found. Throws a  /// [PermissionError] if the file is present but could not be deleted.  void delete(String path) {    ...  }</code></pre><h2 id="Flutter-Go-使用参考"><a href="#Flutter-Go-使用参考" class="headerlink" title="Flutter_Go 使用参考"></a>Flutter_Go 使用参考</h2><h3 id="库的引用"><a href="#库的引用" class="headerlink" title="库的引用"></a>库的引用</h3><p>flutter go 中，导入lib下文件库，统一指定包名，避免过多的<code>../../</code></p><pre><code>package:flutter_go/</code></pre><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="使用相邻字符串连接字符串文字"><a href="#使用相邻字符串连接字符串文字" class="headerlink" title="使用相邻字符串连接字符串文字"></a>使用相邻字符串连接字符串文字</h4><p>如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。</p><pre><code>raiseAlarm(    &#39;ERROR: Parts of the spaceship are on fire. Other &#39;    &#39;parts are overrun by martians. Unclear which are which.&#39;);</code></pre><p>不推荐如下写法:</p><pre><code>raiseAlarm(&#39;ERROR: Parts of the spaceship are on fire. Other &#39; +    &#39;parts are overrun by martians. Unclear which are which.&#39;);</code></pre><h4 id="优先使用模板字符串"><a href="#优先使用模板字符串" class="headerlink" title="优先使用模板字符串"></a>优先使用模板字符串</h4><pre><code>&#39;Hello, $name! You are ${year - birth} years old.&#39;;</code></pre><h4 id="在不需要的时候，避免使用花括号"><a href="#在不需要的时候，避免使用花括号" class="headerlink" title="在不需要的时候，避免使用花括号"></a>在不需要的时候，避免使用花括号</h4><pre><code>  &#39;Hi, $name!&#39;  &quot;Wear your wildest $decade&#39;s outfit.&quot;</code></pre><p>不推荐如下写法：</p><pre><code>  &#39;Hello, &#39; + name + &#39;! You are &#39; + (year - birth).toString() + &#39; y...&#39;;</code></pre><p>不推荐如下写法：</p><pre><code>  &#39;Hi, ${name}!&#39;  &quot;Wear your wildest ${decade}&#39;s outfit.&quot;</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="尽可能使用集合字面量"><a href="#尽可能使用集合字面量" class="headerlink" title="尽可能使用集合字面量"></a>尽可能使用集合字面量</h4><p>如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。</p><pre><code>  var points = [];  var addresses = {};  var lines = &lt;Lines&gt;[];</code></pre><p>不推荐如下写法：</p><pre><code>  var points = List();  var addresses = Map();</code></pre><h4 id="不要使用-length查看集合是否为空"><a href="#不要使用-length查看集合是否为空" class="headerlink" title="不要使用.length查看集合是否为空"></a>不要使用.length查看集合是否为空</h4><pre><code>if (lunchBox.isEmpty) return &#39;so hungry...&#39;;if (words.isNotEmpty) return words.join(&#39; &#39;);</code></pre><p>不推荐如下写法：</p><pre><code>  if (lunchBox.length == 0) return &#39;so hungry...&#39;;  if (!words.isEmpty) return words.join(&#39; &#39;);</code></pre><h4 id="考虑使用高阶方法转换序列"><a href="#考虑使用高阶方法转换序列" class="headerlink" title="考虑使用高阶方法转换序列"></a>考虑使用高阶方法转换序列</h4><p>如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性</p><pre><code>  var aquaticNames = animals      .where((animal) =&gt; animal.isAquatic)      .map((animal) =&gt; animal.name);</code></pre><h4 id="避免使用带有函数字面量的Iterable-forEach"><a href="#避免使用带有函数字面量的Iterable-forEach" class="headerlink" title="避免使用带有函数字面量的Iterable.forEach()"></a>避免使用带有函数字面量的Iterable.forEach()</h4><p>在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。</p><pre><code>for (var person in people) {  ...}</code></pre><p>不推荐如下写法：</p><pre><code>  people.forEach((person) {    ...  });</code></pre><h4 id="不要使用List-from-，除非打算更改结果的类型"><a href="#不要使用List-from-，除非打算更改结果的类型" class="headerlink" title="不要使用List.from()，除非打算更改结果的类型"></a>不要使用List.from()，除非打算更改结果的类型</h4><p>给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表</p><pre><code>var copy1 = iterable.toList();var copy2 = List.from(iterable);</code></pre><p>明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数</p><pre><code>// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;int&gt;&quot;:print(iterable.toList().runtimeType);</code></pre><pre><code>// Creates a List&lt;int&gt;:var iterable = [1, 2, 3];// Prints &quot;List&lt;dynamic&gt;&quot;:print(List.from(iterable).runtimeType);</code></pre><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><h4 id="使用-将命名参数与其默认值分割开"><a href="#使用-将命名参数与其默认值分割开" class="headerlink" title="使用=将命名参数与其默认值分割开"></a>使用=将命名参数与其默认值分割开</h4><p>由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。</p><pre><code>  void insert(Object item, {int at = 0}) { ... }</code></pre><p>不推荐如下写法：</p><pre><code>  void insert(Object item, {int at: 0}) { ... }</code></pre><h4 id="不要使用显式默认值null"><a href="#不要使用显式默认值null" class="headerlink" title="不要使用显式默认值null"></a>不要使用显式默认值null</h4><p>如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它</p><pre><code>void error([String message]) {  stderr.write(message ?? &#39;\n&#39;);}</code></pre><p>不推荐如下写法:</p><pre><code>void error([String message = null]) {  stderr.write(message ?? &#39;\n&#39;);}</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="不要显式地将变量初始化为空"><a href="#不要显式地将变量初始化为空" class="headerlink" title="不要显式地将变量初始化为空"></a>不要显式地将变量初始化为空</h4><p>在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null</p><pre><code>  int _nextId;  class LazyId {    int _id;    int get id {      if (_nextId == null) _nextId = 0;      if (_id == null) _id = _nextId++;      return _id;    }  }</code></pre><p>不推荐如下写法：</p><pre><code>  int _nextId = null;  class LazyId {    int _id = null;    int get id {      if (_nextId == null) _nextId = 0;      if (_id == null) _id = _nextId++;      return _id;    }  }</code></pre><h4 id="避免储存你能计算的东西"><a href="#避免储存你能计算的东西" class="headerlink" title="避免储存你能计算的东西"></a>避免储存你能计算的东西</h4><p>在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们:</p><p>应该避免的写法：</p><pre><code>  class Circle {    num radius;    num area;    num circumference;    Circle(num radius)        : radius = radius,          area = pi * radius * radius,          circumference = pi * 2.0 * radius;  }</code></pre><p>如上代码问题：</p><ul><li>浪费内存</li><li>缓存的问题是无效——如何知道何时缓存过期需要重新计算？</li></ul><p>推荐的写法如下：</p><pre><code>  class Circle {    num radius;    Circle(this.radius);    num get area =&gt; pi * radius * radius;    num get circumference =&gt; pi * 2.0 * radius;  }</code></pre><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="不要把不必要地将字段包装在getter和setter中"><a href="#不要把不必要地将字段包装在getter和setter中" class="headerlink" title="不要把不必要地将字段包装在getter和setter中"></a>不要把不必要地将字段包装在getter和setter中</h4><p>不推荐如下写法：</p><pre><code>  class Box {    var _contents;    get contents =&gt; _contents;    set contents(value) {      _contents = value;    }  }</code></pre><h4 id="优先使用final字段来创建只读属性"><a href="#优先使用final字段来创建只读属性" class="headerlink" title="优先使用final字段来创建只读属性"></a>优先使用final字段来创建只读属性</h4><p>尤其对于 <code>StatelessWidget</code></p><h4 id="在不需要的时候不要用this"><a href="#在不需要的时候不要用this" class="headerlink" title="在不需要的时候不要用this"></a>在不需要的时候不要用this</h4><p>不推荐如下写法：</p><pre><code>  class Box {    var value;    void clear() {      this.update(null);    }    void update(value) {      this.value = value;    }  }</code></pre><p>推荐如下写法：</p><pre><code>  class Box {    var value;    void clear() {      update(null);    }    void update(value) {      this.value = value;    }  }</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="尽可能使用初始化的形式"><a href="#尽可能使用初始化的形式" class="headerlink" title="尽可能使用初始化的形式"></a>尽可能使用初始化的形式</h4><p>不推荐如下写法：</p><pre><code>  class Point {    num x, y;    Point(num x, num y) {      this.x = x;      this.y = y;    }  }</code></pre><p>推荐如下写法：</p><pre><code>class Point {  num x, y;  Point(this.x, this.y);}</code></pre><h4 id="不要使用new"><a href="#不要使用new" class="headerlink" title="不要使用new"></a>不要使用new</h4><p>Dart2使new 关键字可选</p><p>推荐写法：</p><pre><code>  Widget build(BuildContext context) {    return Row(      children: [        RaisedButton(          child: Text(&#39;Increment&#39;),        ),        Text(&#39;Click!&#39;),      ],    );  }</code></pre><p>不推荐如下写法：</p><pre><code>  Widget build(BuildContext context) {    return new Row(      children: [        new RaisedButton(          child: new Text(&#39;Increment&#39;),        ),        new Text(&#39;Click!&#39;),      ],    );  }</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="优先使用async-await代替原始的futures"><a href="#优先使用async-await代替原始的futures" class="headerlink" title="优先使用async/await代替原始的futures"></a>优先使用async/await代替原始的futures</h4><p>async/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。</p><pre><code>  Future&lt;int&gt; countActivePlayers(String teamName) async {    try {      var team = await downloadTeam(teamName);      if (team == null) return 0;      var players = await team.roster;      return players.where((player) =&gt; player.isActive).length;    } catch (e) {      log.error(e);      return 0;    }  }</code></pre><h4 id="当异步没有任何用处时，不要使用它"><a href="#当异步没有任何用处时，不要使用它" class="headerlink" title="当异步没有任何用处时，不要使用它"></a>当异步没有任何用处时，不要使用它</h4><p>如果可以在不改变函数行为的情况下省略异步，那么就这样做。、</p><pre><code>  Future afterTwoThings(Future first, Future second) {    return Future.wait([first, second]);  }</code></pre><p>不推荐写法：</p><pre><code>  Future afterTwoThings(Future first, Future second) async {    return Future.wait([first, second]);  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://github.com/alibaba/flutter-go/blob/develop/Flutter_Go%20%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android 原生项目集成 Flutter 混合开发</title>
    <link href="https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android%20%E5%8E%9F%E7%94%9F%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Flutter%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>https://yangxiaoge.github.io/2019/02/28/2019-02-28-Android 原生项目集成 Flutter 混合开发/</id>
    <published>2019-02-28T09:09:06.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 <a href="https://github.com/yangxiaoge/wanandroid_flutter" target="_blank" rel="noopener">MuMuxi-Flutter</a> 版本，<br>但是现在想要把 Flutter 使用在现有的项目中，改如何操作呢？哈哈，Google 官方已经考虑到了这个问题，并且给出了集成方案 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">Add-Flutter-to-existing-apps</a>。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>新建一个 <code>Flutter module</code>，使用命令：<code>flutter create -t module {moduleName}</code>，其中 <code>moduleName</code> 我这里取名 <code>xinhua_media_flutter_module</code></li><li>随后将 <code>Flutter module</code> 推送至<code>git</code> 仓库，git 推送我就不累赘了，拿到仓库地址 <a href="https://gitee.com/xxx/xinhua_media_flutter_module.git" target="_blank" rel="noopener">https://gitee.com/xxx/xinhua_media_flutter_module.git</a></li><li>在<code>原生</code> Android 项目更目录添加 <code>git submodule</code><pre><code>git submodule add {Flutter module 仓库地址}, 即上面拿到的仓库地址 https://gitee.com/xxx/xinhua_media_flutter_module.gitgit submodule update</code></pre>此时项目结构如下图：<br><img src="https://github.com/yangxiaoge/PersonResources/blob/master/flutter/%E5%8E%9F%E7%94%9F%E9%9B%86%E6%88%90flutter%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true" alt="原生集成flutter工程目录结构.png"></li><li>在原生项目<code>根目录</code> <code>settings.gradle</code> 中 <code>include &#39;:app&#39;</code> 下面添加如下配置<pre><code>setBinding(new Binding([gradle: this]))evaluate(new File(     &#39;xinhua_media_flutter_module/.android/include_flutter.groovy&#39;))</code></pre></li><li>原生项目 <code>app</code> 目录下的 <code>build.gradle</code> 文件中添加 <code>xinhua_media_flutter_module</code> 库的依赖<pre><code>// MyApp/app/build.gradleimplementation project(&#39;:flutter&#39;)</code></pre></li><li>在原生项目中新建一个 <code>FlutterActivity</code> 用来加载 Flutter mudule 页面入口<pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // &quot;flutter_page&quot; 是路由名称，在 Flutter `main.dart` 页面中需要用到 FlutterView seuicSettingPage = Flutter.createView(this, getLifecycle(), &quot;flutter_page&quot;); FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT); // 加 flutterview 添加到布局中 addContentView(seuicSettingPage, layoutParams);}</code></pre></li><li>在 <code>xinhua_media_flutter_module</code> lib 下的 <code>main.dart</code> 文件中添加逻辑<br><code>`</code><br>// xinhua_media_flutter_module/lib/main.dart<br>// 以下 “flutter_page” 判断路由名称，MyApp 是自定义的组件，接下来就可以开发自己的功能逻辑。<br>// 如果发现 AS 不识别 Dart 语言，设置中勾选 <code>Enable Dart support</code><br>import ‘dart:ui’;<br>import ‘package:flutter/material.dart’;</li></ol><p>void main() =&gt; runApp(_widgetForRoute(window.defaultRouteName));</p><p>Widget _widgetForRoute(String route) {<br>  switch (route) {<br>    case ‘flutter_page’:<br>      return MyApp();<br>    default:<br>      return Center(<br>        child: Text(‘Unknown route: $route’, textDirection: TextDirection.ltr),<br>      );<br>  }<br>}<br><code>`</code></p><ol start="8"><li>然后<code>运行</code> Android 原生项目，</li></ol><p>如果混合项目想要使用 flutter <code>hot start/reload</code>，需要 cd 进入 <code>xinhua_media_flutter_module</code> 目录，然后执行 <code>flutter attach</code>，<br>然后打开 flutter 的页面就能正常使用 Hot restart/reload 啦，好了 Android 集成 flutter 到此结束，iOS 集成可以看 Google 官方教程。</p><ol start="9"><li>emmmmm，Flutter 真香😀😆😉😎😘🤩 </li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><code>Flutter</code> 作为 Google 的亲儿子，它还是「Google 下一代操作系统」<code>Fuchsia OS</code> 的内置 UI SDK ！2019 年将是 Flutter 的爆发期，<a href="https://github.com/search?q=flutter" target="_blank" rel="noopener">Github</a> 上已经有很多<br>国人开发的相关插件以及项目了，接下来我也会写一些跟自己 Flutter 项目相关的技术文章！加油！📚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本来最近对 Flutter 的热衷程度日益增长，也使用 Flutter 开发了应用 &lt;a href=&quot;https://github.com/
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter | 状态管理拓展篇——RxDart</title>
    <link href="https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%8B%93%E5%B1%95%E7%AF%87-RxDart/"/>
    <id>https://yangxiaoge.github.io/2019/02/19/2019-02-19-Flutter状态管理拓展篇-RxDart/</id>
    <published>2019-02-19T11:22:01.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p><strong>元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！</strong></p><blockquote><ul><li>原文地址：<a href="https://juejin.im/post/5bcea438e51d4536c65d2232" target="_blank" rel="noopener">https://juejin.im/post/5bcea438e51d4536c65d2232</a></li><li>原文作者：<a href="https://juejin.im/user/5b5d45f4e51d453526175c06/posts" target="_blank" rel="noopener">Vadaski</a></li></ul></blockquote><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><h3 id="ReactiveX-是什么"><a href="#ReactiveX-是什么" class="headerlink" title="ReactiveX 是什么"></a>ReactiveX 是什么</h3><p>ReactiveX 是一个强大的库，用于通过使用<strong>可观察序列</strong>来编写<strong>异步</strong>和<strong>基于事件</strong>的程序。它突破了<strong>语言</strong>和<strong>平台</strong>的限制，让我们编写异步程序就像在自家花园散步那样 easy。我相信你一定会爱上它！</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/24/166a563fd4eb5800?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665e4f1257f4e00?imageslim" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;元宵佳节齐欢乐，月圆时分大团圆。开开心心一年头，健健康康一年尾，祝身体健康，万事如意！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5bcea438e51d4
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android数据库高手秘籍（LitePal）</title>
    <link href="https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E6%89%8B%E7%A7%98%E7%B1%8D%EF%BC%88LitePal%EF%BC%89/"/>
    <id>https://yangxiaoge.github.io/2018/08/23/2018-8-23-Android数据库高手秘籍（LitePal）/</id>
    <published>2018-08-23T15:28:49.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自 <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">郭霖 CSDN</a></p><p>Android 数据库高手秘籍： <a href="https://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/android-database-pro.html</a></p><p>本专栏主要讲解 Android 数据库相关的高级技术。其中包括了 SQLite 中一些不为人知的使用技巧，以及全面剖析 LitePal 这款 Android 数据库框架的所有用法。LitePal 项目地址是: <a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p><h3 id="Android-数据库高手秘籍-零-——前言"><a href="#Android-数据库高手秘籍-零-——前言" class="headerlink" title="Android 数据库高手秘籍 (零)——前言"></a><a href="https://blog.csdn.net/guolin_blog/article/details/38083103" target="_blank" rel="noopener">Android 数据库高手秘籍 (零)——前言</a></h3><h3 id="Android-数据库高手秘籍-一-——SQLite-命令"><a href="#Android-数据库高手秘籍-一-——SQLite-命令" class="headerlink" title="Android 数据库高手秘籍 (一)——SQLite 命令"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38461239" target="_blank" rel="noopener">Android 数据库高手秘籍 (一)——SQLite 命令</a></h3><h3 id="Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法"><a href="#Android-数据库高手秘籍-二-——创建表和-LitePal-的基本用法" class="headerlink" title="Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法"></a><a href="http://blog.csdn.net/guolin_blog/article/details/38556989" target="_blank" rel="noopener">Android 数据库高手秘籍 (二)——创建表和 LitePal 的基本用法</a></h3><h3 id="Android-数据库高手秘籍-三-——使用-LitePal-升级表"><a href="#Android-数据库高手秘籍-三-——使用-LitePal-升级表" class="headerlink" title="Android 数据库高手秘籍 (三)——使用 LitePal 升级表"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39151617" target="_blank" rel="noopener">Android 数据库高手秘籍 (三)——使用 LitePal 升级表</a></h3><h3 id="Android-数据库高手秘籍-四-——使用-LitePal-建立表关联"><a href="#Android-数据库高手秘籍-四-——使用-LitePal-建立表关联" class="headerlink" title="Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39207945" target="_blank" rel="noopener">Android 数据库高手秘籍 (四)——使用 LitePal 建立表关联</a></h3><h3 id="Android-数据库高手秘籍-五-——LitePal-的存储操作"><a href="#Android-数据库高手秘籍-五-——LitePal-的存储操作" class="headerlink" title="Android 数据库高手秘籍 (五)——LitePal 的存储操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/39345833" target="_blank" rel="noopener">Android 数据库高手秘籍 (五)——LitePal 的存储操作</a></h3><h3 id="Android-数据库高手秘籍-六-——LitePal-的修改和删除操作"><a href="#Android-数据库高手秘籍-六-——LitePal-的修改和删除操作" class="headerlink" title="Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40083685" target="_blank" rel="noopener">Android 数据库高手秘籍 (六)——LitePal 的修改和删除操作</a></h3><h3 id="Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术"><a href="#Android-数据库高手秘籍-七-——体验-LitePal-的查询艺术" class="headerlink" title="Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40153833" target="_blank" rel="noopener">Android 数据库高手秘籍 (七)——体验 LitePal 的查询艺术</a></h3><h3 id="Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数"><a href="#Android-数据库高手秘籍-八-——使用-LitePal-的聚合函数" class="headerlink" title="Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数"></a><a href="http://blog.csdn.net/guolin_blog/article/details/40614197" target="_blank" rel="noopener">Android 数据库高手秘籍 (八)——使用 LitePal 的聚合函数</a></h3><h3 id="Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧"><a href="#Android-数据库高手秘籍-九-——赶快使用-LitePal-2-0-版本吧" class="headerlink" title="Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧"></a><a href="http://blog.csdn.net/guolin_blog/article/details/80586028" target="_blank" rel="noopener">Android 数据库高手秘籍 (九)——赶快使用 LitePal 2.0 版本吧</a></h3><h3 id="LitePal-学习笔记-忽略字段，多数据库"><a href="#LitePal-学习笔记-忽略字段，多数据库" class="headerlink" title="LitePal 学习笔记 - 忽略字段，多数据库"></a><a href="https://www.jianshu.com/p/bc68e763c7a2" target="_blank" rel="noopener">LitePal 学习笔记 - 忽略字段，多数据库</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自 &lt;a href=&quot;https://blog.csdn.net/column/details/android-database-pro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郭霖 CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android 数
      
    
    </summary>
    
      <category term="数据库" scheme="https://yangxiaoge.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 常用设计模式</title>
    <link href="https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yangxiaoge.github.io/2018/08/22/2018-8-22-Android常用设计模式/</id>
    <published>2018-08-22T15:37:34.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式专栏： <a href="https://blog.csdn.net/lovelixue/article/category/7959476" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/category/7959476</a></p><p>代码 Github ：<a href="https://github.com/sdgSnow/DesignPattern" target="_blank" rel="noopener">https://github.com/sdgSnow/DesignPattern</a></p><h3 id="Android-常用设计模式（一、单例模式）："><a href="#Android-常用设计模式（一、单例模式）：" class="headerlink" title="Android 常用设计模式（一、单例模式）："></a><a href="https://blog.csdn.net/lovelixue/article/details/81940996" target="_blank" rel="noopener">Android 常用设计模式（一、单例模式）</a>：</h3><ol><li>饿汉式</li><li>懒汉式</li><li>双重锁模式</li></ol><h3 id="Android-常用设计模式（二、建造者模式）"><a href="#Android-常用设计模式（二、建造者模式）" class="headerlink" title="Android 常用设计模式（二、建造者模式）:"></a><a href="https://blog.csdn.net/lovelixue/article/details/81944629" target="_blank" rel="noopener">Android 常用设计模式（二、建造者模式）</a>:</h3><pre><code>//通过builder创建一个Person对象Person person = new Person.PersonBuilder(&quot;小羊羊&quot;)        .setAge(18)        .setSex(&quot;男&quot;)        .setIdentity(&quot;码农&quot;)        .build();</code></pre><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计模式专栏： &lt;a href=&quot;https://blog.csdn.net/lovelixue/article/category/7959476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lovelixue
      
    
    </summary>
    
      <category term="设计模式" scheme="https://yangxiaoge.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java 字节数组 序列化 与 C# 字节数组 序列化差异性</title>
    <link href="https://yangxiaoge.github.io/2018/08/16/2018-8-16-java%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E4%B8%8EC%E4%BA%95%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%AE%E5%BC%82%E6%80%A7/"/>
    <id>https://yangxiaoge.github.io/2018/08/16/2018-8-16-java字节数组与C井字节数组序列化差异性/</id>
    <published>2018-08-16T19:40:05.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WRAP）字符串；</p><p>因此： java 这边需要手动将 byte[] 转成  Base64字符串:<code>Base64.encodeToString(bytes, Base64.NO_WRAP);</code><br>java 我用的是 <code>Gson</code> 序列化， 客户的 .NET 代码用的是 <code>JsonConvert.SerializeObject(obj)</code>。</p><p><img src="https://img-blog.csdn.net/20180816185942460?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180816190114298?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25uOTkxOTI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目遇到一个大坑（接口文档竟然说要传 byte[]，其实应该传 string，还好我要要了一个 C# 代码，差点被坑！！！），需要上传一个 byte[] 数组给后台。 java byte[] 序列化之后还是 byte[], 然而 C# 则变成了 Base64（NO_WR
      
    
    </summary>
    
    
      <category term="byte，C#" scheme="https://yangxiaoge.github.io/tags/byte%EF%BC%8CC/"/>
    
  </entry>
  
  <entry>
    <title>数据库获取 Android 短信</title>
    <link href="https://yangxiaoge.github.io/2018/08/14/2018-8-14-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%B7%E5%8F%96Android%E7%9F%AD%E4%BF%A1/"/>
    <id>https://yangxiaoge.github.io/2018/08/14/2018-8-14-数据库获取Android短信/</id>
    <published>2018-08-14T14:43:05.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读取短信需要的权限"><a href="#读取短信需要的权限" class="headerlink" title="读取短信需要的权限"></a>读取短信需要的权限</h3><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;</code></pre><h3 id="读取数据库短信方法"><a href="#读取数据库短信方法" class="headerlink" title="读取数据库短信方法"></a>读取数据库短信方法</h3><pre><code>   public static List&lt;Map&lt;String, String&gt;&gt; getSmsCode() {        String lastTime = &quot;1534228493681&quot;; // 时间        Log.i(&quot;SMSUtil&quot;, &quot;开始获取短信&quot;);        Cursor cursor = null;        // 添加异常捕捉        try {            //第一种， 查询所有短信            cursor = App.mContext.getContentResolver().query(                    Uri.parse(&quot;content://sms&quot;),                    new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;body&quot;, &quot;date&quot;, &quot;person&quot;, &quot;type&quot;},                    null, null, &quot;date desc&quot;);            //第二种， 通过查询条件， 例如：date &gt; lastTime， 过滤数据            /*cursor = App.mContext.getContentResolver().query(                        Uri.parse(&quot;content://sms&quot;),                        new String[]{&quot;_id&quot;, &quot;address&quot;, &quot;body&quot;, &quot;date&quot;, &quot;person&quot;, &quot;type&quot;},                        &quot;date &gt; ?&quot;, new String[]{lastTime}, &quot;date desc&quot;);*/            if (cursor != null) {                List&lt;Map&lt;String, String&gt;&gt; smsList = new ArrayList&lt;&gt;();                while (cursor.moveToNext()) {                    String body = cursor.getString(cursor.getColumnIndex(&quot;body&quot;));// 在这里获取短信信息                    String person = cursor.getString(cursor.getColumnIndex(&quot;person&quot;)); // 陌生人为null                    String address = cursor.getString(cursor.getColumnIndex(&quot;address&quot;));                    String _id = cursor.getString(cursor.getColumnIndex(&quot;_id&quot;));                    String date = cursor.getString(cursor.getColumnIndex(&quot;date&quot;));                    String type = cursor.getString(cursor.getColumnIndex(&quot;type&quot;));                    HashMap&lt;String, String&gt; smsMap = new HashMap&lt;&gt;();                    smsMap.put(&quot;body&quot;, body);                    smsMap.put(&quot;person&quot;, person);                    smsMap.put(&quot;address&quot;, address);                    smsMap.put(&quot;_id&quot;, _id);                    smsMap.put(&quot;date&quot;, date);                    smsList.add(smsMap);                    Log.i(&quot;test_sms&quot;, &quot;body = &quot; + body + &quot;  person = &quot; + person + &quot;  address = &quot; + address                            + &quot;  date = &quot; + date + &quot;  type = &quot; + type);                }                // 返回所有的短信                return smsList;            }        } catch (Exception e) {            e.printStackTrace();            Log.i(&quot;test_sms&quot;, &quot;e = &quot; + e.getMessage());        } finally {            if (cursor != null) {                cursor.close();            }        }        return null;    }</code></pre><h3 id="URI-主要有："><a href="#URI-主要有：" class="headerlink" title="URI 主要有："></a>URI 主要有：</h3><pre><code>content://sms/             所有短信 (本示例用的所有)content://sms/inbox        收件箱content://sms/sent         已发送content://sms/draft        草稿content://sms/outbox       发件箱content://sms/failed       发送失败content://sms/queued       待发送列表</code></pre><h3 id="SMS-主要结构："><a href="#SMS-主要结构：" class="headerlink" title="SMS 主要结构："></a>SMS 主要结构：</h3><pre><code>_id =&gt; 短消息序号 如 100  thread_id =&gt; 对话的序号 如 100  address =&gt; 发件人地址，手机号. 如 + 8613811810000  person =&gt; 发件人，返回一个数字就是联系人列表里的序号，陌生人为 null  date =&gt; 日期  long 型。如 1256539465022  protocol =&gt; 协议 0 SMS_RPOTO, 1 MMS_PROTO   read =&gt; 是否阅读 0 未读， 1 已读   status =&gt; 状态 -1 接收，0 complete, 64 pending, 128 failed   type =&gt; 类型 1 是接收到的，2 是已发出          (ALL    = 0; 所有    INBOX  = 1; 收件箱    SENT   = 2; 已发送    DRAFT  = 3; 草稿    OUTBOX = 4; 发件箱    FAILED = 5; 失败    QUEUED = 6;)待发送body =&gt; 短消息内容   service_center =&gt; 短信服务中心号码编号。如 + 8613800755500  </code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/ithomer/article/details/7328321" target="_blank" rel="noopener">https://blog.csdn.net/ithomer/article/details/7328321</a><br><a href="https://blog.csdn.net/laichao1112/article/details/6436511" target="_blank" rel="noopener">https://blog.csdn.net/laichao1112/article/details/6436511</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读取短信需要的权限&quot;&gt;&lt;a href=&quot;#读取短信需要的权限&quot; class=&quot;headerlink&quot; title=&quot;读取短信需要的权限&quot;&gt;&lt;/a&gt;读取短信需要的权限&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;
      
    
    </summary>
    
    
      <category term="Android，SMS" scheme="https://yangxiaoge.github.io/tags/Android%EF%BC%8CSMS/"/>
    
  </entry>
  
  <entry>
    <title>（译）为什么每个 Android 开发者都应该尝试 Flutter</title>
    <link href="https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/"/>
    <id>https://yangxiaoge.github.io/2018/08/06/2018-8-6-why-every-android-developer-should-try-out-flutter/</id>
    <published>2018-08-06T18:10:08.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f" target="_blank" rel="noopener">Why every Android Developer should try out Flutter</a></li><li>原文作者：<a href="https://proandroiddev.com/@aaronoe?source=post_header_lockup" target="_blank" rel="noopener">Aaron Oertel</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>掘金链接：<a href="https://juejin.im/post/5b5e70ffe51d4518e311b63d" target="_blank" rel="noopener">https://juejin.im/post/5b5e70ffe51d4518e311b63d</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/why-every-android-developer-should-try-out-flutter.md</a></li><li>译者：<a href="https://github.com/ALVINYEH" target="_blank" rel="noopener">ALVINYEH</a></li><li>校对者：<a href="https://github.com/DateBro" target="_blank" rel="noopener">DateBro</a></li></ul></blockquote><h1 id="为什么每个-Android-开发者都应该尝试-Flutter"><a href="#为什么每个-Android-开发者都应该尝试-Flutter" class="headerlink" title="为什么每个 Android 开发者都应该尝试 Flutter"></a>为什么每个 Android 开发者都应该尝试 Flutter</h1><p>几个月前，我写过一篇题为“<a href="https://juejin.im/post/5add65c46fb9a07aa541e97e" target="_blank" rel="noopener">为什么 Flutter 能最好地改变移动开发</a>”的文章。虽然已经过去了一段时间，但是我对 Flutter 的热爱依然非常强烈；事实上，当我继续使用它时，我意识到了我之前忽略了 Flutter 独特方面的重要性。不要误会我的意思 —— 我仍然认为 Flutter 最强大的一点就是如何解决跨平台开发的许多问题。但最近我开始关注移动开发发展的更多领域，特别是声明性用户界面的概念。</p><p><img src="https://cdn-images-1.medium.com/max/800/0*pV87QzKfowqgkEkd" alt></p><p>摄影者：来自 <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Unsplash</a> 的 <a href="https://unsplash.com/@licole?utm_source=medium&amp;utm_medium=referral" target="_blank" rel="noopener">Chris Charles</a>。</p><p>我相信你已经听过一系列关于为什么 Android 开发者应该关注 Flutter 的若干论据（如果你还没有看过，请让我谦逊地建议你瞧瞧<a href="https://proandroiddev.com/why-flutter-will-change-mobile-development-for-the-best-c249f71fa63c" target="_blank" rel="noopener">这个</a>），但是我想指出一个我还没有真正解决的大问题，那就是 Flutter 可以让你对 App 开发有完全不同的看法。首先，你的应用本身将采用不同的方式构建 —— 但更重要的是，实际的 UI 开发通过将其合并到你的 Dart 代码（而不是 XML）中而被推到前台，因此使它成为了“一等公民”。一旦你的 UI 代码突然出现在一种非标记语言中，你就会意识到你突然有了构建应用的可能性。说实话，在使用 Flutter 之后，我开始讨厌在 Android 上编写 UI 代码；因为在 Android 中步骤更加繁琐，虽然你仍然可以使用数据绑定等工具构建响应式应用，但它实际上比 Flutter 中要花费更多的时间。</p><p>当你考虑在 Android 中整合动画和其他动态数据时，使用 Flutter 的论点变得更加有力。整合动画可能会不太方便，有时你可能不得不拒绝设计师的要求，因为要实现他们的需求太难了。谢天谢地，Flutter 改变了这一切。如果你一直在关注 Flutter，你可能已经从 <a href="https://medium.com/fluttery" target="_blank" rel="noopener">Fluttery</a> 听说过 <strong>Flutter 挑战</strong>。这些挑战展示了构建具有大量自定义组件和精美设计（包括动画）的复杂 UI 的快速和直观性。在 Android 上实现这样的东西会变得非常困难 —— 特别是因为与 Flutter 不同，Android 的视图基于继承而非组合，这使得构建视图变得更加复杂。</p><p>下面，让我们切入正题：使用 Flutter <strong>构建声明性 UI</strong>，这改变了 UI 开发的一切。现在也许你在想，<strong>Android 布局不也是以声明方式构建的吗？</strong>答案是肯定的，但事实不是。使用 XML 来定义布局让我们有了以声明方式定义布局的感觉，但如果你的视图是完全静态的，并且所有数据都是以 XML 格式设置的，那么这种感觉才真正成立。不幸的是，这种情况几乎从未发生过；一旦添加动态数据和类似列表之类的东西，你自然必须使用一些 Java / Kotlin 代码将数据绑定到视图。然后我们最终得到某种 ViewModel，它将数据设置为视图。想象一下，这就像在 Android 上调用 <code>textView.text =“Hello Medium！”</code> 一样。在 Flutter 上，这是完全不同的：你创建了一个包含某个状态的窗口组件类，然后根据该状态以声明方式定义你的布局。每当状态改变时，我们调用 <code>setState（）</code> 来重新渲染我们改变的组件树的部分。让我们看一下如何在 Flutter 中使用 API，并使用结果渲染一个 List：</p><pre><code>@overrideWidget build(BuildContext context) {  return new FutureBuilder&lt;Repositories&gt;(    future: apiClient.getUserRepositoriesFuture(username),    builder: (BuildContext context,         AsyncSnapshot&lt;Repositories&gt; snapshot) {      if (snapshot.hasError)        return new Center(child: new Text(&quot;Network error&quot;));      if (!snapshot.hasData)        return new Center(          child: new CircularProgressIndicator(),        );      return new ListView.builder(        itemCount: snapshot.data.nodes.length,        itemBuilder: (BuildContext context, int index) =&gt;            new RepoPreviewTile(              repository: snapshot.data.nodes[index],            ),      );    },  );}</code></pre><p>在这里，我们使用了 <code>FutureBuilder</code> 来等待网络调用（Future）的完成。一旦网络调用完成，出现结果或错误，<code>FutureBuilder</code> 组件会在内部调用 <code>setState</code> 来调用所提供的 <code>builder</code> 方法来重新渲染。正如你在这个例子中看到的，一切都是<strong>声明式的</strong>。在 Android 上做同样的事情通常需要一个被动的 XML 布局，然后需要一些其他类来手动设置状态，比如 Adapter 和视图模型。这种方法的问题在于，状态可能与屏幕上渲染的状态不同。这就是为什么我们希望拥有像 Flutter 为我们提供的那样的声明性布局。我们最终编写的代码要少得多，同时将状态绑定到要在屏幕上显示的内容。</p><p>有了这些声明性布局，我们也开始对架构进行了不同的思考。突然间，<strong>reactive</strong> 这个词出现了，我们谈论了更多的是关于状态管理的内容，而不是架构。有了 Flutter，像 MVP 和 MVVM 这样的架构已经没有多大有意义了；我们不再使用它们了，而是考虑状态如何流经我们的应用。状态突然成为讨论的一个重要部分，我们将投入越来越多精力去思考构建应用的新方法上。这对我们所有人来说都是一次新的旅程，有许多事情可以解决，但最重要的是，这是我们开阔视野的机会。</p><p>坦白地说，Flutter 也不只有阳光和彩虹。我目前正在与 Flutter 合作开展一个更大的项目来了解它的弱点，迄今为止我遇到的最大缺陷是缺乏基础设施。当我尝试使用 Graphql-API 时，这个问题就非常明显；虽然有库确实会这样做，但它们并没有接近 Android 与 Apollo 的关系。不过，好消息是，Flutter 迎头赶上只是时间的问题，在此期间扩展现有的库，甚至建立自己的库并不困难。请注意，你可能需要花一些时间投入在应用程序的基础设施中，而对于 Android 和 iOS 来说，情况通常并非如此 —— 毕竟，天下没有免费的午餐。</p><p>最后，我最近从使用 Flutter 中得到的最大启示之一就是，体验这种构建 UI 的声明方式以及它对状态管理的影响是非常有用的。我觉得 Flutter 太棒了；不过，我告诫你不要把它当作解决你所有问题的银弹，而应该是作为一种创新的工具，它可以比在 Android 上更快地构建漂亮的自定义 UI。更重要的是，它展示了强大的声明性布局功能，并让你将应用视为渲染状态，而不是非连贯性 Activity，视图和视图模型 —— 仅此而言，我强烈建议你尝试一下 Flutter。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://proandroiddev.com/why-every-android-developer-should-try-out-flutter-319ae710e97f&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://yangxiaoge.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Git clone 慢怎么办 - 配置代理</title>
    <link href="https://yangxiaoge.github.io/2018/08/03/2018-8-3-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>https://yangxiaoge.github.io/2018/08/03/2018-8-3-git配置代理/</id>
    <published>2018-08-03T17:23:35.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。</p><p>配置 Git 代理。</p><pre><code>// 查看当前代理设置git config --global http.proxy// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080git config --global http.proxy &#39;http://127.0.0.1:1080&#39;git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;/// 删除代理git config --global --unset http.proxy// 注意 `mac` 小飞机需要开启全局代理</code></pre><p>接下来尽情的使用 git 吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人是 macOS 系统，用的 ShadowsocksX-NG ，开了全局代理也无事于补，折腾了好一会儿找到了解决办法。&lt;/p&gt;
&lt;p&gt;配置 Git 代理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查看当前代理设置
git config --global http.proxy

      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何接入 VirtualAPK 插件框架</title>
    <link href="https://yangxiaoge.github.io/2018/07/25/2018-07-25%20-%20%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%20virtualapk%20%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    <id>https://yangxiaoge.github.io/2018/07/25/2018-07-25 - 如何接入 virtualapk 插件框架/</id>
    <published>2018-07-25T17:05:06.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/didi/VirtualAPK/raw/master/imgs/va.png" alt></p><p>封面图片来源: <a href="https://blog.csdn.net/byeweiyang/article/details/80127643" target="_blank" rel="noopener">https://blog.csdn.net/byeweiyang/article/details/80127643</a></p><p>话不多说，先上我的 Demo 地址：<a href="https://github.com/yangxiaoge/VirtualAPKDemo" target="_blank" rel="noopener">https://github.com/yangxiaoge/VirtualAPKDemo</a></p><p>本文转载：原文链接<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p>最近都在搞插件框架，为项目搭建用，之前集成了下阿里的 atlas，现在送上一篇滴滴的 virtualapk，就个人而言，滴滴的集成过程比阿里简单些，有兴趣的可以看看我 atlas 的：<a href="https://blog.csdn.net/lovelixue/article/details/81141213" target="_blank" rel="noopener">https://blog.csdn.net/lovelixue/article/details/81141213</a></p><p><em>废话不多说，上过程</em></p><h3 id="1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写"><a href="#1-环境配置，很重要，官方有规定-gradle-使用哪个之类的，我用的不同，我就基于我的来写" class="headerlink" title="1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写"></a>1. 环境配置，很重要，官方有规定 gradle 使用哪个之类的，我用的不同，我就基于我的来写</h3><p>1.1 新建一个工程，根目录的 build.gradle 里面</p><p>classpath ‘com.android.tools.build:gradle:3.0.0’</p><p>classpath ‘com.didi.virtualapk:gradle:0.9.8.4’</p><p>根目录 就配置这两个</p><p>1.2 在 app（宿主）目录下的 build.gradle 文件下添加</p><p>apply plugin: ‘com.didi.virtualapk.host’<br>在 dependencies 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>1.3 重点来了，通过 file，new module 的形式新建一个 module，然后我命名为 plugindemo，然后在 nodule.gradle 里面添加</p><p>implementation ‘com.didi.virtualapk:core:0.9.6’<br>接着在末端添加</p><p>apply plugin: ‘com.didi.virtualapk.plugin’<br>virtualApk {<br>    // 插件资源表中的packageId，需要确保不同插件有不同的packageId.<br>    packageId = 0x6f             // The package id of Resources.<br>    // 宿主工程application模块的路径，插件的构建需要依赖这个路径<br>    targetHost=’../app’ // The path of application module in host project.<br>    //默认为true，如果插件有引用宿主的类，那么这个选项可以使得插件和宿主保持混淆一致<br>    applyHostMapping = true      // [Optional] Default value is true.<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725103642552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>基本 环境就到此为止了，接下来代码部分</p><h3 id="2-代码添加并验证"><a href="#2-代码添加并验证" class="headerlink" title="2. 代码添加并验证"></a>2. 代码添加并验证</h3><p>在 app 的 mainactivity 里面添加两个按钮，一个是跳转到 module 去的，一个是加载插件的</p><p>public void loadPlugin() {<br>    PluginManager pluginManager = PluginManager.getInstance(this);<br>    //此处是当查看插件apk是否存在,如果存在就去加载(比如修改线上的bug,把插件apk下载到sdcard的根目录下取名为plugin-release.apk)<br>    File apk = new File(Environment.getExternalStorageDirectory(), “plugin-release.apk”);<br>    if (apk.exists()) {<br>        try {<br>            pluginManager.loadPlugin(apk);<br>            Toast.makeText(this, “插件加载成功”, Toast.LENGTH_SHORT).show();<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>            Toast.makeText(this, “插件加载异常！”, Toast.LENGTH_SHORT).show();<br>        }<br>    }<br>}<br>截图<br><img src="https://img-blog.csdn.net/20180725104101299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这个时候跳转是不行的，接下来就需要加载插件了 ，首先需要生成插件 apk</p><p>官方文档是通过命令</p><p>gradle clean assemblePlugin来构建插件</p><p>如果不想这样，也可以通过直接 gradle 的来，具体如下<br><img src="https://img-blog.csdn.net/20180725104350857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>这样 就生成插件 apk 了，同时官方文档介绍了下这个，就是只能生成 release 版本的，插件包位于 build 目录下<br><img src="https://img-blog.csdn.net/20180725104530319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVsaXh1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>到这里 就可以结束验证了，点击加载插件，然后再点击跳转，你会发现可以跳转了，如果如果有帮助可以帮我点个赞或者 githup 上面 star 一下，谢谢，如果有问题，可以下面评论回复，一起学习探讨。下面贴上注意点</p><ol><li><p>集成环境一定要配置好</p></li><li><p>生成的插件包和加载的时候名字一定要一样</p></li><li><p>注意 SD 卡的权限</p></li></ol><p>贴上相关参考文档和我的 githup 代码</p><p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK</a></p><p><a href="https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki/VirtualAPK-%E6%9E%84%E5%BB%BA%E5%99%A8-API-%E6%A6%82%E8%A7%88</a></p><p>github：<a href="https://github.com/sdgSnow/VirtualAPK" target="_blank" rel="noopener">https://github.com/sdgSnow/VirtualAPK</a></p><p>希望对大家有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/didi/VirtualAPK/raw/master/imgs/va.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;封面图片来源: &lt;a href=&quot;https://blog.csdn.net/byeweiyang/articl
      
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="插件化" scheme="https://yangxiaoge.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>锻炼身体从现在做起</title>
    <link href="https://yangxiaoge.github.io/2018/03/23/2018-3-23-%E9%94%BB%E7%82%BC%E8%BA%AB%E4%BD%93%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%81%9A%E8%B5%B7/"/>
    <id>https://yangxiaoge.github.io/2018/03/23/2018-3-23-锻炼身体从现在做起/</id>
    <published>2018-03-23T11:19:14.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- <a href="https://www.zhihu.com/question/22918787/answer/23166234" target="_blank" rel="noopener">杨小彻的回答 - 知乎 </a></p></blockquote><h3 id="上学"><a href="#上学" class="headerlink" title="上学"></a>上学</h3><p>我也是曾经瘦过的人，一度认为自己不会胖，上初高中一直都没有胖起来。于是我上了大学，入学时119斤173的个子，大学疯玩了4年，胡吃胡喝，毕业后我125斤😂</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>工作1年不到，长期坐着也不怎么运动，放假也不出门，十足的宅男。不用想肯定又胖了，emmm，130斤了Σ( °吓°|||)︴。</p><h3 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h3><p>交往我老婆以后，自己也不宅了，犹如一个没吃过东西的人，吃遍了各种以前没吃过的食物。她吃不完的我这人又舍不得浪费我就帮着消灭了（其实还是我能吃），再加上老婆烧的饭也很好吃，我就hold不住了。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>随着时间流逝，毕业快3年了，我体重飚到144斤了，啊五环～ 突然想唱这首歌🎤。呵，难道就是胖了就这么结束了？不，我还越来越黑了，由于从事it每天电脑相伴（我猜是这样的）。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>重点来了，在老婆的<code>劝导</code>下我要开始健身了，没错就是健身，不能任由自己这么胖下去了。既然事态发展到这步田地，箭在弦上不得不发了，不是我瘦就是健身房亡！社会社会|･ω･｀)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;胖，是一种不管别人说「你胖了」或是「你瘦了」都能感觉到有形状的恶意扑面砸来的敏感。- &lt;a href=&quot;https://www.zhihu.com/question/22918787/answer/23166234&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Nice git log</title>
    <link href="https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/"/>
    <id>https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/</id>
    <published>2017-12-13T10:11:01.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。</p><p>开发中查看提交记录是家常便饭了，<code>git log</code> 命令是查看全部提交日志，<code>git log -2</code>  查看最近 2 次的提交日志，<code>git log -p</code>  查看历史纪录以来哪几行被修改，<code>git log --stat --summary</code> 查看每个版本变动的档案和行数。</p><p>Git 默认的 git log 是这样子的，emmmmmm….. 丑</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e2fcca990.png"></div><p>于是乎 Google 了一个 git 配置，打开终端，输入以下命令。</p><pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;  </code></pre><p>以后在终端输入 git lg，就能看到下面漂亮的 git log 了。</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e32602b21.png"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。&lt;/p&gt;
&lt;p&gt;开发中查看提交记录是家常便饭了，&lt;code&gt;git log&lt;/code&gt; 命令是查看全部提交日志，&lt;code&gt;git log -2&lt;/code&gt;  查看最近 2 次的提交日志，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android Launcher 界面添加未接来电/未读短信条数显示</title>
    <link href="https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-%E7%95%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E6%9C%AA%E6%8E%A5%E6%9D%A5%E7%94%B5-%E6%9C%AA%E8%AF%BB%E7%9F%AD%E4%BF%A1%E6%9D%A1%E6%95%B0%E6%98%BE%E7%A4%BA/"/>
    <id>https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-界面添加未接来电-未读短信条数显示/</id>
    <published>2017-10-19T16:00:50.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Thumbnail by <a href="https://octiviotti.deviantart.com/" target="_blank" rel="noopener">octiviotti</a></p></blockquote><p>本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。</p><p>涉及到几个文件：<br><a id="more"></a></p><ol><li>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</li><li>packages/apps/Launcher3/src/com/android/launcher3/Utilities.java</li><li>packages/apps/Launcher3/AndroidManifest.xml </li></ol><p>具体的思路：<code>Launcher</code> 中注册 <code>ContentObserver</code> 来监听短信和电话数据库，当数据发生变化时，读取读取数据库未读数目之后通过 ICON_NAME ，<code>重新绘制</code>短信，电话的图标（在原图右上角画圆和数字）。</p><hr><p>具体代码：</p><h3 id="1-Launcher-java"><a href="#1-Launcher-java" class="headerlink" title="1. Launcher.java"></a>1. Launcher.java</h3><ul><li>首先是定义两个 ContentObserver</li></ul><pre><code>private final static int UPDATE_MMS_ICON = 826;  private final static int UPDATE_CALL_ICON = 1206;public class SMSContentObserver extends ContentObserver {    private Handler mHandler;    public SMSContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;SMSContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_MMS_ICON);        Message msg = mHandler.obtainMessage(UPDATE_MMS_ICON);        msg.obj = getMissMmsCount();        mHandler.sendMessage(msg);    }}public class CallContentObserver extends ContentObserver {    private Handler mHandler;    public CallContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;CallContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_CALL_ICON);        Message msg = mHandler.obtainMessage(UPDATE_CALL_ICON);        msg.obj = getMissCallCount();        mHandler.sendMessage(msg);    }}</code></pre><ul><li>在 onCreate() 中注册 ContentObserver</li></ul><pre><code>private SMSContentObserver smsContentObserver = null;  private CallContentObserver callContentObserver = null;  smsContentObserver = new SMSContentObserver(this,mHandler);callContentObserver =new CallContentObserver(this,mHandler);getContentResolver().registerContentObserver(Calls.CONTENT_URI,true,callContentObserver);getContentResolver().registerContentObserver(Uri.parse(&quot;content://mms-sms/&quot;),true,smsContentObserver);</code></pre><ul><li>定义两个 ICON_NAME</li></ul><pre><code>// 这两个 ICON_NAME 根据自己实际系统短信和电话页面对应包名填写private final static String PHONE_ICON_NAME = &quot;com.android.dialer.DialtactsActivity&quot;;private final static String MMS_ICON_NAME = &quot;com.android.messaging.ui.conversationlist.ConversationListActivity&quot;;</code></pre><ul><li>mHandler 中处理</li></ul><pre><code>@Thunkfinal Handler mHandler = new Handler(new Handler.Callback() {    @Override    public boolean handleMessage(Message msg) {        Log.i(&quot;Launcher-&quot;,&quot;mHandler msg.what = &quot; + msg.what);        if (msg.what == ADVANCE_MSG) {            int i = 0;            for (View key : mWidgetsToAdvance.keySet()) {                final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);                final int delay = mAdvanceStagger * i;                if (v instanceof Advanceable) {                    mHandler.postDelayed(new Runnable() {                        public void run() {                            ((Advanceable) v).advance();                        }                    }, delay);                }                i++;            }            sendAdvanceMessage(mAdvanceInterval);        }        //ADD BY Bruce Yang FOR SHOW UNREAD MMS        else if (msg.what == UPDATE_MMS_ICON) {            setMmsOrPhoneNum(MMS_ICON_NAME, getMissMmsCount());        } else if (msg.what == UPDATE_CALL_ICON) {            setMmsOrPhoneNum(PHONE_ICON_NAME, getMissCallCount());        }        return true;    }});</code></pre><ul><li>获取数据库中未读数目</li></ul><pre><code> private int getMissMmsCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount&quot;);    int missSmsCount = 0;    Cursor cursorSMS = null;    Cursor cursorMMS = null;    try {        cursorSMS = getContentResolver().query(                Uri.parse(&quot;content://sms&quot;), null, &quot;(read=0 and type=1)&quot;,                null, null);        cursorMMS = getContentResolver().query(                Uri.parse(&quot;content://mms&quot;), null, &quot;(read=0)&quot;, null,                null);    } catch (SQLiteException e) {        return missSmsCount;    }    if (cursorSMS != null) {        missSmsCount = cursorSMS.getCount();        cursorSMS.close();    }    if (cursorMMS != null) {            missSmsCount = missSmsCount + cursorMMS.getCount();        cursorMMS.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount  missSmsCount = &quot; + missSmsCount);    return missSmsCount;}private int getMissCallCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount&quot;);    int missCallCount = 0;    Uri missingCallUri = Calls.CONTENT_URI;    String where = Calls.TYPE + &quot;=&#39;&quot; + Calls.MISSED_TYPE + &quot;&#39;&quot;            + &quot; AND new=1&quot;;    Cursor cursorCall = null;    try {        cursorCall = getContentResolver().query(missingCallUri,                null, where, null, null);    } catch (SQLiteException e) {        return missCallCount;    }    if (cursorCall != null) {        missCallCount = cursorCall.getCount();        cursorCall.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount  missCallCount = &quot; + missCallCount);    return missCallCount;}</code></pre><ul><li>设置 ICON 未读数</li></ul><pre><code>/**    *    * @param flag 更新电话或短信 ICON    * @param missCount 未读数*/private void setMmsOrPhoneNum(final String flag, final int missCount) {    Log.i(&quot;Launcher-&quot;,&quot;flag = &quot;+flag +&quot; missCount = &quot;+missCount);    if(mWorkspace == null) return;    ArrayList&lt;CellLayout&gt; cellLayouts = mWorkspace.getWorkspaceAndHotseatCellLayouts();    for (final CellLayout layoutParent: cellLayouts) {        final ViewGroup shortcutAndWidgetContainer = layoutParent.getShortcutsAndWidgets();        mWorkspace.post(new Runnable() {            public void run() {                int childCount = shortcutAndWidgetContainer.getChildCount();                for (int j = 0; j &lt;childCount; j++) {                    View view = shortcutAndWidgetContainer.getChildAt(j);                    Object tag = view.getTag();                    if (tag instanceof ShortcutInfo) {                        final ShortcutInfo info = (ShortcutInfo) tag;                        final Intent intent = info.intent;                        if (intent != null) {                            final ComponentName name = intent.getComponent();                            if (name != null &amp;&amp; name.getClassName().equals(flag)) {                                BubbleTextView bv = (BubbleTextView) view;                                Bitmap defaultIconBitmap = Bitmap.createBitmap(info.getIcon(mIconCache));                                Bitmap bitmap = Utilities.createIconBitmap(defaultIconBitmap, missCount);                                bv.setCompoundDrawablesWithIntrinsicBounds(null,                                        new FastBitmapDrawable(bitmap),                                        null, null);                            }                        }                    }                }            }        });    }}</code></pre><ul><li>第一次启动 Launcher 就能获取未读数目，在 finishBindingItems() 添加逻辑</li></ul><pre><code>//ADD BY Bruce Yangint missCall = getMissCallCount();int missMms = getMissMmsCount();if(missCall != 0) {    setMmsOrPhoneNum(PHONE_ICON_NAME, missCall);}if(missMms != 0) {    setMmsOrPhoneNum(MMS_ICON_NAME, missMms);}</code></pre><ul><li>在 onDestroy() 中反注册 ContentObserver</li></ul><pre><code>getContentResolver().unregisterContentObserver(smsContentObserver);getContentResolver().unregisterContentObserver(callContentObserver);</code></pre><h3 id="2-Utilities-java"><a href="#2-Utilities-java" class="headerlink" title="2. Utilities.java"></a>2. Utilities.java</h3><p>新增构造方法，用于重新绘制带数字的应用图标。</p><pre><code>//add by Bruce Yang for ...static Bitmap createIconBitmap(Bitmap b, int count) {    Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888,true);    Log.i(&quot;Launcher-&quot;,&quot;b.isMutable() = &quot;+b.isMutable()); // 如果为 false 就会抛出 java.lang.IllegalStateException 异常， http://bbs.csdn.net/topics/370021698    if (count == 0) return b;    int textureWidth = bitmap.getWidth();    final Canvas canvas = sCanvas;    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    canvas.setBitmap(bitmap);    paint.setColor(Color.RED);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    paint.setColor(Color.WHITE);    paint.setStyle(Paint.Style.STROKE);    paint.setStrokeWidth(2);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    Paint countPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    countPaint.setColor(Color.WHITE);    countPaint.setTextSize(26f);    countPaint.setTypeface(Typeface.DEFAULT_BOLD);    float x = textureWidth - 24-4;    if (count &gt; 9) x -= 4+6;    if (count &gt; 99) {        countPaint.setTextSize(22f);        String text = String.valueOf(99) + &quot;+&quot;;        canvas.drawText(text, x-2, 25+5, countPaint);    } else {        String text = String.valueOf(count);        canvas.drawText(text,x, 25+5, countPaint);    }    return bitmap;}</code></pre><h3 id="3-AndroidManifest-xml"><a href="#3-AndroidManifest-xml" class="headerlink" title="3. AndroidManifest.xml"></a>3. AndroidManifest.xml</h3><p>添加如下两个权限，由于 Android 6.0 以上需要动态权限申请，这里为了直接获取权限，可以将 targetSdkVersion 改成 21（原来是 23）。</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot; /&gt;</code></pre><h3 id="4-修改对比"><a href="#4-修改对比" class="headerlink" title="4. 修改对比"></a>4. 修改对比</h3><blockquote><p>修改前：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e865f6b26df.png" width="270" height="480"></p><blockquote><p>修改后：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e86659672b9.png" width="270" height="480"></p><blockquote><p>参考文章： </p></blockquote><p><a href="http://blog.csdn.net/chenxiong668/article/details/12851357" target="_blank" rel="noopener">http://blog.csdn.net/chenxiong668/article/details/12851357</a><br><a href="http://blog.csdn.net/kerancsdn/article/details/26705767" target="_blank" rel="noopener">http://blog.csdn.net/kerancsdn/article/details/26705767</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Thumbnail by &lt;a href=&quot;https://octiviotti.deviantart.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;octiviotti&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。&lt;/p&gt;
&lt;p&gt;涉及到几个文件：&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从 0 搭建直播系统</title>
    <link href="https://yangxiaoge.github.io/2017/09/12/2017-09-12-%E4%BB%8E-0-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/</id>
    <published>2017-09-12T15:45:18.000Z</published>
    <updated>2017-10-12T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个直播的 Demo，今天正好看到<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统</a>，索性就把我自己的搭(折)建(腾)过程做一个记录。<br><a id="more"></a><br>搭建流程：</p><blockquote><p>服务器系统：Ubuntu 16.10 系统<br>推流，拉流系统：Win 7, Android</p></blockquote><p>一个简易的直播系统，大致可以由三部分组成（详情见<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋博客</a>）：</p><ul><li>搭建一个 rtmp 媒体服务器：这里使用 srs，链接为：<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li>推流端：这里使用 obs，链接为：<a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a></li><li>拉流端：这里使用播放器 vlc，链接为：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></li></ul><h3 id="使用第三方-SDK-推流"><a href="#使用第三方-SDK-推流" class="headerlink" title="使用第三方 SDK 推流"></a>使用第三方 SDK 推流</h3><p>这里以百度云的直播 SDK 为例，下载地址：<br><a href="https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E" target="_blank" rel="noopener">https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E</a></p><p>修改推流地址之后上传到了我的 <a href="https://github.com/yangxiaoge/PushFlowLive" target="_blank" rel="noopener">PushFlowLive</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/baidu-livecamera-%E6%8E%A8%E6%B5%81.apk" target="_blank" rel="noopener">apk 下载</a></p><h3 id="使用开源项目推流"><a href="#使用开源项目推流" class="headerlink" title="使用开源项目推流"></a>使用开源项目推流</h3><p>使用一个开源项目：</p><blockquote><p><a href="https://github.com/begeekmyfriend/yasea" target="_blank" rel="noopener">https://github.com/begeekmyfriend/yasea</a></p></blockquote><blockquote><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/yasea-推流.apk" target="_blank" rel="noopener">apk 下载</a></p></blockquote><h3 id="利用-ffmpeg-推流"><a href="#利用-ffmpeg-推流" class="headerlink" title="利用 ffmpeg 推流"></a>利用 ffmpeg 推流</h3><blockquote><p>详情见鸿洋博客</p></blockquote><p>大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。</p><p>这里，由于篇幅，我们就直接使用别人编好的项目了。</p><p><a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="noopener">https://github.com/WritingMinds/ffmpeg-android-java</a></p><p><strong><em>搭建过程截图</em></strong>：<br>直播步骤：1，开启rtmp 媒体服务器 2，推流（推流客户端，apk等） 3，拉流（vlc等）<br><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-43.jpg" alt></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-51.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-57.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-02.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-04.jpg" alt></p><blockquote><p>封面小黄人动图来自 <a href="https://giphy.com/search/new-follower" target="_blank" rel="noopener">giphy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想搞个直播的 Demo，今天正好看到&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/77937483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统&lt;/a&gt;，索性就把我自己的搭(折)建(腾)过程做一个记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="直播" scheme="https://yangxiaoge.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的 Android Framework</title>
    <link href="https://yangxiaoge.github.io/2017/09/05/2017-09-05-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-Android-Framework/"/>
    <id>https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/</id>
    <published>2017-09-05T14:16:37.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— <code>前言</code><br><a id="more"></a></p><blockquote><p>本文转自 <a href="https://juejin.im/post/586da43b1b69e60062cb8a4f" target="_blank" rel="noopener">墨镜猫</a>，通俗有趣的文笔</p></blockquote><div align="center"><img src="https://github.com/yangxiaoge/PersonResources/blob/bfd168d0f60a7fa8b11ad50cdc53694c77d90bd9/Android/Android%20Framework.jpg?raw=true"></div><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含以下类：</p><ul><li>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。</li><li>Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。</li><li>PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。</li><li>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。</li><li>DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。</li><li>ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。</li></ul><h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><p>Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。</p><p>每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。</p><h3 id="从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的</h3><p>ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。</p><p>接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。</p><p><strong><em>很多线程是不是很晕？</em></strong></p><ol><li>安卓程序中都有哪些线程？</li></ol><p>客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。</p><ol start="2"><li>UI 线程是什么？</li></ol><p>一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p><ol start="3"><li>自定义的线程和 UI 线程有什么区别？</li></ol><p>UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— &lt;code&gt;前言&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Framework" scheme="https://yangxiaoge.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源许可证？</title>
    <link href="https://yangxiaoge.github.io/2017/08/29/2017-08-29-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%9F/"/>
    <id>https://yangxiaoge.github.io/2017/08/29/2017-08-29-如何选择开源许可证？/</id>
    <published>2017-08-29T14:36:51.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。<br><a id="more"></a></p><blockquote><p>本文转自 <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a> 大大</p></blockquote><p>如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">上百种</a>。很少有人搞得清楚它们的区别。即使在最流行的六种—– <a href="http://www.gnu.org/licenses/gpl.html" target="_blank" rel="noopener">GPL</a>、<a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener">BSD</a>、<a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener">MIT</a>、<a href="http://www.mozilla.org/MPL/" target="_blank" rel="noopener">Mozilla</a>、<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache</a> 和 <a href="http://www.gnu.org/copyleft/lesser.html" target="_blank" rel="noopener">LGPL</a>—-之中做选择，也很复杂。<br>乌克兰程序员 <a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="noopener">Paul Bagwell</a> ，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。<br>下面是我制作的中文版，请看大图。<br><img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt></p><p>有兴趣详细了解开源协议的可以看这篇文章：<a href="http://www.gcssloop.com/tips/choose-license" target="_blank" rel="noopener">程序员不可不知的版权协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。&lt;br&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Binder源码分析</title>
    <link href="https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder源码分析/</id>
    <published>2017-07-06T10:00:05.000Z</published>
    <updated>2017-11-22T14:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>forked from <a href="https://github.com/xdtianyu/SourceAnalysis" target="_blank" rel="noopener">xdtianyu/SourceAnalysis</a></p></blockquote><p>本文是基于 <a href="https://github.com/xdtianyu/android-6.0.0_r1" target="_blank" rel="noopener">Android 6.0.0</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow" target="_blank" rel="noopener">kernel 3.4</a> 源码 及 Android SDK 23 展开的。</p><p>先上一张图，直白的了解 Binder 通信过程。(摘自<a href="http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA" target="_blank" rel="noopener">超详细 Android 面试的准备与经历分享 | 百度 (offer)</a>)</p><blockquote><p><img src="/assets/学习资料/面试小札/Binder通信过程.png" alt></p></blockquote><a id="more"></a><p><strong>目录</strong></p><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-binder-与-aidl">2. Binder 与 AIDL</a><ul><li><a href="#21-aidl-客户端">2.1 AIDL 客户端</a></li><li><a href="#22-aidl-服务端">2.2 AIDL 服务端</a></li><li><a href="#23-远程服务的获取与使用">2.3 远程服务的获取与使用</a></li></ul></li><li><a href="#3-binder-框架及-native-层">3. Binder 框架及 Native 层</a><ul><li><a href="#31-binder-native-的入口">3.1 Binder Native 的入口</a></li><li><a href="#32-binder-本地层的整个函数/方法调用过程">3.2 Binder 本地层的整个函数/方法调用过程</a></li><li><a href="#33-binder-设备文件的打开和读写">3.3 Binder 设备文件的打开和读写</a></li></ul></li><li><a href="#4-binder-驱动">4. Binder 驱动</a><ul><li><a href="#41-binder-设备的创建">4.1 binder 设备的创建</a></li><li><a href="#42-binder-协议和数据结构">4.2 binder 协议和数据结构</a></li><li><a href="#43-binder-驱动文件操作">4.3 binder 驱动文件操作</a></li></ul></li><li><a href="#5-binder-与系统服务">5. Binder 与系统服务</a><ul><li><a href="#51-contextgetsystemservice">5.1 Context.getSystemService()</a></li><li><a href="#52-contextgetsystemservice-源码分析">5.2 Context.getSystemService() 源码分析</a></li></ul></li><li><a href="#6-结论">6. 结论</a></li><li><a href="#7-参考">7. 参考</a></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 <code>Context.getSystemService()</code> 来获取系统服务，或直接使用 <code>AIDL</code> 来实现多个程序(APP)间数据交互。</p><p>Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/android_binder.png" alt="android_binder"></p><p>不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。</p><p>我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。</p><h2 id="2-Binder-与-AIDL"><a href="#2-Binder-与-AIDL" class="headerlink" title="2. Binder 与 AIDL"></a>2. Binder 与 AIDL</h2><p>AIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/AIDL.png" alt="AIDL概念图"></p><ul><li><p>Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。</p></li><li><p>Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。</p></li></ul><p>接下来再看具体实现， 完整源代码见 <a href="https://github.com/xdtianyu/AidlExample" target="_blank" rel="noopener">AidlExample</a>。在这个工程中，我们新建了两个应用， <code>app</code> 是客户端代码， <code>remoteservice</code> 则是服务端代码。</p><h3 id="2-1-AIDL-客户端"><a href="#2-1-AIDL-客户端" class="headerlink" title="2.1 AIDL 客户端"></a>2.1 AIDL 客户端</h3><p>在 Android Studio 项目上右键， <code>New</code> -&gt; <code>AIDL</code> -&gt; <code>AIDL File</code> 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> 文件</p><pre><code class="java">// IRemoteService.aidlpackage com.android.aidltest;interface IRemoteService {    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);}</code></pre><p>从生成的示例代码可以看出，AIDL 的语法类似 Java， <code>basicTypes()</code> 方法传递的参数只是基本类型。</p><p>如果要传递自定义类型如 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java#L6" target="_blank" rel="noopener">User</a>，则需要实现 <a href="http://developer.android.com/reference/android/os/Parcelable.html" target="_blank" rel="noopener">Parcelable</a> 接口。<code>Parcelable</code> 是一个与 Java <code>Serializable</code> 类似的序列化接口。 </p><p>这样类 <code>User</code> 的实例就可以储存到 <a href="http://developer.android.com/reference/android/os/Parcel.html" target="_blank" rel="noopener">Parcel</a> 中，而 <code>Parcel</code> 则是一个可以通过 <code>IBinder</code> 发送数据或对象引用的容器。</p><pre><code class="java">// User.javapublic class User implements Parcelable {    private int uid;    private String name;    // 从 Parcel 中读取数据，顺序需要和写入保持一致    protected User(Parcel in) {        uid = in.readInt();        name = in.readString();    }    // 必须实现，用于从 Parcel 对象中生成类实例    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {        @Override        public User createFromParcel(Parcel in) {            return new User(in);        }        @Override        public User[] newArray(int size) {            return new User[size];        }    };    // 将数据写入到 Parcel 中， 顺序需要与读取保持一致    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(uid);        dest.writeString(name);    }}</code></pre><p>再向 <code>IRemoteService.aidl</code> 中添加一个 <code>addUser()</code> 方法，同时新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> 文件。</p><pre><code class="java">// IRemoteService.aidlpackage com.android.aidltest;import com.android.aidltest.User;interface IRemoteService {    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);    // in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法    void addUser(in User user);}// User.aidlpackage com.android.aidltest;parcelable User;</code></pre><p>运行编译后，会在 <code>generated</code> 文件夹中生成一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">IRemoteService.java</a> 接口文件。这个接口中有两个内部类 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Stub.Proxy</a>。注意客户端生成的<code>IRemoteService.java</code> 文件和在后文服务端生成的文件内容是相同的。</p><p>客户端会从 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L34" target="_blank" rel="noopener">Stub.asInterface()</a> 得到 <code>IRemoteService (Stub.Proxy)</code> 的实例，这个实例就是一个通过 Binder 传递回来的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L93" target="_blank" rel="noopener">远程对象</a> 的包装。而服务端则需要实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">IRemoteService.addUser()</a> 方法。</p><pre><code class="java">// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) {    if ((obj == null)) {        return null;    }    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);    if (((iin != null) &amp;&amp; (iin instanceof org.xdty.remoteservice.IRemoteService))) {        return ((org.xdty.remoteservice.IRemoteService) iin);    }    return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);}</code></pre><h3 id="2-2-AIDL-服务端"><a href="#2-2-AIDL-服务端" class="headerlink" title="2.2 AIDL 服务端"></a>2.2 AIDL 服务端</h3><p>为了演示进程间通信，我们新建一个模块（应用） <a href="https://github.com/xdtianyu/AidlExample/tree/master/remoteservice" target="_blank" rel="noopener">RemoteService</a> 来实现功能，并在客户端绑定服务。</p><p>按客户端的结构新建 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java" target="_blank" rel="noopener">User.java</a> 文件，并拷贝内容，注意如果需要请修改包名。</p><p>新建服务 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L29" target="_blank" rel="noopener">RemoteService</a> ，覆盖(Override) <code>onBind()</code> 方法并返回 <code>IRemoteService.Stub</code> 实例 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>：</p><pre><code class="java">// RemoteService.javapublic class RemoteService extends Service {    private static final String TAG = RemoteService.class.getSimpleName();    private IBinder mBinder = new IRemoteService.Stub() {        @Override        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,                double aDouble, String aString) throws RemoteException {            Log.d(TAG, &quot;basicTypes: &quot;);        }        @Override        public void addUser(User user) throws RemoteException {            Log.d(TAG, &quot;addUser: &quot; + user.name);        }    };    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }}</code></pre><p>这样服务端就实现了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">addUser()</a> 方法，当客户端通过远程对象调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L135" target="_blank" rel="noopener">IRemoteService.Stub.Proxy.addUser()</a> 时，远程对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">mRemote</a> 就会通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 发送命令给服务端，服务端收到命令后在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L76" target="_blank" rel="noopener">Stub.onTransact()</a> 中读取数据并执行 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">addUser()</a> 方法。更多细节我们将在 <a href="#3-binder-%E6%A1%86%E6%9E%B6%E5%8F%8A-native-%E5%B1%82">3. Binder 框架及 Native 层</a> 小节讲述。</p><pre><code class="java">// IRemoteService.java@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,        int flags) throws android.os.RemoteException {    switch (code) {        ...        case TRANSACTION_addUser: {            data.enforceInterface(DESCRIPTOR);            org.xdty.remoteservice.User _arg0;            if ((0 != data.readInt())) {                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);            } else {                _arg0 = null;            }            this.addUser(_arg0);            reply.writeNoException();            return true;        }    }    return super.onTransact(code, data, reply, flags);}</code></pre><h3 id="2-3-远程服务的获取与使用"><a href="#2-3-远程服务的获取与使用" class="headerlink" title="2.3 远程服务的获取与使用"></a>2.3 远程服务的获取与使用</h3><p>客户端要使用远程服务，需要绑定服务 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L45" target="_blank" rel="noopener">bindService</a>) 并建立服务连接 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L19" target="_blank" rel="noopener">ServiceConnection</a>)。</p><pre><code class="java">// MainActivity.javapublic class MainActivity extends AppCompatActivity {    private ServiceConnection mConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            IRemoteService remoteService = IRemoteService.Stub.asInterface(service);            try {                remoteService.addUser(new User(1, &quot;neo&quot;));            } catch (RemoteException e) {                e.printStackTrace();            }        }        ...    };    ...    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        Intent intent = new Intent().setComponent(new ComponentName(                &quot;org.xdty.remoteservice&quot;,                &quot;org.xdty.remoteservice.RemoteService&quot;));        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);    }}</code></pre><p>我们可以看出，客户端通过 <code>binderService()</code> 方法，获取远程服务并在服务连接 <code>ServiceConnection</code> 中 <code>onServiceConnected()</code> 回调中得到了 <code>IBinder service</code> 实例， 最后通过上文提到的 <code>IRemoteService.Stub.asInterface(service)</code> 方法得到远程服务 <code>IRemoteService</code> 的实例。通过 <code>IRemoteService.addUser()</code> 方法我们可以像调用本地方法一样调用远程方法。在来看 <code>IRemoteService.addUser()</code> 的实现：</p><pre><code class="java">// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) {    ...    return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);}private static class Proxy implements org.xdty.remoteservice.IRemoteService {    private android.os.IBinder mRemote;    Proxy(android.os.IBinder remote) {        mRemote = remote;    }    @Override    public android.os.IBinder asBinder() {        return mRemote;    }    ...    @Override    public void addUser(org.xdty.remoteservice.User user)            throws android.os.RemoteException {        android.os.Parcel _data = android.os.Parcel.obtain();        android.os.Parcel _reply = android.os.Parcel.obtain();        try {            _data.writeInterfaceToken(DESCRIPTOR);            if ((user != null)) {                _data.writeInt(1);                user.writeToParcel(_data, 0);            } else {                _data.writeInt(0);            }            mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);            _reply.readException();        } finally {            _reply.recycle();            _data.recycle();        }    }}</code></pre><p>可以看到客户端调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L25" target="_blank" rel="noopener">remoteService.addUser(new User(1, “neo”))</a> 方法实际上是通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IBinder service</a> 实例的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 方法，发送了与服务端约定好的命令 <code>Stub.TRANSACTION_addUser</code>，并将参数按格式打包进 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L137" target="_blank" rel="noopener">Parcel</a> 对象。</p><p>服务端则在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法中收到命令后会对命令和参数重新解析：</p><pre><code class="java">// IRemoteService.javapublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,        int flags) throws android.os.RemoteException {    switch (code) {        ...        case TRANSACTION_addUser: {            data.enforceInterface(DESCRIPTOR);            org.xdty.remoteservice.User _arg0;            if ((0 != data.readInt())) {                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);            } else {                _arg0 = null;            }            this.addUser(_arg0);            reply.writeNoException();            return true;        }    }    return super.onTransact(code, data, reply, flags);}</code></pre><p>可以看到在 <code>onTransact()</code> 中，最终 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">this.addUser(_arg0)</a> 调用了上文提到的服务端的实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub.addUser()</a> 。</p><p>远程 Binder 对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L42" target="_blank" rel="noopener">mRemote</a> 是由客户端绑定服务时 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L23" target="_blank" rel="noopener">onServiceConnected()</a> 返回的。继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1283" target="_blank" rel="noopener">bindService()</a></p><pre><code class="java">// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn,        int flags) {    warnIfCallingFromSystemProcess();    return bindServiceCommon(service, conn, flags, Process.myUserHandle());}</code></pre><p>可以看到最后是通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1317#L1320" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> 来绑定服务</p><pre><code class="java">// bindServiceCommon()int res = ActivityManagerNative.getDefault().bindService(    mMainThread.getApplicationThread(), getActivityToken(), service,    service.resolveTypeIfNeeded(getContentResolver()),    sd, flags, getOpPackageName(), user.getIdentifier());// ActivityManagerNative.getDefault().bindService()public int bindService(IApplicationThread caller, IBinder token,        Intent service, String resolvedType, IServiceConnection connection,        int flags,  String callingPackage, int userId) throws RemoteException {    ...    data.writeStrongBinder(connection.asBinder());    ...    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);    ...}</code></pre><p>追踪到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3740" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> ，可以发现 <code>ActivityManager</code> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3750" target="_blank" rel="noopener">IServiceConnection</a>也是一个 <code>AIDL</code> 实现。通过它的 <code>ActivityManagerProxy.bindService()</code> 将绑定请求发送给本地层。</p><p>再从 <code>onServiceConnected()</code> 回调追踪， <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1223" target="_blank" rel="noopener">onServiceConnected()</a> 是由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1175" target="_blank" rel="noopener">LoadedApk.ServiceDispatcher.doConnected()</a> 回调的。</p><p><em>关于更多的 <code>bindService()</code> 远程服务创建及 <code>ServiceConnection</code> 回调， 请参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6745181" target="_blank" rel="noopener">Android应用程序绑定服务（bindService）的过程源代码分析</a></em></p><p><em>利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 <a href="https://github.com/xdtianyu/CallerInfo/tree/master/plugin/src/main" target="_blank" rel="noopener">CallerInfo Plugin</a> 的实现 </em></p><p>从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。</p><h2 id="3-Binder-框架及-Native-层"><a href="#3-Binder-框架及-Native-层" class="headerlink" title="3. Binder 框架及 Native 层"></a>3. Binder 框架及 Native 层</h2><p>Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/Binder.png" alt="Binder框架图片"></p><p>Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 <a href="#4-binder-%E9%A9%B1%E5%8A%A8">4. Binder 驱动</a> 小节详细讲述。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native.png" alt="Binder本地框架图片"></p><p>JNI 的代码位于 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/core/jni" target="_blank" rel="noopener">frameworks/base/core/jni</a> 目录下，主要是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp" target="_blank" rel="noopener">android_util_Binder.cpp</a> 文件和头文件 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.h" target="_blank" rel="noopener">android_util_Binder.h</a></p><p>Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 <code>libandroid_runtime.so</code> 系统库。</p><p>Binder 本地层的代码在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/libs/binder" target="_blank" rel="noopener">frameworks/native/libs/binder</a> 目录下， 此目录在 Android 系统编译后会生成 <code>libbinder.so</code> 文件，供 JNI 调用。<code>libbinder</code> 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/include/binder" target="_blank" rel="noopener">frameworks/native/include/binder</a> 目录下。</p><h3 id="3-1-Binder-Native-的入口"><a href="#3-1-Binder-Native-的入口" class="headerlink" title="3.1 Binder Native 的入口"></a>3.1 Binder Native 的入口</h3><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IInterface.cpp#L33" target="_blank" rel="noopener">IInterface.cpp</a> 是 Binder 本地层入口，与 java 层的 <code>android.os.IInterface</code> 对应，提供 <code>asBinder()</code> 的实现，返回 <code>IBinder</code> 对象。</p><p>在头文件中有两个类 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L50" target="_blank" rel="noopener">BnInterface (Binder Native Interface)</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L63" target="_blank" rel="noopener">BpInterface (Binder Proxy Interface)</a>, 对应于 java 层的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Proxy</a></p><pre><code class="c++">sp&lt;IBinder&gt; IInterface::asBinder(const IInterface* iface){    if (iface == NULL) return NULL;    return const_cast&lt;IInterface*&gt;(iface)-&gt;onAsBinder();}</code></pre><pre><code class="c++">template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder{public:    virtual sp&lt;IInterface&gt;      queryLocalInterface(const String16&amp; _descriptor);    virtual const String16&amp;     getInterfaceDescriptor() const;protected:    virtual IBinder*            onAsBinder();};// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase{public:                                BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected:    virtual IBinder*            onAsBinder();};</code></pre><p>其中 <code>BnInterface</code> 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。<code>BpInterface</code> 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。</p><h3 id="3-2-Binder-本地层的整个函数-方法调用过程"><a href="#3-2-Binder-本地层的整个函数-方法调用过程" class="headerlink" title="3.2 Binder 本地层的整个函数/方法调用过程"></a>3.2 Binder 本地层的整个函数/方法调用过程</h3><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native_stack.png" alt="Binder本地函数调用图"></p><p>1. Java 层 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IRemoteService.Stub.Proxy</a> 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L501" target="_blank" rel="noopener">android.os.IBinder (实现在 android.os.Binder.BinderProxy)</a> 的 <code>transact()</code> 发送 <code>Stub.TRANSACTION_addUser</code> 命令。</p><p>2. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L507" target="_blank" rel="noopener">BinderProxy.transact()</a> 进入 native 层。</p><p>3. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">jni</a> 转到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">android_os_BinderProxy_transact()</a> 函数。</p><p>4. 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1124" target="_blank" rel="noopener">IBinder-&gt;transact</a> 函数。</p><pre><code class="c++">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException{    IBinder* target = (IBinder*)        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);    status_t err = target-&gt;transact(code, *data, reply, flags);}</code></pre><p>而 <code>gBinderProxyOffsets.mObject</code> 则是在 java 层调用 <code>IBinder.getContextObject()</code> 时在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L580" target="_blank" rel="noopener">javaObjectForIBinder</a> 函数中设置的</p><pre><code class="c++">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz){    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);    return javaObjectForIBinder(env, b);}jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val){    ...    LOGDEATH(&quot;objectForBinder %p: created new proxy %p !\n&quot;, val.get(), object);    // The proxy holds a reference to the native object.    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());    val-&gt;incStrong((void*)javaObjectForIBinder);    ...}</code></pre><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L85" target="_blank" rel="noopener">ProcessState::getContextObject()</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L220" target="_blank" rel="noopener">ProcessState::getStrongProxyForHandle()</a></p><pre><code class="c++">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/){    return getStrongProxyForHandle(0);}sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle){    sp&lt;IBinder&gt; result;    ...    b = new BpBinder(handle);     result = b;    ...    return result;}</code></pre><p>可见 <a href>android_os_BinderProxy_transact()</a> 函数实际上调用的是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L159" target="_blank" rel="noopener">BpBinder::transact()</a> 函数。</p><p>5. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L164" target="_blank" rel="noopener">BpBinder::transact()</a> 则又调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L548" target="_blank" rel="noopener">IPCThreadState::self()-&gt;transact()</a> 函数。</p><pre><code class="c++">status_t IPCThreadState::transact(int32_t handle,                                  uint32_t code, const Parcel&amp; data,                                  Parcel* reply, uint32_t flags){    status_t err = data.errorCheck();    flags |= TF_ACCEPT_FDS;    if (err == NO_ERROR) {        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),            (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);    }    if ((flags &amp; TF_ONE_WAY) == 0) {        if (reply) {            err = waitForResponse(reply);        } else {            Parcel fakeReply;            err = waitForResponse(&amp;fakeReply);        }    } else {        err = waitForResponse(NULL, NULL);    }    return err;}status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer){    binder_transaction_data tr;    tr.target.ptr = 0; /* Don&#39;t pass uninitialized stack data to a remote process */    tr.target.handle = handle;    tr.code = code;    ...    mOut.writeInt32(cmd);    mOut.write(&amp;tr, sizeof(tr));    return NO_ERROR;}</code></pre><p>由函数内容可以看出， 数据再一次通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L904" target="_blank" rel="noopener">writeTransactionData()</a> 传递给 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L934" target="_blank" rel="noopener">mOut</a> 进行写入操作。 <code>mOut</code> 是一个 Parcel 对象， 声明在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IPCThreadState.h#L123" target="_blank" rel="noopener">IPCThreadState.h</a> 文件中。之后则调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L583" target="_blank" rel="noopener">waitForResponse()</a> 函数。</p><p>6. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L712" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> 在一个 <code>while</code> 循环里不断的调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">talkWithDriver()</a> 并检查是否有数据返回。</p><pre><code class="c++">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){    uint32_t cmd;    int32_t err;    while (1) {        if ((err=talkWithDriver()) &lt; NO_ERROR) break;        ...        cmd = (uint32_t)mIn.readInt32();        switch (cmd) {        case BR_TRANSACTION_COMPLETE:            ...        case BR_REPLY:            {                binder_transaction_data tr;                err = mIn.read(&amp;tr, sizeof(tr));                ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);                if (err != NO_ERROR) goto finish;                if (reply) {                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {                        reply-&gt;ipcSetDataReference(                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                            tr.data_size,                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                            tr.offsets_size/sizeof(binder_size_t),                            freeBuffer, this);                    } else {                        err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);                        freeBuffer(NULL,                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                            tr.data_size,                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                            tr.offsets_size/sizeof(binder_size_t), this);                    }                } else {                    freeBuffer(NULL,                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                        tr.data_size,                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                        tr.offsets_size/sizeof(binder_size_t), this);                    continue;                }            }            goto finish;        }        default:            err = executeCommand(cmd);            if (err != NO_ERROR) goto finish;            break;        }    }    ...}</code></pre><p>7. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> 函数是真正与 binder 驱动交互的实现。<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 就是使用系统调用函数 <code>ioctl</code> 向 binder 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令。</p><pre><code class="c++">status_t IPCThreadState::talkWithDriver(bool doReceive){    if (mProcess-&gt;mDriverFD &lt;= 0) {        return -EBADF;    }    binder_write_read bwr;    // Is the read buffer empty?    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();    // We don&#39;t want to write anything if we are still reading    // from data left in the input buffer and the caller    // has requested to read the next data.    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;    bwr.write_size = outAvail;    bwr.write_buffer = (uintptr_t)mOut.data();    // This is what we&#39;ll read.    if (doReceive &amp;&amp; needRead) {        bwr.read_size = mIn.dataCapacity();        bwr.read_buffer = (uintptr_t)mIn.data();    } else {        bwr.read_size = 0;        bwr.read_buffer = 0;    }    // Return immediately if there is nothing to do.    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;    bwr.write_consumed = 0;    bwr.read_consumed = 0;    status_t err;#if defined(HAVE_ANDROID_OS)        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)            err = NO_ERROR;        else            err = -errno;#else        err = INVALID_OPERATION;#endif    do {        if (mProcess-&gt;mDriverFD &lt;= 0) {            err = -EBADF;        }    } while (err == -EINTR);    if (err &gt;= NO_ERROR) {        if (bwr.write_consumed &gt; 0) {            if (bwr.write_consumed &lt; mOut.dataSize())                mOut.remove(0, bwr.write_consumed);            else                mOut.setDataSize(0);        }        if (bwr.read_consumed &gt; 0) {            mIn.setDataSize(bwr.read_consumed);            mIn.setDataPosition(0);        }        return NO_ERROR;    }    return err;}</code></pre><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L718" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> ,就将数据发送给了 Binder 驱动。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L723" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> ，可以从 第6步 发现 <code>IPCThreadState</code> 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L787" target="_blank" rel="noopener">executeCommand(cmd)</a> 函数。</p><p>8. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L947" target="_blank" rel="noopener">IPCThreadState::executeCommand()</a> 处理 Binder 驱动返回命令</p><pre><code class="c++">status_t IPCThreadState::executeCommand(int32_t cmd){    BBinder* obj;    RefBase::weakref_type* refs;    status_t result = NO_ERROR;    switch ((uint32_t)cmd) {    ...    case BR_TRANSACTION:        {            binder_transaction_data tr;            result = mIn.read(&amp;tr, sizeof(tr));            ...            Parcel buffer;            buffer.ipcSetDataReference(                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                tr.data_size,                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);            ...            Parcel reply;            status_t error;            if (tr.target.ptr) {                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);                error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);            } else {                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);            }            ...        }        break;    ...}</code></pre><p>9. 可以看出其调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">BBinder::transact()</a> 函数，将数据返回给上层。</p><pre><code class="c++">status_t BBinder::transact(    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){    data.setDataPosition(0);    status_t err = NO_ERROR;    switch (code) {        case PING_TRANSACTION:            reply-&gt;writeInt32(pingBinder());            break;        default:            err = onTransact(code, data, reply, flags);            break;    }    if (reply != NULL) {        reply-&gt;setDataPosition(0);    }    return err;}</code></pre><p>10. 而这里的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags)</a> 中的 <code>b (BBinder)</code> 是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L217" target="_blank" rel="noopener">JavaBBinder</a> 的实例，所以会调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L247" target="_blank" rel="noopener">JavaBBinder::onTransact()</a> 函数</p><pre><code class="c++">// frameworks/base/core/jni/android_util_Binder.cppvirtual status_t onTransact(        uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)    {        JNIEnv* env = javavm_to_jnienv(mVM);        ...        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,            code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);    }static int int_register_android_os_Binder(JNIEnv* env){    ...    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, &quot;execTransact&quot;, &quot;(IJJI)Z&quot;);    ...}</code></pre><p>11. 可见 JNI 通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L260" target="_blank" rel="noopener">gBinderOffsets.mExecTransact</a> 最后执行了 <code>android.os.Binder</code> 的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L865" target="_blank" rel="noopener">execTransact()</a> 方法。</p><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L442" target="_blank" rel="noopener">execTransact()</a> 方法是 jni 回调的入口。</p><pre><code class="java">// Entry point from android_util_Binder.cpp&#39;s onTransact    private boolean execTransact(int code, long dataObj, long replyObj,            int flags) {        Parcel data = Parcel.obtain(dataObj);        Parcel reply = Parcel.obtain(replyObj);        ...        try {            res = onTransact(code, data, reply, flags);        }         ...    }</code></pre><p>12. 而我们则在服务端 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub</a> 重载了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法，所以数据最后会回到我们的服务端并执行服务端实现的 <code>addUser()</code> 方法。</p><pre><code class="java">public static abstract class Stub extends android.os.Binder        implements org.xdty.remoteservice.IRemoteService {    ...    @Override    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,            int flags) throws android.os.RemoteException {        switch (code) {            case INTERFACE_TRANSACTION: {                reply.writeString(DESCRIPTOR);                return true;            }            case TRANSACTION_basicTypes: {                ...                return true;            }            case TRANSACTION_addUser: {                data.enforceInterface(DESCRIPTOR);                org.xdty.remoteservice.User _arg0;                if ((0 != data.readInt())) {                    _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);                } else {                    _arg0 = null;                }                this.addUser(_arg0);                reply.writeNoException();                return true;            }        }        return super.onTransact(code, data, reply, flags);    }}</code></pre><p>上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 <code>BC_TRANSACTION</code> 到 Binder 驱动，服务端进程监听返回的 <code>BR_TRANSACTION</code> 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 <code>BC_REPLY</code> 命令， 客户端监听 <code>BR_REPLY</code> 命令。</p><h3 id="3-3-Binder-设备文件的打开和读写"><a href="#3-3-Binder-设备文件的打开和读写" class="headerlink" title="3.3 Binder 设备文件的打开和读写"></a>3.3 Binder 设备文件的打开和读写</h3><p><strong>1. 设备的打开</strong></p><p>在上一小节中我们看到 JNI 过程中调用了 <code>ProcessState::getContextObject()</code> 函数， 在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">ProcessState</a> 初始化时会打开 binder 设备</p><pre><code class="c++">// ProcessState.cppProcessState::ProcessState()    : mDriverFD(open_driver())    ...{    ...}</code></pre><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L311#L337" target="_blank" rel="noopener">open_driver()</a> 函数内容如下</p><pre><code class="c++">// ProcessState.cppstatic int open_driver(){    // 打开设备文件    int fd = open(&quot;/dev/binder&quot;, O_RDWR);    if (fd &gt;= 0) {        fcntl(fd, F_SETFD, FD_CLOEXEC);        int vers = 0;        // 获取驱动版本        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);        if (result == -1) {            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));            close(fd);            fd = -1;        }        // 检查驱动版本是否一致        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {            ALOGE(&quot;Binder driver protocol does not match user space protocol!&quot;);            close(fd);            fd = -1;        }        // 设置最多 15 个 binder 线程        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);        if (result == -1) {            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));        }    } else {        ALOGW(&quot;Opening &#39;/dev/binder&#39; failed: %s\n&quot;, strerror(errno));    }    return fd;}</code></pre><p><strong>2. 设备的读写</strong></p><p>打开设备文件后，文件描述符被保存在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">mDriverFD</a>， 通过系统调用 <code>ioctl</code> 函数操作 <code>mDriverFD</code> 就可以实现和 binder 驱动的交互。</p><p>对 Binder 设备文件的所有读写及关闭操作则都在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L805" target="_blank" rel="noopener">IPCThreadState</a> 中，如上一小节提及到的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver</a> 函数</p><p><code>talkWithDriver()</code> 函数封装了 <code>BINDER_WRITE_READ</code> 命令，会从 binder 驱动读取或写入封装在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">binder_write_read</a> 结构体中的本地或远程对象。</p><pre><code class="c++">// IPCThreadState.cppstatus_t IPCThreadState::talkWithDriver(bool doReceive){       binder_write_read bwr;    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;    // 写入数据    bwr.write_size = outAvail;    bwr.write_buffer = (uintptr_t)mOut.data();    // 读取数据    if (doReceive &amp;&amp; needRead) {        bwr.read_size = mIn.dataCapacity();        bwr.read_buffer = (uintptr_t)mIn.data();    } else {        bwr.read_size = 0;        bwr.read_buffer = 0;    }    ...    // 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动    if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)        err = NO_ERROR;    ...}</code></pre><p>可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。</p><h2 id="4-Binder-驱动"><a href="#4-Binder-驱动" class="headerlink" title="4. Binder 驱动"></a>4. Binder 驱动</h2><p>关于 binder 驱动建议参考另一篇文章 <a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a> <a href="[Android Binder](https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11">原文</a>，本小节仍需要完善。</p><p>Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_reference.png" alt="Binder reference"></p><p>Binder 驱动的代码位于 kernel 代码的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/tree/master/drivers/staging/android" target="_blank" rel="noopener">drivers/staging/android</a> 目录下。主文件是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c" target="_blank" rel="noopener">binder.c</a></p><p>进程间传输的数据被称为 Binder 对象，它是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L49" target="_blank" rel="noopener">flat_binder_object</a>，结构如下</p><pre><code class="c">struct flat_binder_object {    /* 8 bytes for large_flat_header. */    unsigned long       type;    unsigned long       flags;    /* 8 bytes of data. */    union {        void        *binder;    /* local object */        signed long handle;     /* remote object */    };    /* extra data associated with local object */    void            *cookie;};</code></pre><p>其中 类型 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">type</a> 描述了 Binder 对象的类型，包含 <code>BINDER</code>(本地对象)、<code>HANDLE</code>(远程对象)、 <code>FD</code> 三大类(五种)</p><pre><code class="c">enum {    BINDER_TYPE_BINDER  = B_PACK_CHARS(&#39;s&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&#39;w&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_HANDLE  = B_PACK_CHARS(&#39;s&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(&#39;w&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_FD      = B_PACK_CHARS(&#39;f&#39;, &#39;d&#39;, &#39;*&#39;, B_TYPE_LARGE),};</code></pre><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L52" target="_blank" rel="noopener">flags</a> 则表述了<a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L110" target="_blank" rel="noopener">传输方式</a>，如异步、无返回等</p><pre><code class="c">enum transaction_flags {    TF_ONE_WAY  = 0x01, /* this is a one-way call: async, no return */    TF_ROOT_OBJECT  = 0x04, /* contents are the component&#39;s root object */    TF_STATUS_CODE  = 0x08, /* contents are a 32-bit status code */    TF_ACCEPT_FDS   = 0x10, /* allow replies with file descriptors */};</code></pre><p>而 <code>flat_binder_object</code> 中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L55" target="_blank" rel="noopener">union 联合体</a> 就是要传输的数据，当类型为 <code>BINDER</code> 时， 数据就是一个本地对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L56" target="_blank" rel="noopener">*binder</a>，而类型为 <code>HANDLE</code> 时，数据则是一个远程对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L57" target="_blank" rel="noopener">handle</a>。</p><p>当 <code>flat_binder_object</code> 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1671" target="_blank" rel="noopener">binder_transaction</a> 的实现。</p><p>该如何理解本地 <code>BINDER</code> 对象和远程 <code>HANDLE</code> 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 <code>RemoteService</code> 有个对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>，对于 <code>RemoteService</code> 来说，<code>mBinder</code> 就是一个本地的 <code>BINDER</code> 对象；如果进程 <code>app</code> 通过 Binder 驱动访问 <code>RemoteService</code> 的 <code>mBinder</code> 对象，对于 <code>app</code> 来说， <code>mBinder</code> 就是一个 <code>HANDLE</code>。因此，从根本上来说 <code>handle</code> 和 <code>binder</code> 都指向 <code>RemoteService</code> 的 <code>mBinder</code>。本地对象还可以带有额外的数据，保存在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L61" target="_blank" rel="noopener">cookie</a> 中。</p><p>Binder 驱动直接操作的最外层数据结构是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L117" target="_blank" rel="noopener">binder_transaction_data</a>， Binder 对象 <code>flat_binder_object</code> 被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">binder_transaction_data</a> 结构体中。</p><p><code>binder_transaction_data</code> 数据结构才是真正传输的数据，其定义如下</p><pre><code class="c">struct binder_transaction_data {    /* The first two are only used for bcTRANSACTION and brTRANSACTION,     * identifying the target and contents of the transaction.     */    union {        size_t  handle; /* target descriptor of command transaction */        void    *ptr;   /* target descriptor of return transaction */    } target;    void        *cookie;    /* target object cookie */    unsigned int    code;       /* transaction command */    /* General information about the transaction. */    unsigned int    flags;    pid_t       sender_pid;    uid_t       sender_euid;    size_t      data_size;  /* number of bytes of data */    size_t      offsets_size;   /* number of bytes of offsets */    /* If this transaction is inline, the data immediately     * follows here; otherwise, it ends with a pointer to     * the data buffer.     */    union {        struct {            /* transaction data */            const void  *buffer;            /* offsets from buffer to flat_binder_object structs */            const void  *offsets;        } ptr;        uint8_t buf[8];    } data;};</code></pre><p><code>flat_binder_object</code> 就被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">*buffer</a>中，其中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L126" target="_blank" rel="noopener">unsigned int   code;</a> 则是传输命令，描述了 Binder 对象执行的操作。</p><h3 id="4-1-binder-设备的创建"><a href="#4-1-binder-设备的创建" class="headerlink" title="4.1 binder 设备的创建"></a>4.1 binder 设备的创建</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3747" target="_blank" rel="noopener">device_initcall()</a> 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。</p><pre><code class="c">static struct miscdevice binder_miscdev = {    .minor = MISC_DYNAMIC_MINOR,    // 设备文件 /dev/binder    .name = &quot;binder&quot;,    // 设备文件操作    .fops = &amp;binder_fops};static int __init binder_init(void){    int ret;    ...    // 注册字符设备    ret = misc_register(&amp;binder_miscdev);    ...    // 调试文件， 在 /sys/kernel/debug/binder 目录下    if (binder_debugfs_dir_entry_root) {        debugfs_create_file(&quot;state&quot;,                    S_IRUGO,                    binder_debugfs_dir_entry_root,                    NULL,                    &amp;binder_state_fops);        ...    }    return ret;}device_initcall(binder_init);</code></pre><p>可以看出 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3704" target="_blank" rel="noopener">binder_init()</a> 使用 <code>misc_register()</code> 函数创建了 binder 设备。从 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3716" target="_blank" rel="noopener">misc_register(&amp;binder_miscdev);</a> 及 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3695" target="_blank" rel="noopener">.name = “binder”</a> 可以看出， binder 向 kernel 注册了一个 <code>/dev/binder</code> 的字符设备，而文件操作都在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中定义。</p><pre><code class="c">static const struct file_operations binder_fops = {    .owner = THIS_MODULE,    .poll = binder_poll,    .unlocked_ioctl = binder_ioctl,    .mmap = binder_mmap,    .open = binder_open,    .flush = binder_flush,    .release = binder_release,};</code></pre><p>从上面 <code>binder_fops</code> 结构体可以看出，主要的操作是 <code>binder_ioctl()</code> <code>binder_mmap()</code> <code>binder_open()</code> 等函数实现的。</p><h3 id="4-2-binder-协议和数据结构"><a href="#4-2-binder-协议和数据结构" class="headerlink" title="4.2 binder 协议和数据结构"></a>4.2 binder 协议和数据结构</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 文件中定义了 binder 协议和重要的数据结构。</p><p>首先在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">enum</a> 中定义了 binder 处理的类型，引用或是句柄</p><pre><code class="c">enum {    BINDER_TYPE_BINDER  = B_PACK_CHARS(&#39;s&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&#39;w&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_HANDLE  = B_PACK_CHARS(&#39;s&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(&#39;w&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_FD      = B_PACK_CHARS(&#39;f&#39;, &#39;d&#39;, &#39;*&#39;, B_TYPE_LARGE),};</code></pre><p>下面这段宏定义则是在 <code>ioctl</code> 函数调用时可用的具体命令。</p><pre><code class="c">#define BINDER_WRITE_READ       _IOWR(&#39;b&#39;, 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT     _IOW(&#39;b&#39;, 3, int64_t)#define BINDER_SET_MAX_THREADS      _IOW(&#39;b&#39;, 5, size_t)#define BINDER_SET_IDLE_PRIORITY    _IOW(&#39;b&#39;, 6, int)#define BINDER_SET_CONTEXT_MGR      _IOW(&#39;b&#39;, 7, int)#define BINDER_THREAD_EXIT      _IOW(&#39;b&#39;, 8, int)#define BINDER_VERSION          _IOWR(&#39;b&#39;, 9, struct binder_version)</code></pre><p>在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L166" target="_blank" rel="noopener">BinderDriverReturnProtocol</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L254" target="_blank" rel="noopener">BinderDriverCommandProtocol</a> 中 则分别定义了 客户端调用 和 服务端 返回的命令。</p><h3 id="4-3-binder-驱动文件操作"><a href="#4-3-binder-驱动文件操作" class="headerlink" title="4.3 binder 驱动文件操作"></a>4.3 binder 驱动文件操作</h3><p>上文已经提到，所有的操作定义在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中，下面讲述这些操作。</p><p><strong>设备的打开 - binder_open() 函数</strong></p><p>用户空间在打开 <code>/dev/binder</code> 设备时，驱动会出发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3004" target="_blank" rel="noopener">binder_open()</a> 函数的响应。</p><pre><code class="c">static int binder_open(struct inode *nodp, struct file *filp){    struct binder_proc *proc;    // 分配 binder_proc 数据结构内存    proc = kzalloc(sizeof(*proc), GFP_KERNEL);    if (proc == NULL)        return -ENOMEM;    // 增加当前线程/进程的引用计数并赋值给tsk    get_task_struct(current);    proc-&gt;tsk = current;    // 初始化队列    INIT_LIST_HEAD(&amp;proc-&gt;todo);    init_waitqueue_head(&amp;proc-&gt;wait);    proc-&gt;default_priority = task_nice(current);    binder_lock(__func__);    // 增加BINDER_STAT_PROC的对象计数    binder_stats_created(BINDER_STAT_PROC);    // 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);    // 保存进程 id    proc-&gt;pid = current-&gt;group_leader-&gt;pid;    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);    // 驱动文件 private_data 指向 proc    filp-&gt;private_data = proc;    binder_unlock(__func__);    return 0;}</code></pre><p><strong>驱动文件释放 - binder_release() 函数</strong></p><p>在用户空间关闭驱动设备文件时，会调用 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3068" target="_blank" rel="noopener">binder_release()</a> 函数，清理 binder_proc 对象，释放占用的内存。</p><pre><code class="c">static int binder_release(struct inode *nodp, struct file *filp){    struct binder_proc *proc = filp-&gt;private_data;    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);    return 0;}static voidbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer){    mutex_lock(&amp;binder_deferred_lock);    proc-&gt;deferred_work |= defer;    if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) {        // 添加到释放队列中        hlist_add_head(&amp;proc-&gt;deferred_work_node,                &amp;binder_deferred_list);        queue_work(binder_deferred_workqueue, &amp;binder_deferred_work);    }    mutex_unlock(&amp;binder_deferred_lock);}</code></pre><p><strong>内存映射 - binder_mmap() 函数</strong></p><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2905" target="_blank" rel="noopener">binder_mmap()</a> 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。</p><pre><code class="c">static int binder_mmap(struct file *filp, struct vm_area_struct *vma){    int ret;    struct vm_struct *area;    // 获得 binder_proc 对象    struct binder_proc *proc = filp-&gt;private_data;    const char *failure_string;    struct binder_buffer *buffer;    // 最多只分配 4M 的内存    if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;    // 检查 flags    if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) {        ret = -EPERM;        failure_string = &quot;bad vm_flags&quot;;        goto err_bad_arg;    }    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;    mutex_lock(&amp;binder_mmap_lock);    // 检查是否已经映射    if (proc-&gt;buffer) {        ret = -EBUSY;        failure_string = &quot;already mapped&quot;;        goto err_already_mapped;    }    // 申请内核虚拟内存空间    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);    if (area == NULL) {        ret = -ENOMEM;        failure_string = &quot;get_vm_area&quot;;        goto err_get_vm_area_failed;    }    // 将申请到的内存地址保存到 binder_proc 对象中    proc-&gt;buffer = area-&gt;addr;    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;    mutex_unlock(&amp;binder_mmap_lock);    // 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针    proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);    if (proc-&gt;pages == NULL) {        ret = -ENOMEM;        failure_string = &quot;alloc page array&quot;;        goto err_alloc_pages_failed;    }    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;    vma-&gt;vm_ops = &amp;binder_vm_ops;    vma-&gt;vm_private_data = proc;    // 分配一个页的物理内存    if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {        ret = -ENOMEM;        failure_string = &quot;alloc small buf&quot;;        goto err_alloc_small_buf_failed;    }    // 内存提供给 binder_buffer    buffer = proc-&gt;buffer;    // 初始化 proc-&gt;buffers 链表    INIT_LIST_HEAD(&amp;proc-&gt;buffers);    // 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);    buffer-&gt;free = 1;    binder_insert_free_buffer(proc, buffer);    proc-&gt;free_async_space = proc-&gt;buffer_size / 2;    barrier();    proc-&gt;files = get_files_struct(proc-&gt;tsk);    proc-&gt;vma = vma;    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;    return 0;}</code></pre><p><strong>驱动命令接口 - binder_ioctl() 函数</strong></p><p>用户态程序调用 <code>ioctl</code> 系统函数向 <code>/dev/binder</code> 设备发送数据时，会触发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2734" target="_blank" rel="noopener">binder_ioctl()</a> 函数响应。</p><p>上文数据结构中已经提到了 <code>binder_ioctl</code> 可以处理的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L87" target="_blank" rel="noopener">命令</a></p><pre><code class="c">// 核心命令，数据的读写#define BINDER_WRITE_READ       _IOWR(&#39;b&#39;, 1, struct binder_write_read)// 设置最大线程数#define BINDER_SET_MAX_THREADS      _IOW(&#39;b&#39;, 5, size_t)// 设置 context manager#define BINDER_SET_CONTEXT_MGR      _IOW(&#39;b&#39;, 7, int)// 线程退出命令#define BINDER_THREAD_EXIT      _IOW(&#39;b&#39;, 8, int)// binder 驱动的版本#define BINDER_VERSION          _IOWR(&#39;b&#39;, 9, struct binder_version)</code></pre><pre><code class="c">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){    int ret;    struct binder_proc *proc = filp-&gt;private_data;    struct binder_thread *thread;    unsigned int size = _IOC_SIZE(cmd);    void __user *ubuf = (void __user *)arg;    // 检查是否有错误    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);    if (ret)        goto err_unlocked;    binder_lock(__func__);    // 获取 binder_thread 对象    thread = binder_get_thread(proc);    if (thread == NULL) {        ret = -ENOMEM;        goto err;    }    switch (cmd) {    case BINDER_WRITE_READ: {        struct binder_write_read bwr;        if (size != sizeof(struct binder_write_read)) {            ret = -EINVAL;            goto err;        }        // 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr        if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {            ret = -EFAULT;            goto err;        }        if (bwr.write_size &gt; 0) {            // 执行写入操作            ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);            if (ret &lt; 0) {                bwr.read_consumed = 0;                if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))                    ret = -EFAULT;                goto err;            }        }        if (bwr.read_size &gt; 0) {            // 执行读取操作            ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);            if (!list_empty(&amp;proc-&gt;todo))                wake_up_interruptible(&amp;proc-&gt;wait);            if (ret &lt; 0) {                if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))                    ret = -EFAULT;                goto err;            }        }        // 操作完成后将数据返回给用户空间        if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {            ret = -EFAULT;            goto err;        }        break;    }    case BINDER_SET_MAX_THREADS:        // 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) {            ret = -EINVAL;            goto err;        }        break;    case BINDER_SET_CONTEXT_MGR:        // 检查是否已经设置        if (binder_context_mgr_node != NULL) {            ret = -EBUSY;            goto err;        }        // 设置 context manager        ret = security_binder_set_context_mgr(proc-&gt;tsk);        if (ret &lt; 0)            goto err;        if (binder_context_mgr_uid != -1) {            if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {                ret = -EPERM;                goto err;            }        } else            binder_context_mgr_uid = current-&gt;cred-&gt;euid;        // 创建 binder_context_mgr_node 节点        binder_context_mgr_node = binder_new_node(proc, NULL, NULL);        if (binder_context_mgr_node == NULL) {            ret = -ENOMEM;            goto err;        }        // 初始化节点数据        binder_context_mgr_node-&gt;local_weak_refs++;        binder_context_mgr_node-&gt;local_strong_refs++;        binder_context_mgr_node-&gt;has_strong_ref = 1;        binder_context_mgr_node-&gt;has_weak_ref = 1;        break;    case BINDER_THREAD_EXIT:        // 线程退出，释放资源        binder_free_thread(proc, thread);        thread = NULL;        break;    case BINDER_VERSION:        // 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中        if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) {            ret = -EINVAL;            goto err;        }        break;    default:        ret = -EINVAL;        goto err;    }    ret = 0;...}</code></pre><pre><code class="c">static struct binder_node *binder_new_node(struct binder_proc *proc,                       void __user *ptr,                       void __user *cookie){    struct rb_node **p = &amp;proc-&gt;nodes.rb_node;    struct rb_node *parent = NULL;    struct binder_node *node;    // 查找要插入节点的父节点    while (*p) {        parent = *p;        node = rb_entry(parent, struct binder_node, rb_node);        if (ptr &lt; node-&gt;ptr)            p = &amp;(*p)-&gt;rb_left;        else if (ptr &gt; node-&gt;ptr)            p = &amp;(*p)-&gt;rb_right;        else            return NULL;    }    // 为要插入节点分配内存空间    node = kzalloc(sizeof(*node), GFP_KERNEL);    if (node == NULL)        return NULL;    binder_stats_created(BINDER_STAT_NODE);    // 插入节点    rb_link_node(&amp;node-&gt;rb_node, parent, p);    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);    // 初始化    node-&gt;debug_id = ++binder_last_id;    node-&gt;proc = proc;    node-&gt;ptr = ptr;    node-&gt;cookie = cookie;    node-&gt;work.type = BINDER_WORK_NODE;    INIT_LIST_HEAD(&amp;node-&gt;work.entry);    INIT_LIST_HEAD(&amp;node-&gt;async_todo);    return node;}</code></pre><p><strong>BINDER_WRITE_READ 处理过程</strong></p><p>在 binder 本地层中，我们看到在 <code>IPCThreadState::talkWithDriver()</code> 函数中， binder 本地层通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 命令的形式，与 binder 驱动交互。</p><p>可以看出 <code>ioctl()</code> 的第三个参数是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L69" target="_blank" rel="noopener">binder_write_read</a> 结构体</p><p>binder.h 头文件中定义了两个数据类型, 一个是 <code>binder_write_read</code></p><pre><code class="c">struct binder_write_read {    signed long write_size; /* bytes to write */    signed long write_consumed; /* bytes consumed by driver */    unsigned long   write_buffer;    signed long read_size;  /* bytes to read */    signed long read_consumed;  /* bytes consumed by driver */    unsigned long   read_buffer;};</code></pre><p>其中 <code>write_size</code> 和 <code>read_size</code> 表示需要被读写的字节数， <code>write_consumed</code> 和 <code>read_consumed</code> 表示已经被 binder 驱动读写的字节数， <code>write_buffer</code> 和 <code>read_buffer</code> 则是指向被读写数据的指针。</p><p>具体的读写操作被 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1852" target="_blank" rel="noopener">binder_thread_write</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2266" target="_blank" rel="noopener">binder_thread_read</a> 实现。</p><p><strong>数据写入 - binder_thread_write() 函数</strong></p><p>将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。</p><pre><code class="c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,            void __user *buffer, int size, signed long *consumed){    uint32_t cmd;    // 用户空间数据，起始地址和结束地址    void __user *ptr = buffer + *consumed;    void __user *end = buffer + size;    // 循环读取    while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {        // 从用户空间获取操作命令        if (get_user(cmd, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);        if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {            // 增加命令计数器            binder_stats.bc[_IOC_NR(cmd)]++;            proc-&gt;stats.bc[_IOC_NR(cmd)]++;            thread-&gt;stats.bc[_IOC_NR(cmd)]++;        }        switch (cmd) {        // 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref        case BC_INCREFS:        case BC_ACQUIRE:        case BC_RELEASE:        case BC_DECREFS: {            uint32_t target;            struct binder_ref *ref;            const char *debug_string;            // 获取目标进程节点描述 desc            if (get_user(target, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 索描述为 0 表示 context manager 进程            if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp;                (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {                // 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用                ref = binder_get_ref_for_node(proc,                           binder_context_mgr_node);            } else                // 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用                ref = binder_get_ref(proc, target);            switch (cmd) {            case BC_INCREFS:                debug_string = &quot;IncRefs&quot;;                // 增加弱引用计数                binder_inc_ref(ref, 0, NULL);                break;            case BC_ACQUIRE:                debug_string = &quot;Acquire&quot;;                // 增加强引用计数                binder_inc_ref(ref, 1, NULL);                break;            case BC_RELEASE:                debug_string = &quot;Release&quot;;                // 减少强引用计数                binder_dec_ref(ref, 1);                break;            case BC_DECREFS:            default:                debug_string = &quot;DecRefs&quot;;                // 减少弱引用计数                binder_dec_ref(ref, 0);                break;            }            break;        }        case BC_INCREFS_DONE:        case BC_ACQUIRE_DONE: {            void __user *node_ptr;            void *cookie;            struct binder_node *node;            // 从用户空间读取 node_ptr            if (get_user(node_ptr, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 从用户空间读取 cookie            if (get_user(cookie, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 获得节点            node = binder_get_node(proc, node_ptr);            // 没有找到则返回            if (node == NULL) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;%s u%p no match\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_INCREFS_DONE ?                    &quot;BC_INCREFS_DONE&quot; :                    &quot;BC_ACQUIRE_DONE&quot;,                    node_ptr);                break;            }            // cookie 不匹配则返回            if (cookie != node-&gt;cookie) {                binder_user_error(&quot;binder: %d:%d %s u%p node %d&quot;                    &quot; cookie mismatch %p != %p\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_INCREFS_DONE ?                    &quot;BC_INCREFS_DONE&quot; : &quot;BC_ACQUIRE_DONE&quot;,                    node_ptr, node-&gt;debug_id,                    cookie, node-&gt;cookie);                break;            }            if (cmd == BC_ACQUIRE_DONE) {                node-&gt;pending_strong_ref = 0;            } else {                node-&gt;pending_weak_ref = 0;            }            // 减少节点使用计数            binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);            break;        }        // 释放 binder_bffer        case BC_FREE_BUFFER: {            void __user *data_ptr;            struct binder_buffer *buffer;            // 从用户空间获取 data_ptr            if (get_user(data_ptr, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 查找 binder_buffer            buffer = binder_buffer_lookup(proc, data_ptr);            // 没有找到则返回            if (buffer == NULL) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;BC_FREE_BUFFER u%p no match\n&quot;,                    proc-&gt;pid, thread-&gt;pid, data_ptr);                break;            }            // 不允许用户释放则返回            if (!buffer-&gt;allow_user_free) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;BC_FREE_BUFFER u%p matched &quot;                    &quot;unreturned buffer\n&quot;,                    proc-&gt;pid, thread-&gt;pid, data_ptr);                break;            }            // 将 buffer-&gt;transaction 置空            if (buffer-&gt;transaction) {                buffer-&gt;transaction-&gt;buffer = NULL;                buffer-&gt;transaction = NULL;            }            if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) {                if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))                    buffer-&gt;target_node-&gt;has_async_transaction = 0;                else                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);            }            // 释放 binder_buffer 对象            trace_binder_transaction_buffer_release(buffer);            binder_transaction_buffer_release(proc, buffer, NULL);            binder_free_buf(proc, buffer);            break;        }        // binder 数据传递处理        case BC_TRANSACTION:        case BC_REPLY: {            struct binder_transaction_data tr;            // 从用户空间拷贝 binder_transaction_data 对象            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))                return -EFAULT;            ptr += sizeof(tr);            // 实际的传输函数，在下文讲解            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);            break;        }        // 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态        case BC_REGISTER_LOOPER:            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_REGISTER_LOOPER called &quot;                    &quot;after BC_ENTER_LOOPER\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            } else if (proc-&gt;requested_threads == 0) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_REGISTER_LOOPER called &quot;                    &quot;without request\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            } else {                proc-&gt;requested_threads--;                proc-&gt;requested_threads_started++;            }            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;            break;        // 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态        case BC_ENTER_LOOPER:            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_ENTER_LOOPER called after &quot;                    &quot;BC_REGISTER_LOOPER\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            }            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;            break;        // 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态        case BC_EXIT_LOOPER:            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;            break;        // 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知        case BC_REQUEST_DEATH_NOTIFICATION:        case BC_CLEAR_DEATH_NOTIFICATION: {            uint32_t target;            void __user *cookie;            struct binder_ref *ref;            struct binder_ref_death *death;            // 从用户空间获取 binder_ref 描述 desc            if (get_user(target, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 从用户空间获取 cookie            if (get_user(cookie, (void __user * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 获取 binder_ref 引用            ref = binder_get_ref(proc, target);            if (ref == NULL) {                binder_user_error(&quot;binder: %d:%d %s &quot;                    &quot;invalid ref %d\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?                    &quot;BC_REQUEST_DEATH_NOTIFICATION&quot; :                    &quot;BC_CLEAR_DEATH_NOTIFICATION&quot;,                    target);                break;            }            if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {                if (ref-&gt;death) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_REQUEST_DEATH_NOTI&quot;                        &quot;FICATION death notific&quot;                        &quot;ation already set\n&quot;,                        proc-&gt;pid, thread-&gt;pid);                    break;                }                // 为 binder_ref_death 对象分配内存空间                death = kzalloc(sizeof(*death), GFP_KERNEL);                if (death == NULL) {                    thread-&gt;return_error = BR_ERROR;                    break;                }                // 初始化 binder_ref_death 对象                binder_stats_created(BINDER_STAT_DEATH);                INIT_LIST_HEAD(&amp;death-&gt;work.entry);                death-&gt;cookie = cookie;                ref-&gt;death = death;                if (ref-&gt;node-&gt;proc == NULL) {                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);                    } else {                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);                        // 唤醒目标进程                        wake_up_interruptible(&amp;proc-&gt;wait);                    }                }            } else {                if (ref-&gt;death == NULL) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_CLEAR_DEATH_NOTIFI&quot;                        &quot;CATION death notificat&quot;                        &quot;ion not active\n&quot;,                        proc-&gt;pid, thread-&gt;pid);                    break;                }                death = ref-&gt;death;                if (death-&gt;cookie != cookie) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_CLEAR_DEATH_NOTIFI&quot;                        &quot;CATION death notificat&quot;                        &quot;ion cookie mismatch &quot;                        &quot;%p != %p\n&quot;,                        proc-&gt;pid, thread-&gt;pid,                        death-&gt;cookie, cookie);                    break;                }                // 将 ref-&gt;death 置空                ref-&gt;death = NULL;                if (list_empty(&amp;death-&gt;work.entry)) {                    death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);                    } else {                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);                        // 唤醒目标进程                        wake_up_interruptible(&amp;proc-&gt;wait);                    }                } else {                    BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);                    death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;                }            }        } break;        case BC_DEAD_BINDER_DONE: {            struct binder_work *w;            void __user *cookie;            struct binder_ref_death *death = NULL;            // 从用户空间获取 cookie            if (get_user(cookie, (void __user * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) {                struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);                if (tmp_death-&gt;cookie == cookie) {                    death = tmp_death;                    break;                }            }            if (death == NULL) {                binder_user_error(&quot;binder: %d:%d BC_DEAD&quot;                    &quot;_BINDER_DONE %p not found\n&quot;,                    proc-&gt;pid, thread-&gt;pid, cookie);                break;            }            list_del_init(&amp;death-&gt;work.entry);            // 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION            if (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) {                death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;                if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);                } else {                    list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);                    // 唤醒目标进程                    wake_up_interruptible(&amp;proc-&gt;wait);                }            }        } break;        default:            return -EINVAL;        }        *consumed = ptr - buffer;    }    return 0;}</code></pre><p><strong>binder_transaction() 函数</strong></p><p>在上文处理 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2041" target="_blank" rel="noopener">BC_TRANSACTION</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2042" target="_blank" rel="noopener">BC_REPLY</a> 时，调用了 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1417" target="_blank" rel="noopener">binder_transaction()</a> 函数。我们继续追踪</p><pre><code class="c">static void binder_transaction(struct binder_proc *proc,                   struct binder_thread *thread,                   struct binder_transaction_data *tr, int reply){    struct binder_transaction *t;    struct binder_work *tcomplete;    size_t *offp, *off_end;    struct binder_proc *target_proc;    struct binder_thread *target_thread = NULL;    struct binder_node *target_node = NULL;    struct list_head *target_list;    wait_queue_head_t *target_wait;    struct binder_transaction *in_reply_to = NULL;    if (reply) {        // BC_REPLY 处理流程        // 得到 binder_transaction 对象        in_reply_to = thread-&gt;transaction_stack;        if (in_reply_to == NULL) {            return_error = BR_FAILED_REPLY;            goto err_empty_call_stack;        }        binder_set_nice(in_reply_to-&gt;saved_priority);        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;        // 获取目标线程        target_thread = in_reply_to-&gt;from;        target_proc = target_thread-&gt;proc;    } else {        // BC_TRANSACTION 处理流程        // 查找目标节点        if (tr-&gt;target.handle) {            struct binder_ref *ref;            // 获取 binder_ref 对象            ref = binder_get_ref(proc, tr-&gt;target.handle);            target_node = ref-&gt;node;        } else {            // 索引为 0 则返回 context manager            target_node = binder_context_mgr_node;        }        // 得到目标进程        target_proc = target_node-&gt;proc;        if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) {            struct binder_transaction *tmp;            tmp = thread-&gt;transaction_stack;            while (tmp) {                if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)                    // 获得目标线程                    target_thread = tmp-&gt;from;                tmp = tmp-&gt;from_parent;            }        }    }    // 设置要处理的目标进程或目标线程任务    if (target_thread) {        target_list = &amp;target_thread-&gt;todo;        target_wait = &amp;target_thread-&gt;wait;    } else {        target_list = &amp;target_proc-&gt;todo;        target_wait = &amp;target_proc-&gt;wait;    }    // 为 binder_transaction 对象分配内存空间    t = kzalloc(sizeof(*t), GFP_KERNEL);    binder_stats_created(BINDER_STAT_TRANSACTION);    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);    // 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))        t-&gt;from = thread;    else        t-&gt;from = NULL;    // 设置 binder_transaction 对象    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;    t-&gt;to_proc = target_proc;    t-&gt;to_thread = target_thread;    t-&gt;code = tr-&gt;code;    t-&gt;flags = tr-&gt;flags;    t-&gt;priority = task_nice(current);    // 为 binder_buffer 分配内存空间    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));    // 设置 binder_buffer    t-&gt;buffer-&gt;allow_user_free = 0;    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;    t-&gt;buffer-&gt;transaction = t;    t-&gt;buffer-&gt;target_node = target_node;    if (target_node)        binder_inc_node(target_node, 1, 0, NULL);    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));    // 从用户空间拷贝数据到 binder_buffer    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {        return_error = BR_FAILED_REPLY;        goto err_copy_data_failed;    }    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {        return_error = BR_FAILED_REPLY;        goto err_copy_data_failed;    }    off_end = (void *)offp + tr-&gt;offsets_size;    for (; offp &lt; off_end; offp++) {        struct flat_binder_object *fp;        // 为 flat_binder_object 赋值        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);        // 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE        switch (fp-&gt;type) {        case BINDER_TYPE_BINDER:        case BINDER_TYPE_WEAK_BINDER: {            struct binder_ref *ref;            // 获取 binder_node 节点            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);            if (node == NULL) {                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);                if (node == NULL) {                    return_error = BR_FAILED_REPLY;                    goto err_binder_new_node_failed;                }                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);            }            if (fp-&gt;cookie != node-&gt;cookie) {                goto err_binder_get_ref_for_node_failed;            }            // 获取 binder_ref 对象            ref = binder_get_ref_for_node(target_proc, node);            // 转换类型            if (fp-&gt;type == BINDER_TYPE_BINDER)                fp-&gt;type = BINDER_TYPE_HANDLE;            else                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;            fp-&gt;handle = ref-&gt;desc;            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,                       &amp;thread-&gt;todo);        } break;        case BINDER_TYPE_HANDLE:        case BINDER_TYPE_WEAK_HANDLE: {            // 获取 binder_ref 对象            struct binder_ref*ref = binder_get_ref(proc, fp-&gt;handle);            // 转换类型            if (ref-&gt;node-&gt;proc == target_proc) {                if (fp-&gt;type == BINDER_TYPE_HANDLE)                    fp-&gt;type = BINDER_TYPE_BINDER;                else                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;                fp-&gt;binder = ref-&gt;node-&gt;ptr;                fp-&gt;cookie = ref-&gt;node-&gt;cookie;                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, NULL);            } else {                struct binder_ref *new_ref;                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);                fp-&gt;handle = new_ref-&gt;desc;                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);            }        } break;        // 文件类型        case BINDER_TYPE_FD: {            int target_fd;            struct file *file;            // 获得文件对象            file = fget(fp-&gt;handle);            // 分配一个新的文件描述符            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);            task_fd_install(target_proc, target_fd, file);            fp-&gt;handle = target_fd;        } break;        default:            return_error = BR_FAILED_REPLY;            goto err_bad_object_type;        }    }    if (reply) {        // BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象        binder_pop_transaction(target_thread, in_reply_to);    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {        // 同步状态(双向)需要设置回复        t-&gt;need_reply = 1;        t-&gt;from_parent = thread-&gt;transaction_stack;        thread-&gt;transaction_stack = t;    } else {        // 异步传输不需要设置回复        if (target_node-&gt;has_async_transaction) {            target_list = &amp;target_node-&gt;async_todo;            target_wait = NULL;        } else            target_node-&gt;has_async_transaction = 1;    }    t-&gt;work.type = BINDER_WORK_TRANSACTION;    list_add_tail(&amp;t-&gt;work.entry, target_list);    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);    if (target_wait)        // 唤醒目标线程        wake_up_interruptible(target_wait);    return;}</code></pre><p><strong>数据读取 - binder_thread_read() 函数</strong></p><p>用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。</p><pre><code class="c">static int binder_thread_read(struct binder_proc *proc,                  struct binder_thread *thread,                  void  __user *buffer, int size,                  signed long *consumed, int non_block){    void __user *ptr = buffer + *consumed;    void __user *end = buffer + size;    int ret = 0;    int wait_for_proc_work;    if (*consumed == 0) {        // 第一次操作时向用户空间返回 BR_NOOP 命令        if (put_user(BR_NOOP, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);    }retry:    // 获取将要处理的任务    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;                list_empty(&amp;thread-&gt;todo);    if (wait_for_proc_work) {        if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |                    BINDER_LOOPER_STATE_ENTERED))) {            binder_user_error(&quot;binder: %d:%d ERROR: Thread waiting &quot;                &quot;for process work before calling BC_REGISTER_&quot;                &quot;LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;,                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);            wait_event_interruptible(binder_user_error_wait,                         binder_stop_on_user_error &lt; 2);        }        binder_set_nice(proc-&gt;default_priority);        if (non_block) {            // 非阻塞且没有数据则返回 EAGAIN            if (!binder_has_proc_work(proc, thread))                ret = -EAGAIN;        } else            // 阻塞则进入睡眠状态，等待可操作的任务            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));    } else {        if (non_block) {            if (!binder_has_thread_work(thread))                ret = -EAGAIN;        } else            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));    }    binder_lock(__func__);    if (wait_for_proc_work)        proc-&gt;ready_threads--;    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;    if (ret)        return ret;    while (1) {        uint32_t cmd;        struct binder_transaction_data tr;        struct binder_work *w;        struct binder_transaction *t = NULL;        // 获取 binder_work 对象        if (!list_empty(&amp;thread-&gt;todo))            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);        else {            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */                goto retry;            break;        }        if (end - ptr &lt; sizeof(tr) + 4)            break;        switch (w-&gt;type) {        case BINDER_WORK_TRANSACTION: {            // 获取 binder_transaction 对象            t = container_of(w, struct binder_transaction, work);        } break;        case BINDER_WORK_TRANSACTION_COMPLETE: {            cmd = BR_TRANSACTION_COMPLETE;            // 返回 BR_TRANSACTION_COMPLETE 命令            if (put_user(cmd, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            binder_stat_br(proc, thread, cmd);            // 从 work 链表中删除并释放内存            list_del(&amp;w-&gt;entry);            kfree(w);            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);        } break;        case BINDER_WORK_NODE: {            // 获得 binder_node 节点            struct binder_node *node = container_of(w, struct binder_node, work);            uint32_t cmd = BR_NOOP;            const char *cmd_name;            // 根据节点类型，增加/获取、减少/释放节点索引            int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs;            int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong;            // 构造 BR_* 命令            if (weak &amp;&amp; !node-&gt;has_weak_ref) {                cmd = BR_INCREFS;                cmd_name = &quot;BR_INCREFS&quot;;                node-&gt;has_weak_ref = 1;                node-&gt;pending_weak_ref = 1;                node-&gt;local_weak_refs++;            } else if (strong &amp;&amp; !node-&gt;has_strong_ref) {                cmd = BR_ACQUIRE;                cmd_name = &quot;BR_ACQUIRE&quot;;                node-&gt;has_strong_ref = 1;                node-&gt;pending_strong_ref = 1;                node-&gt;local_strong_refs++;            } else if (!strong &amp;&amp; node-&gt;has_strong_ref) {                cmd = BR_RELEASE;                cmd_name = &quot;BR_RELEASE&quot;;                node-&gt;has_strong_ref = 0;            } else if (!weak &amp;&amp; node-&gt;has_weak_ref) {                cmd = BR_DECREFS;                cmd_name = &quot;BR_DECREFS&quot;;                node-&gt;has_weak_ref = 0;            }            // 向用户空间返回命令            if (cmd != BR_NOOP) {                if (put_user(cmd, (uint32_t __user *)ptr))                    return -EFAULT;                ptr += sizeof(uint32_t);                if (put_user(node-&gt;ptr, (void * __user *)ptr))                    return -EFAULT;                ptr += sizeof(void *);                if (put_user(node-&gt;cookie, (void * __user *)ptr))                    return -EFAULT;                ptr += sizeof(void *);                binder_stat_br(proc, thread, cmd);            } else {                list_del_init(&amp;w-&gt;entry);                if (!weak &amp;&amp; !strong) {                    rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);                    kfree(node);                    binder_stats_deleted(BINDER_STAT_NODE);                }            }        } break;        case BINDER_WORK_DEAD_BINDER:        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {            struct binder_ref_death *death;            uint32_t cmd;            // 获取 binder_ref_death 对象            death = container_of(w, struct binder_ref_death, work);            // 构造返回命令            if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;            else                cmd = BR_DEAD_BINDER;            // 向用户空间返回命令            if (put_user(cmd, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 将 cookie 返回给用户空间            if (put_user(death-&gt;cookie, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            binder_stat_br(proc, thread, cmd);            if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {                list_del(&amp;w-&gt;entry);                kfree(death);                binder_stats_deleted(BINDER_STAT_DEATH);            } else                list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);            if (cmd == BR_DEAD_BINDER)                goto done; /* DEAD_BINDER notifications can cause transactions */        } break;        }        if (!t)            continue;        if (t-&gt;buffer-&gt;target_node) {            // 获得 binder_node 节点            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;            // 将数据封装到 binder_transaction_data 对象            tr.target.ptr = target_node-&gt;ptr;            tr.cookie =  target_node-&gt;cookie;            t-&gt;saved_priority = task_nice(current);            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;                !(t-&gt;flags &amp; TF_ONE_WAY))                binder_set_nice(t-&gt;priority);            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)                binder_set_nice(target_node-&gt;min_priority);            // 设置返回的命令类型            cmd = BR_TRANSACTION;        } else {            tr.target.ptr = NULL;            tr.cookie = NULL;            cmd = BR_REPLY;        }        tr.code = t-&gt;code;        tr.flags = t-&gt;flags;        tr.sender_euid = t-&gt;sender_euid;        if (t-&gt;from) {            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;            tr.sender_pid = task_tgid_nr_ns(sender,                            current-&gt;nsproxy-&gt;pid_ns);        } else {            tr.sender_pid = 0;        }        tr.data_size = t-&gt;buffer-&gt;data_size;        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +                    proc-&gt;user_buffer_offset;        tr.data.ptr.offsets = tr.data.ptr.buffer +                    ALIGN(t-&gt;buffer-&gt;data_size,                        sizeof(void *));        if (put_user(cmd, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);        // 拷贝 binder_transaction_data 对象到用户空间        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))            return -EFAULT;        ptr += sizeof(tr);        binder_stat_br(proc, thread, cmd);        // 移除 binder_transaction 并释放空间        list_del(&amp;t-&gt;work.entry);        t-&gt;buffer-&gt;allow_user_free = 1;        // 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {            t-&gt;to_parent = thread-&gt;transaction_stack;            t-&gt;to_thread = thread;            thread-&gt;transaction_stack = t;        } else {            t-&gt;buffer-&gt;transaction = NULL;            kfree(t);            binder_stats_deleted(BINDER_STAT_TRANSACTION);        }        break;    }}</code></pre><p>从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。</p><h2 id="5-Binder-与系统服务"><a href="#5-Binder-与系统服务" class="headerlink" title="5. Binder 与系统服务"></a>5. Binder 与系统服务</h2><h3 id="5-1-Context-getSystemService"><a href="#5-1-Context-getSystemService" class="headerlink" title="5.1 Context.getSystemService()"></a>5.1 Context.getSystemService()</h3><p>Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.Class&lt;T" target="_blank" rel="noopener">服务</a>) 主要有 <code>WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager</code></p><p>我们可以通过 <code>Context.getSystemService(String name)</code> 来获取 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String" target="_blank" rel="noopener">服务</a>)。</p><p>例如 可以通过如下方法从 xml 中插入新的视图</p><pre><code>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);inflater.inflate(R.layout.view, root, true);</code></pre><h3 id="5-2-Context-getSystemService-源码分析"><a href="#5-2-Context-getSystemService-源码分析" class="headerlink" title="5.2 Context.getSystemService() 源码分析"></a>5.2 Context.getSystemService() 源码分析</h3><p>追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1364" target="_blank" rel="noopener">ContextImpl</a> <code>getSystemService()</code> 源代码</p><pre><code class="java">    @Override    public Object getSystemService(String name) {        return SystemServiceRegistry.getSystemService(this, name);    }</code></pre><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L719" target="_blank" rel="noopener">SystemServiceRegistry</a> 源代码</p><pre><code class="java">    /**     * Gets a system service from a given context.     */    public static Object getSystemService(ContextImpl ctx, String name) {        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);        return fetcher != null ? fetcher.getService(ctx) : null;    }</code></pre><p>追踪 <code>SYSTEM_SERVICE_FETCHERS</code> 可以发现在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L318" target="_blank" rel="noopener">SystemServiceRegistry</a> 静态区中注册了几乎所有的系统服务</p><pre><code class="java">    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,            new CachedServiceFetcher&lt;LayoutInflater&gt;() {        @Override        public LayoutInflater createService(ContextImpl ctx) {            return new PhoneLayoutInflater(ctx.getOuterContext());        }});    registerService(Context.LOCATION_SERVICE, LocationManager.class,            new CachedServiceFetcher&lt;LocationManager&gt;() {        @Override        public LocationManager createService(ContextImpl ctx) {            IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);            return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));        }});</code></pre><p>上面代码片断中，<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L322" target="_blank" rel="noopener">PhoneLayoutInflater</a> 最终回到了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/view/LayoutInflater.java#L204" target="_blank" rel="noopener">LayoutInflater</a>。而 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/LocationManager.java#L315" target="_blank" rel="noopener">LocationManager</a> 则是对 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/ILocationManager.aidl#L39" target="_blank" rel="noopener">ILocationManager</a> 的封装。可以发现，在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/location/java/android/location" target="_blank" rel="noopener">frameworks/base/location/java/android/location</a> 包下含有大量的 AIDL 文件。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L49" target="_blank" rel="noopener">ServiceManager.getService(Context.LOCATION_SERVICE)</a> </p><pre><code class="java">    private static IServiceManager getIServiceManager() {        if (sServiceManager != null) {            return sServiceManager;        }        // Find the service manager        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());        return sServiceManager;    }    /**     * Returns a reference to a service with the given name.     *      * @param name the name of the service to get     * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&#39;t exist     */    public static IBinder getService(String name) {        try {            IBinder service = sCache.get(name);            if (service != null) {                return service;            } else {                return getIServiceManager().getService(name);            }        } catch (RemoteException e) {            Log.e(TAG, &quot;error in getService&quot;, e);        }        return null;    }</code></pre><p>从上面代码片断可以看出，<code>ServiceManager</code> 会从 <code>sCache</code> 缓存或 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">IServiceManager</a> 中查找服务并返回一个 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L85" target="_blank" rel="noopener">IBinder</a> 对象。这个 <code>IBinder</code> 就是一个远程对象，可以通过它与其他进程交互。 </p><p>继续深入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L55" target="_blank" rel="noopener">getIServiceManager().getService(name)</a> , 进入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">ServiceManagerNative</a> </p><pre><code class="java">    /**     * Cast a Binder object into a service manager interface, generating     * a proxy if needed.     */    static public IServiceManager asInterface(IBinder obj)    {        if (obj == null) {            return null;        }        IServiceManager in =            (IServiceManager)obj.queryLocalInterface(descriptor);        if (in != null) {            return in;        }        return new ServiceManagerProxy(obj);    }    class ServiceManagerProxy implements IServiceManager {        public ServiceManagerProxy(IBinder remote) {            mRemote = remote;        }        public IBinder asBinder() {            return mRemote;        }        public IBinder getService(String name) throws RemoteException {            Parcel data = Parcel.obtain();            Parcel reply = Parcel.obtain();            data.writeInterfaceToken(IServiceManager.descriptor);            data.writeString(name);            mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);            IBinder binder = reply.readStrongBinder();            reply.recycle();            data.recycle();            return binder;        }        private IBinder mRemote;    }</code></pre><p>从上边代码片断可以看到，<code>ServiceManager.getIServiceManager()</code> 返回的是一个 <code>ServiceManagerProxy</code>, 而 <code>ServiceManager.getService()</code> 则是在 <code>ServiceManagerProxy</code> 中通过 <code>ServiceManager</code> 的远程 <code>Binder</code> 对象 <code>mRemote</code>，操作 <code>Parcel</code> 数据，调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L223" target="_blank" rel="noopener">IBinder.transact(int code, Parcel data, Parcel reply, int flags)</a> 方法来发送请求，并通过 <code>reply.readStrongBinder()</code> 返回了要查找的服务的远程对象。</p><p>可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。</p><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。</p><p>2. 上层的 <code>android.os.Binder</code> 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。</p><p>3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 <code>transact</code> 和 <code>onTransact</code> 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><a href="http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/" target="_blank" rel="noopener">Android Binder机制</a></p><p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder</a></p><p><a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Android_Architecture_Binder.pdf" target="_blank" rel="noopener">Android Architecture Binder</a></p><p><a href="http://liuxiangtian.github.io/2016/01/07/AIDL%E4%B8%8EBinder%E6%A1%86%E6%9E%B6%E6%B5%85%E8%B0%88/" target="_blank" rel="noopener">AIDL与Binder框架浅谈</a></p><p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a></p><p><a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf" target="_blank" rel="noopener">Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013</a></p><p><a href="https://www.youtube.com/watch?v=NWhyADzgoiI" target="_blank" rel="noopener">Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video)</a></p><p><a href="http://blog.csdn.net/u010961631/article/details/20479507" target="_blank" rel="noopener">Binder源码分析之驱动层（原）</a></p><p><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a></p><p><a href="http://blog.csdn.net/qq429205464/article/details/7822442" target="_blank" rel="noopener">构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解</a></p><p><a href="http://blog.csdn.net/21cnbao/article/details/8087354" target="_blank" rel="noopener">Service与Android系统设计（7）— Binder驱动</a></p><p><a href="https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://www.cnblogs.com/zhangxinyan/p/3487889.html" target="_blank" rel="noopener">Binder机制，从Java到C （7. Native Service）</a></p><hr><p><strong>待补充的内容</strong></p><p>1. 客户端 bindService() 流程及源码分析</p><p>2. Binder Native 层其他源码文件分析</p><p>3. 系统服务（SystemService）详细列表及在本地层的源码分析</p><p>4. SystemManager 源码分析</p><p>5. 完善 binder 驱动内容，补充关系图</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;forked from &lt;a href=&quot;https://github.com/xdtianyu/SourceAnalysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xdtianyu/SourceAnalysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是基于 &lt;a href=&quot;https://github.com/xdtianyu/android-6.0.0_r1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 6.0.0&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel 3.4&lt;/a&gt; 源码 及 Android SDK 23 展开的。&lt;/p&gt;
&lt;p&gt;先上一张图，直白的了解 Binder 通信过程。(摘自&lt;a href=&quot;http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;超详细 Android 面试的准备与经历分享 | 百度 (offer)&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/学习资料/面试小札/Binder通信过程.png&quot; alt&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Binder" scheme="https://yangxiaoge.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android O上手体验</title>
    <link href="https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O上手体验/</id>
    <published>2017-05-19T13:34:15.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 <a href="http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">stormzhang</a> （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。<a id="more"></a><br>有几个重要的事件：Google AI，Android O，Kotlin，等等<br>本文重点是 Android O 的上手视频，迫不及待的把测试机 Nexus 5X 刷成了 Android 0，<a href="https://developer.android.com/preview/download.html" target="_blank" rel="noopener">Android O 系统映像文件下载</a>，官网介绍特性：<a href="https://developer.android.com/preview/index.html" target="_blank" rel="noopener">Android O 新特性介绍</a>。</p><p><strong>上手视频：</strong><br><!--<video height="800" controls>    <source src="/img/video/Android8.0device-2017-05-19-131435.mp4"></video>--><br><!--宽占满，高度自适应。 poster 预加载显示的图像--></p><video height="700" id="video" controls preload="none" poster="/img/video/Android_O_Preload.png"><br>      <source id="mp4" src="/img/video/Android8.0device-2017-05-19-131435.mp4" type="video/mp4"><br></video>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 &lt;a href=&quot;http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stormzhang&lt;/a&gt; （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。
    
    </summary>
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/categories/Android-O/"/>
    
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/tags/Android-O/"/>
    
  </entry>
  
  <entry>
    <title>Android输入法加密研究</title>
    <link href="https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android%E8%BE%93%E5%85%A5%E6%B3%95%E5%8A%A0%E5%AF%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android输入法加密研究/</id>
    <published>2017-05-09T09:51:03.000Z</published>
    <updated>2019-03-14T01:40:22.198Z</updated>
    
    <content type="html"><![CDATA[<p>近期接到一个微信，QQ 聊天时加密文字的需求。<br>我当时的心情是这样的：<br><img src="/img/Android输入法加密研究/kidding_me.png" width="150" alt="are you kidding me?" align="center"><br><a id="more"></a></p><h2 id="开源项目入手"><a href="#开源项目入手" class="headerlink" title="开源项目入手"></a>开源项目入手</h2><p>冷静下来，细细思考，要不开发一个输入法？我这是要挑战搜狗输入法一个团队吗，不现实呀！然后就找到了 Goolge 开源的 PinyinIME（Android 4.4.4）。<br>毕竟输入法将输入的文字设置到编辑框要走 BaseInputConnection 中 commitText 方法，那么我就想在这个地方动手脚呗。嗯，说干就干，我就撸了一下 PinyinIME 项目中的代码，实现效果如下：(加密后的文字后面我加了一个 “中” 字)<br><img src="/img/Android输入法加密研究/撸了个加密.png" width="350" alt="加密前后" align="center"></p><p>哎呦，看着也还凑活哈。嗯，然后打开搜狗，百度输入法一看，用户就不乐意了，你家输入法真挫！一怒之下不用了。虽然这是个笑话，但是开发输入法代价太大了，毕竟要大量时间，人力。</p><h2 id="源码分析入手"><a href="#源码分析入手" class="headerlink" title="源码分析入手"></a>源码分析入手</h2><p>所以啊，我想要不从系统层入手？（<a href="https://developer.android.com/reference/android/inputmethodservice/InputMethodService.html?hl=zh-cn" target="_blank" rel="noopener">查了下 Api</a>）</p><ul><li><p><code>frameworks/base/...</code> 下有个类 <code>InputMethodManager</code> (输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的 context 中，用来沟通管理所有进程间交互的全局系统服务。) 中有个方法 showSoftInput (View view, int flags, ResultReceiver resultReceiver)。 注意到一个 view 参数，此参数就是输入框（微信，QQ，等输入框，webview除外）的 View，既然有了 view，那么我就可以 getText，setText 等等操作。<br>我将 view 中的内容 Toast 出来效果如下：<br><img src="/img/Android输入法加密研究/input_method2.png" width="350" alt="InputMethodManager中获取输入框对象，随时可以获取文本" align="center"></p></li><li><p><code>InputMethodService</code>，每个<code>输入法 App</code> 应用都是继承自它！那么就可以对它的生命周期下手了。输入法显示的时候开启一个自定义的服务（有悬浮窗的），输入法关闭的时候结束服务并且释放相应的静态变量。重点就在于生命周期的研究！</p></li><li><p>目的是，将 <code>InputMethodManager</code> 中的 编辑框 View 对象存起来，然后在 InputMethodService 中启动的服务 暂且叫做 <code>MyFloatEncryService</code> 中获取这个 View，之后就直接可以 get，set 加密了。</p></li></ul><p>实现方案在开发中，后续补充~~~ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期接到一个微信，QQ 聊天时加密文字的需求。&lt;br&gt;我当时的心情是这样的：&lt;br&gt;&lt;img src=&quot;/img/Android输入法加密研究/kidding_me.png&quot; width=&quot;150&quot; alt=&quot;are you kidding me?&quot; align=&quot;center&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/categories/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
</feed>
