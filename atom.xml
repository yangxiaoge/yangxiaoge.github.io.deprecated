<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>珠珠のBlog</title>
  <icon>https://www.gravatar.com/avatar/4ec65d784d203bac0fd2da7375835dff</icon>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangxiaoge.github.io/"/>
  <updated>2018-01-19T01:09:00.450Z</updated>
  <id>https://yangxiaoge.github.io/</id>
  
  <author>
    <name>Bruce Yang</name>
    <email>yang.jianan0926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nice git log</title>
    <link href="https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/"/>
    <id>https://yangxiaoge.github.io/2017/12/13/2017-12-13-nice-git-log/</id>
    <published>2017-12-13T10:11:01.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。</p><p>开发中查看提交记录是家常便饭了，<code>git log</code> 命令是查看全部提交日志，<code>git log -2</code>  查看最近 2 次的提交日志，<code>git log -p</code>  查看历史纪录以来哪几行被修改，<code>git log --stat --summary</code> 查看每个版本变动的档案和行数。</p><p>Git 默认的 git log 是这样子的，emmmmmm….. 丑</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e2fcca990.png"></div><p>于是乎 Google 了一个 git 配置，打开终端，输入以下命令。</p><pre><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></pre><p>以后在终端输入 git lg，就能看到下面漂亮的 git log 了。</p><div align="center"><img src="https://i.loli.net/2017/12/14/5a31e32602b21.png"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git 是一个强大的版本管理器，自从用上 git 后，腰不酸腿不疼了。&lt;/p&gt;
&lt;p&gt;开发中查看提交记录是家常便饭了，&lt;code&gt;git log&lt;/code&gt; 命令是查看全部提交日志，&lt;code&gt;git log -2&lt;/code&gt;  查看最近 2 次的提交日志，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://yangxiaoge.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Android Launcher 界面添加未接来电/未读短信条数显示</title>
    <link href="https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-%E7%95%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0%E6%9C%AA%E6%8E%A5%E6%9D%A5%E7%94%B5-%E6%9C%AA%E8%AF%BB%E7%9F%AD%E4%BF%A1%E6%9D%A1%E6%95%B0%E6%98%BE%E7%A4%BA/"/>
    <id>https://yangxiaoge.github.io/2017/10/19/2017-10-19-Android-Launcher-界面添加未接来电-未读短信条数显示/</id>
    <published>2017-10-19T16:00:50.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Thumbnail by <a href="https://octiviotti.deviantart.com/" target="_blank" rel="noopener">octiviotti</a></p></blockquote><p>本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。</p><p>涉及到几个文件：<br><a id="more"></a></p><ol><li>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</li><li>packages/apps/Launcher3/src/com/android/launcher3/Utilities.java</li><li>packages/apps/Launcher3/AndroidManifest.xml </li></ol><p>具体的思路：<code>Launcher</code> 中注册 <code>ContentObserver</code> 来监听短信和电话数据库，当数据发生变化时，读取读取数据库未读数目之后通过 ICON_NAME ，<code>重新绘制</code>短信，电话的图标（在原图右上角画圆和数字）。</p><hr><p>具体代码：</p><h3 id="1-Launcher-java"><a href="#1-Launcher-java" class="headerlink" title="1. Launcher.java"></a>1. Launcher.java</h3><ul><li>首先是定义两个 ContentObserver</li></ul><pre><code>private final static int UPDATE_MMS_ICON = 826;  private final static int UPDATE_CALL_ICON = 1206;public class SMSContentObserver extends ContentObserver {    private Handler mHandler;    public SMSContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;SMSContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_MMS_ICON);        Message msg = mHandler.obtainMessage(UPDATE_MMS_ICON);        msg.obj = getMissMmsCount();        mHandler.sendMessage(msg);    }}public class CallContentObserver extends ContentObserver {    private Handler mHandler;    public CallContentObserver(Context context, Handler handler) {        super(handler);        mHandler = handler;    }    @Override    public void onChange(boolean selfChange) {        Log.i(&quot;Launcher-&quot;,&quot;CallContentObserver onChange&quot;);        mHandler.removeMessages(UPDATE_CALL_ICON);        Message msg = mHandler.obtainMessage(UPDATE_CALL_ICON);        msg.obj = getMissCallCount();        mHandler.sendMessage(msg);    }}</code></pre><ul><li>在 onCreate() 中注册 ContentObserver</li></ul><pre><code>private SMSContentObserver smsContentObserver = null;  private CallContentObserver callContentObserver = null;  smsContentObserver = new SMSContentObserver(this,mHandler);callContentObserver =new CallContentObserver(this,mHandler);getContentResolver().registerContentObserver(Calls.CONTENT_URI,true,callContentObserver);getContentResolver().registerContentObserver(Uri.parse(&quot;content://mms-sms/&quot;),true,smsContentObserver);</code></pre><ul><li>定义两个 ICON_NAME</li></ul><pre><code>// 这两个 ICON_NAME 根据自己实际系统短信和电话页面对应包名填写private final static String PHONE_ICON_NAME = &quot;com.android.dialer.DialtactsActivity&quot;;private final static String MMS_ICON_NAME = &quot;com.android.messaging.ui.conversationlist.ConversationListActivity&quot;;</code></pre><ul><li>mHandler 中处理</li></ul><pre><code>@Thunkfinal Handler mHandler = new Handler(new Handler.Callback() {    @Override    public boolean handleMessage(Message msg) {        Log.i(&quot;Launcher-&quot;,&quot;mHandler msg.what = &quot; + msg.what);        if (msg.what == ADVANCE_MSG) {            int i = 0;            for (View key : mWidgetsToAdvance.keySet()) {                final View v = key.findViewById(mWidgetsToAdvance.get(key).autoAdvanceViewId);                final int delay = mAdvanceStagger * i;                if (v instanceof Advanceable) {                    mHandler.postDelayed(new Runnable() {                        public void run() {                            ((Advanceable) v).advance();                        }                    }, delay);                }                i++;            }            sendAdvanceMessage(mAdvanceInterval);        }        //ADD BY Bruce Yang FOR SHOW UNREAD MMS        else if (msg.what == UPDATE_MMS_ICON) {            setMmsOrPhoneNum(MMS_ICON_NAME, getMissMmsCount());        } else if (msg.what == UPDATE_CALL_ICON) {            setMmsOrPhoneNum(PHONE_ICON_NAME, getMissCallCount());        }        return true;    }});</code></pre><ul><li>获取数据库中未读数目</li></ul><pre><code> private int getMissMmsCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount&quot;);    int missSmsCount = 0;    Cursor cursorSMS = null;    Cursor cursorMMS = null;    try {        cursorSMS = getContentResolver().query(                Uri.parse(&quot;content://sms&quot;), null, &quot;(read=0 and type=1)&quot;,                null, null);        cursorMMS = getContentResolver().query(                Uri.parse(&quot;content://mms&quot;), null, &quot;(read=0)&quot;, null,                null);    } catch (SQLiteException e) {        return missSmsCount;    }    if (cursorSMS != null) {        missSmsCount = cursorSMS.getCount();        cursorSMS.close();    }    if (cursorMMS != null) {            missSmsCount = missSmsCount + cursorMMS.getCount();        cursorMMS.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissMmsCount  missSmsCount = &quot; + missSmsCount);    return missSmsCount;}private int getMissCallCount() {    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount&quot;);    int missCallCount = 0;    Uri missingCallUri = Calls.CONTENT_URI;    String where = Calls.TYPE + &quot;=&#39;&quot; + Calls.MISSED_TYPE + &quot;&#39;&quot;            + &quot; AND new=1&quot;;    Cursor cursorCall = null;    try {        cursorCall = getContentResolver().query(missingCallUri,                null, where, null, null);    } catch (SQLiteException e) {        return missCallCount;    }    if (cursorCall != null) {        missCallCount = cursorCall.getCount();        cursorCall.close();    }    Log.i(&quot;Launcher-&quot;,&quot;getMissCallCount  missCallCount = &quot; + missCallCount);    return missCallCount;}</code></pre><ul><li>设置 ICON 未读数</li></ul><pre><code>/**    *    * @param flag 更新电话或短信 ICON    * @param missCount 未读数*/private void setMmsOrPhoneNum(final String flag, final int missCount) {    Log.i(&quot;Launcher-&quot;,&quot;flag = &quot;+flag +&quot; missCount = &quot;+missCount);    if(mWorkspace == null) return;    ArrayList&lt;CellLayout&gt; cellLayouts = mWorkspace.getWorkspaceAndHotseatCellLayouts();    for (final CellLayout layoutParent: cellLayouts) {        final ViewGroup shortcutAndWidgetContainer = layoutParent.getShortcutsAndWidgets();        mWorkspace.post(new Runnable() {            public void run() {                int childCount = shortcutAndWidgetContainer.getChildCount();                for (int j = 0; j &lt;childCount; j++) {                    View view = shortcutAndWidgetContainer.getChildAt(j);                    Object tag = view.getTag();                    if (tag instanceof ShortcutInfo) {                        final ShortcutInfo info = (ShortcutInfo) tag;                        final Intent intent = info.intent;                        if (intent != null) {                            final ComponentName name = intent.getComponent();                            if (name != null &amp;&amp; name.getClassName().equals(flag)) {                                BubbleTextView bv = (BubbleTextView) view;                                Bitmap defaultIconBitmap = Bitmap.createBitmap(info.getIcon(mIconCache));                                Bitmap bitmap = Utilities.createIconBitmap(defaultIconBitmap, missCount);                                bv.setCompoundDrawablesWithIntrinsicBounds(null,                                        new FastBitmapDrawable(bitmap),                                        null, null);                            }                        }                    }                }            }        });    }}</code></pre><ul><li>第一次启动 Launcher 就能获取未读数目，在 finishBindingItems() 添加逻辑</li></ul><pre><code>//ADD BY Bruce Yangint missCall = getMissCallCount();int missMms = getMissMmsCount();if(missCall != 0) {    setMmsOrPhoneNum(PHONE_ICON_NAME, missCall);}if(missMms != 0) {    setMmsOrPhoneNum(MMS_ICON_NAME, missMms);}</code></pre><ul><li>在 onDestroy() 中反注册 ContentObserver</li></ul><pre><code>getContentResolver().unregisterContentObserver(smsContentObserver);getContentResolver().unregisterContentObserver(callContentObserver);</code></pre><h3 id="2-Utilities-java"><a href="#2-Utilities-java" class="headerlink" title="2. Utilities.java"></a>2. Utilities.java</h3><p>新增构造方法，用于重新绘制带数字的应用图标。</p><pre><code>//add by Bruce Yang for ...static Bitmap createIconBitmap(Bitmap b, int count) {    Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888,true);    Log.i(&quot;Launcher-&quot;,&quot;b.isMutable() = &quot;+b.isMutable()); // 如果为 false 就会抛出 java.lang.IllegalStateException 异常， http://bbs.csdn.net/topics/370021698    if (count == 0) return b;    int textureWidth = bitmap.getWidth();    final Canvas canvas = sCanvas;    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    canvas.setBitmap(bitmap);    paint.setColor(Color.RED);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    paint.setColor(Color.WHITE);    paint.setStyle(Paint.Style.STROKE);    paint.setStrokeWidth(2);    canvas.drawCircle(textureWidth - 17-6, 16+6, 16+6, paint);    Paint countPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DEV_KERN_TEXT_FLAG);    countPaint.setColor(Color.WHITE);    countPaint.setTextSize(26f);    countPaint.setTypeface(Typeface.DEFAULT_BOLD);    float x = textureWidth - 24-4;    if (count &gt; 9) x -= 4+6;    if (count &gt; 99) {        countPaint.setTextSize(22f);        String text = String.valueOf(99) + &quot;+&quot;;        canvas.drawText(text, x-2, 25+5, countPaint);    } else {        String text = String.valueOf(count);        canvas.drawText(text,x, 25+5, countPaint);    }    return bitmap;}</code></pre><h3 id="3-AndroidManifest-xml"><a href="#3-AndroidManifest-xml" class="headerlink" title="3. AndroidManifest.xml"></a>3. AndroidManifest.xml</h3><p>添加如下两个权限，由于 Android 6.0 以上需要动态权限申请，这里为了直接获取权限，可以将 targetSdkVersion 改成 21（原来是 23）。</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot; /&gt;</code></pre><h3 id="4-修改对比"><a href="#4-修改对比" class="headerlink" title="4. 修改对比"></a>4. 修改对比</h3><blockquote><p>修改前：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e865f6b26df.png" width="270" height="480"></p><blockquote><p>修改后：</p></blockquote><p><img src="https://i.loli.net/2017/10/19/59e86659672b9.png" width="270" height="480"></p><blockquote><p>参考文章： </p></blockquote><p><a href="http://blog.csdn.net/chenxiong668/article/details/12851357" target="_blank" rel="noopener">http://blog.csdn.net/chenxiong668/article/details/12851357</a><br><a href="http://blog.csdn.net/kerancsdn/article/details/26705767" target="_blank" rel="noopener">http://blog.csdn.net/kerancsdn/article/details/26705767</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Thumbnail by &lt;a href=&quot;https://octiviotti.deviantart.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;octiviotti&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文代码基于 Android 6.0（高通），原生不支持未接来电以及未读短信的图标右上角数目显示。&lt;/p&gt;
&lt;p&gt;涉及到几个文件：&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从 0 搭建直播系统</title>
    <link href="https://yangxiaoge.github.io/2017/09/12/2017-09-12-%E4%BB%8E-0-%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/</id>
    <published>2017-09-12T15:45:18.000Z</published>
    <updated>2017-10-12T15:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个直播的 Demo，今天正好看到<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统</a>，索性就把我自己的搭(折)建(腾)过程做一个记录。<br><a id="more"></a><br>搭建流程：</p><blockquote><p>服务器系统：Ubuntu 16.10 系统<br>推流，拉流系统：Win 7, Android</p></blockquote><p>一个简易的直播系统，大致可以由三部分组成（详情见<a href="http://blog.csdn.net/lmj623565791/article/details/77937483" target="_blank" rel="noopener">鸿洋博客</a>）：</p><ul><li>搭建一个 rtmp 媒体服务器：这里使用 srs，链接为：<a href="https://github.com/ossrs/srs" target="_blank" rel="noopener">https://github.com/ossrs/srs</a></li><li>推流端：这里使用 obs，链接为：<a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a></li><li>拉流端：这里使用播放器 vlc，链接为：<a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></li></ul><h3 id="使用第三方-SDK-推流"><a href="#使用第三方-SDK-推流" class="headerlink" title="使用第三方 SDK 推流"></a>使用第三方 SDK 推流</h3><p>这里以百度云的直播 SDK 为例，下载地址：<br><a href="https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E" target="_blank" rel="noopener">https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E</a></p><p>修改推流地址之后上传到了我的 <a href="https://github.com/yangxiaoge/PushFlowLive" target="_blank" rel="noopener">PushFlowLive</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/baidu-livecamera-%E6%8E%A8%E6%B5%81.apk" target="_blank" rel="noopener">apk 下载</a></p><h3 id="使用开源项目推流"><a href="#使用开源项目推流" class="headerlink" title="使用开源项目推流"></a>使用开源项目推流</h3><p>使用一个开源项目：</p><blockquote><p><a href="https://github.com/begeekmyfriend/yasea" target="_blank" rel="noopener">https://github.com/begeekmyfriend/yasea</a></p><p><a href="https://github.com/yangxiaoge/Zz_Application/raw/master/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/apk/yasea-推流.apk" target="_blank" rel="noopener">apk 下载</a></p></blockquote><h3 id="利用-ffmpeg-推流"><a href="#利用-ffmpeg-推流" class="headerlink" title="利用 ffmpeg 推流"></a>利用 ffmpeg 推流</h3><blockquote><p>详情见鸿洋博客</p></blockquote><p>大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。</p><p>这里，由于篇幅，我们就直接使用别人编好的项目了。</p><p><a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="noopener">https://github.com/WritingMinds/ffmpeg-android-java</a></p><p><strong><em>搭建过程截图</em></strong>：<br>直播步骤：1，开启rtmp 媒体服务器 2，推流（推流客户端，apk等） 3，拉流（vlc等）<br><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-43.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-51.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-43-57.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-02.jpg" alt="利用手机端推流，电脑端通过 VLC 拉流"></p><p><img src="https://raw.githubusercontent.com/yangxiaoge/Zz_Application/fc9482b0e15cf82aa60e0a7b943e41d22cac09c9/gif_public/%E4%BB%8E%200%20%E6%90%AD%E5%BB%BA%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/photo_2017-09-12_14-44-04.jpg" alt=""></p><blockquote><p>封面小黄人动图来自 <a href="https://giphy.com/search/new-follower" target="_blank" rel="noopener">giphy</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想搞个直播的 Demo，今天正好看到&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/77937483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统&lt;/a&gt;，索性就把我自己的搭(折)建(腾)过程做一个记录。&lt;br&gt;
    
    </summary>
    
    
      <category term="直播" scheme="https://yangxiaoge.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的 Android Framework</title>
    <link href="https://yangxiaoge.github.io/2017/09/05/2017-09-05-%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84-Android-Framework/"/>
    <id>https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/</id>
    <published>2017-09-05T14:16:37.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— <code>前言</code><br><a id="more"></a></p><blockquote><p>本文转自 <a href="https://juejin.im/post/586da43b1b69e60062cb8a4f" target="_blank" rel="noopener">墨镜猫</a>，通俗有趣的文笔</p></blockquote><div align="center"><img src="https://dn-mhke0kuv.qbox.me/b06cc296588f99c3852e.jpg?imageView2/1/w/1200/h/700/q/85/interlace/1"></div><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含以下类：</p><ul><li>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。</li><li>Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。</li><li>PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。</li><li>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。</li><li>DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。</li><li>ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。</li><li>WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。</li></ul><h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><p>Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。</p><p>每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。</p><h3 id="从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从-apk-程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的</h3><p>ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。</p><p>接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。</p><p><strong><em>很多线程是不是很晕？</em></strong></p><ol><li>安卓程序中都有哪些线程？</li></ol><p>客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。</p><ol><li>UI 线程是什么？</li></ol><p>一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p><ol><li>自定义的线程和 UI 线程有什么区别？</li></ol><p>UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— &lt;code&gt;前言&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Framework" scheme="https://yangxiaoge.github.io/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源许可证？</title>
    <link href="https://yangxiaoge.github.io/2017/08/29/2017-08-29-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%EF%BC%9F/"/>
    <id>https://yangxiaoge.github.io/2017/08/29/2017-08-29-如何选择开源许可证？/</id>
    <published>2017-08-29T14:36:51.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。<br><a id="more"></a></p><blockquote><p>本文转自 <a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a> 大大</p></blockquote><p>如何为代码选择开源许可证，这是一个问题。<br>世界上的开源许可证，大概有<a href="http://www.gnu.org/licenses/license-list.html" target="_blank" rel="noopener">上百种</a>。很少有人搞得清楚它们的区别。即使在最流行的六种—– <a href="http://www.gnu.org/licenses/gpl.html" target="_blank" rel="noopener">GPL</a>、<a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener">BSD</a>、<a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener">MIT</a>、<a href="http://www.mozilla.org/MPL/" target="_blank" rel="noopener">Mozilla</a>、<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache</a> 和 <a href="http://www.gnu.org/copyleft/lesser.html" target="_blank" rel="noopener">LGPL</a>—-之中做选择，也很复杂。<br>乌克兰程序员 <a href="http://pbagwl.com/post/5078147450/description-of-popular-software-licenses" target="_blank" rel="noopener">Paul Bagwell</a> ，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。<br>下面是我制作的中文版，请看大图。<br><img src="http://image.beekka.com/blog/201105/free_software_licenses.png" alt=""></p><p>有兴趣详细了解开源协议的可以看这篇文章：<a href="http://www.gcssloop.com/tips/choose-license" target="_blank" rel="noopener">程序员不可不知的版权协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。&lt;br&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="https://yangxiaoge.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Binder源码分析</title>
    <link href="https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/07/06/2017-07-06-Binder源码分析/</id>
    <published>2017-07-06T10:00:05.000Z</published>
    <updated>2017-11-22T14:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>forked from <a href="https://github.com/xdtianyu/SourceAnalysis" target="_blank" rel="noopener">xdtianyu/SourceAnalysis</a></p></blockquote><p>本文是基于 <a href="https://github.com/xdtianyu/android-6.0.0_r1" target="_blank" rel="noopener">Android 6.0.0</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow" target="_blank" rel="noopener">kernel 3.4</a> 源码 及 Android SDK 23 展开的。</p><p>先上一张图，直白的了解 Binder 通信过程。(摘自<a href="http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA" target="_blank" rel="noopener">超详细 Android 面试的准备与经历分享 | 百度 (offer)</a>)</p><blockquote><p><img src="/assets/学习资料/面试小札/Binder通信过程.png" alt=""></p></blockquote><a id="more"></a><p><strong>目录</strong></p><ul><li><a href="#1-简介">1. 简介</a></li><li><a href="#2-binder-与-aidl">2. Binder 与 AIDL</a><ul><li><a href="#21-aidl-客户端">2.1 AIDL 客户端</a></li><li><a href="#22-aidl-服务端">2.2 AIDL 服务端</a></li><li><a href="#23-远程服务的获取与使用">2.3 远程服务的获取与使用</a></li></ul></li><li><a href="#3-binder-框架及-native-层">3. Binder 框架及 Native 层</a><ul><li><a href="#31-binder-native-的入口">3.1 Binder Native 的入口</a></li><li><a href="#32-binder-本地层的整个函数/方法调用过程">3.2 Binder 本地层的整个函数/方法调用过程</a></li><li><a href="#33-binder-设备文件的打开和读写">3.3 Binder 设备文件的打开和读写</a></li></ul></li><li><a href="#4-binder-驱动">4. Binder 驱动</a><ul><li><a href="#41-binder-设备的创建">4.1 binder 设备的创建</a></li><li><a href="#42-binder-协议和数据结构">4.2 binder 协议和数据结构</a></li><li><a href="#43-binder-驱动文件操作">4.3 binder 驱动文件操作</a></li></ul></li><li><a href="#5-binder-与系统服务">5. Binder 与系统服务</a><ul><li><a href="#51-contextgetsystemservice">5.1 Context.getSystemService()</a></li><li><a href="#52-contextgetsystemservice-源码分析">5.2 Context.getSystemService() 源码分析</a></li></ul></li><li><a href="#6-结论">6. 结论</a></li><li><a href="#7-参考">7. 参考</a></li></ul><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 <code>Context.getSystemService()</code> 来获取系统服务，或直接使用 <code>AIDL</code> 来实现多个程序(APP)间数据交互。</p><p>Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/android_binder.png" alt="android_binder"></p><p>不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。</p><p>我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。</p><h2 id="2-Binder-与-AIDL"><a href="#2-Binder-与-AIDL" class="headerlink" title="2. Binder 与 AIDL"></a>2. Binder 与 AIDL</h2><p>AIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/AIDL.png" alt="AIDL概念图"></p><ul><li><p>Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。</p></li><li><p>Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。</p></li></ul><p>接下来再看具体实现， 完整源代码见 <a href="https://github.com/xdtianyu/AidlExample" target="_blank" rel="noopener">AidlExample</a>。在这个工程中，我们新建了两个应用， <code>app</code> 是客户端代码， <code>remoteservice</code> 则是服务端代码。</p><h3 id="2-1-AIDL-客户端"><a href="#2-1-AIDL-客户端" class="headerlink" title="2.1 AIDL 客户端"></a>2.1 AIDL 客户端</h3><p>在 Android Studio 项目上右键， <code>New</code> -&gt; <code>AIDL</code> -&gt; <code>AIDL File</code> 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> 文件</p><pre><code class="java">// IRemoteService.aidlpackage com.android.aidltest;interface IRemoteService {    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);}</code></pre><p>从生成的示例代码可以看出，AIDL 的语法类似 Java， <code>basicTypes()</code> 方法传递的参数只是基本类型。</p><p>如果要传递自定义类型如 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java#L6" target="_blank" rel="noopener">User</a>，则需要实现 <a href="http://developer.android.com/reference/android/os/Parcelable.html" target="_blank" rel="noopener">Parcelable</a> 接口。<code>Parcelable</code> 是一个与 Java <code>Serializable</code> 类似的序列化接口。 </p><p>这样类 <code>User</code> 的实例就可以储存到 <a href="http://developer.android.com/reference/android/os/Parcel.html" target="_blank" rel="noopener">Parcel</a> 中，而 <code>Parcel</code> 则是一个可以通过 <code>IBinder</code> 发送数据或对象引用的容器。</p><pre><code class="java">// User.javapublic class User implements Parcelable {    private int uid;    private String name;    // 从 Parcel 中读取数据，顺序需要和写入保持一致    protected User(Parcel in) {        uid = in.readInt();        name = in.readString();    }    // 必须实现，用于从 Parcel 对象中生成类实例    public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {        @Override        public User createFromParcel(Parcel in) {            return new User(in);        }        @Override        public User[] newArray(int size) {            return new User[size];        }    };    // 将数据写入到 Parcel 中， 顺序需要与读取保持一致    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(uid);        dest.writeString(name);    }}</code></pre><p>再向 <code>IRemoteService.aidl</code> 中添加一个 <code>addUser()</code> 方法，同时新建一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> 文件。</p><pre><code class="java">// IRemoteService.aidlpackage com.android.aidltest;import com.android.aidltest.User;interface IRemoteService {    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);    // in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法    void addUser(in User user);}// User.aidlpackage com.android.aidltest;parcelable User;</code></pre><p>运行编译后，会在 <code>generated</code> 文件夹中生成一个 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">IRemoteService.java</a> 接口文件。这个接口中有两个内部类 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Stub.Proxy</a>。注意客户端生成的<code>IRemoteService.java</code> 文件和在后文服务端生成的文件内容是相同的。</p><p>客户端会从 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L34" target="_blank" rel="noopener">Stub.asInterface()</a> 得到 <code>IRemoteService (Stub.Proxy)</code> 的实例，这个实例就是一个通过 Binder 传递回来的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L93" target="_blank" rel="noopener">远程对象</a> 的包装。而服务端则需要实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">IRemoteService.addUser()</a> 方法。</p><pre><code class="java">// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) {    if ((obj == null)) {        return null;    }    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);    if (((iin != null) &amp;&amp; (iin instanceof org.xdty.remoteservice.IRemoteService))) {        return ((org.xdty.remoteservice.IRemoteService) iin);    }    return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);}</code></pre><h3 id="2-2-AIDL-服务端"><a href="#2-2-AIDL-服务端" class="headerlink" title="2.2 AIDL 服务端"></a>2.2 AIDL 服务端</h3><p>为了演示进程间通信，我们新建一个模块（应用） <a href="https://github.com/xdtianyu/AidlExample/tree/master/remoteservice" target="_blank" rel="noopener">RemoteService</a> 来实现功能，并在客户端绑定服务。</p><p>按客户端的结构新建 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/IRemoteService.aidl" target="_blank" rel="noopener">IRemoteService.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/aidl/org/xdty/remoteservice/User.aidl" target="_blank" rel="noopener">User.aidl</a> <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/User.java" target="_blank" rel="noopener">User.java</a> 文件，并拷贝内容，注意如果需要请修改包名。</p><p>新建服务 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L29" target="_blank" rel="noopener">RemoteService</a> ，覆盖(Override) <code>onBind()</code> 方法并返回 <code>IRemoteService.Stub</code> 实例 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>：</p><pre><code class="java">// RemoteService.javapublic class RemoteService extends Service {    private static final String TAG = RemoteService.class.getSimpleName();    private IBinder mBinder = new IRemoteService.Stub() {        @Override        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,                double aDouble, String aString) throws RemoteException {            Log.d(TAG, &quot;basicTypes: &quot;);        }        @Override        public void addUser(User user) throws RemoteException {            Log.d(TAG, &quot;addUser: &quot; + user.name);        }    };    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }}</code></pre><p>这样服务端就实现了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L15" target="_blank" rel="noopener">addUser()</a> 方法，当客户端通过远程对象调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L135" target="_blank" rel="noopener">IRemoteService.Stub.Proxy.addUser()</a> 时，远程对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">mRemote</a> 就会通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 发送命令给服务端，服务端收到命令后在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L76" target="_blank" rel="noopener">Stub.onTransact()</a> 中读取数据并执行 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">addUser()</a> 方法。更多细节我们将在 <a href="#3-binder-%E6%A1%86%E6%9E%B6%E5%8F%8A-native-%E5%B1%82">3. Binder 框架及 Native 层</a> 小节讲述。</p><pre><code class="java">// IRemoteService.java@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,        int flags) throws android.os.RemoteException {    switch (code) {        ...        case TRANSACTION_addUser: {            data.enforceInterface(DESCRIPTOR);            org.xdty.remoteservice.User _arg0;            if ((0 != data.readInt())) {                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);            } else {                _arg0 = null;            }            this.addUser(_arg0);            reply.writeNoException();            return true;        }    }    return super.onTransact(code, data, reply, flags);}</code></pre><h3 id="2-3-远程服务的获取与使用"><a href="#2-3-远程服务的获取与使用" class="headerlink" title="2.3 远程服务的获取与使用"></a>2.3 远程服务的获取与使用</h3><p>客户端要使用远程服务，需要绑定服务 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L45" target="_blank" rel="noopener">bindService</a>) 并建立服务连接 (<a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L19" target="_blank" rel="noopener">ServiceConnection</a>)。</p><pre><code class="java">// MainActivity.javapublic class MainActivity extends AppCompatActivity {    private ServiceConnection mConnection = new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            IRemoteService remoteService = IRemoteService.Stub.asInterface(service);            try {                remoteService.addUser(new User(1, &quot;neo&quot;));            } catch (RemoteException e) {                e.printStackTrace();            }        }        ...    };    ...    @Override    protected void onCreate(Bundle savedInstanceState) {        ...        Intent intent = new Intent().setComponent(new ComponentName(                &quot;org.xdty.remoteservice&quot;,                &quot;org.xdty.remoteservice.RemoteService&quot;));        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);    }}</code></pre><p>我们可以看出，客户端通过 <code>binderService()</code> 方法，获取远程服务并在服务连接 <code>ServiceConnection</code> 中 <code>onServiceConnected()</code> 回调中得到了 <code>IBinder service</code> 实例， 最后通过上文提到的 <code>IRemoteService.Stub.asInterface(service)</code> 方法得到远程服务 <code>IRemoteService</code> 的实例。通过 <code>IRemoteService.addUser()</code> 方法我们可以像调用本地方法一样调用远程方法。在来看 <code>IRemoteService.addUser()</code> 的实现：</p><pre><code class="java">// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) {    ...    return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);}private static class Proxy implements org.xdty.remoteservice.IRemoteService {    private android.os.IBinder mRemote;    Proxy(android.os.IBinder remote) {        mRemote = remote;    }    @Override    public android.os.IBinder asBinder() {        return mRemote;    }    ...    @Override    public void addUser(org.xdty.remoteservice.User user)            throws android.os.RemoteException {        android.os.Parcel _data = android.os.Parcel.obtain();        android.os.Parcel _reply = android.os.Parcel.obtain();        try {            _data.writeInterfaceToken(DESCRIPTOR);            if ((user != null)) {                _data.writeInt(1);                user.writeToParcel(_data, 0);            } else {                _data.writeInt(0);            }            mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);            _reply.readException();        } finally {            _reply.recycle();            _data.recycle();        }    }}</code></pre><p>可以看到客户端调用 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L25" target="_blank" rel="noopener">remoteService.addUser(new User(1, “neo”))</a> 方法实际上是通过 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IBinder service</a> 实例的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">transact()</a> 方法，发送了与服务端约定好的命令 <code>Stub.TRANSACTION_addUser</code>，并将参数按格式打包进 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L137" target="_blank" rel="noopener">Parcel</a> 对象。</p><p>服务端则在 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法中收到命令后会对命令和参数重新解析：</p><pre><code class="java">// IRemoteService.javapublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,        int flags) throws android.os.RemoteException {    switch (code) {        ...        case TRANSACTION_addUser: {            data.enforceInterface(DESCRIPTOR);            org.xdty.remoteservice.User _arg0;            if ((0 != data.readInt())) {                _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);            } else {                _arg0 = null;            }            this.addUser(_arg0);            reply.writeNoException();            return true;        }    }    return super.onTransact(code, data, reply, flags);}</code></pre><p>可以看到在 <code>onTransact()</code> 中，最终 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L84" target="_blank" rel="noopener">this.addUser(_arg0)</a> 调用了上文提到的服务端的实现 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub.addUser()</a> 。</p><p>远程 Binder 对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L42" target="_blank" rel="noopener">mRemote</a> 是由客户端绑定服务时 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/src/main/java/org/xdty/aidlexample/MainActivity.java#L23" target="_blank" rel="noopener">onServiceConnected()</a> 返回的。继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1283" target="_blank" rel="noopener">bindService()</a></p><pre><code class="java">// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn,        int flags) {    warnIfCallingFromSystemProcess();    return bindServiceCommon(service, conn, flags, Process.myUserHandle());}</code></pre><p>可以看到最后是通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1317#L1320" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> 来绑定服务</p><pre><code class="java">// bindServiceCommon()int res = ActivityManagerNative.getDefault().bindService(    mMainThread.getApplicationThread(), getActivityToken(), service,    service.resolveTypeIfNeeded(getContentResolver()),    sd, flags, getOpPackageName(), user.getIdentifier());// ActivityManagerNative.getDefault().bindService()public int bindService(IApplicationThread caller, IBinder token,        Intent service, String resolvedType, IServiceConnection connection,        int flags,  String callingPackage, int userId) throws RemoteException {    ...    data.writeStrongBinder(connection.asBinder());    ...    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);    ...}</code></pre><p>追踪到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3740" target="_blank" rel="noopener">ActivityManagerNative.getDefault().bindService()</a> ，可以发现 <code>ActivityManager</code> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ActivityManagerNative.java#L3750" target="_blank" rel="noopener">IServiceConnection</a>也是一个 <code>AIDL</code> 实现。通过它的 <code>ActivityManagerProxy.bindService()</code> 将绑定请求发送给本地层。</p><p>再从 <code>onServiceConnected()</code> 回调追踪， <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1223" target="_blank" rel="noopener">onServiceConnected()</a> 是由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/LoadedApk.java#L1175" target="_blank" rel="noopener">LoadedApk.ServiceDispatcher.doConnected()</a> 回调的。</p><p><em>关于更多的 <code>bindService()</code> 远程服务创建及 <code>ServiceConnection</code> 回调， 请参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6745181" target="_blank" rel="noopener">Android应用程序绑定服务（bindService）的过程源代码分析</a></em></p><p><em>利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 <a href="https://github.com/xdtianyu/CallerInfo/tree/master/plugin/src/main" target="_blank" rel="noopener">CallerInfo Plugin</a> 的实现 </em></p><p>从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。</p><h2 id="3-Binder-框架及-Native-层"><a href="#3-Binder-框架及-Native-层" class="headerlink" title="3. Binder 框架及 Native 层"></a>3. Binder 框架及 Native 层</h2><p>Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/Binder.png" alt="Binder框架图片"></p><p>Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 <a href="#4-binder-%E9%A9%B1%E5%8A%A8">4. Binder 驱动</a> 小节详细讲述。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native.png" alt="Binder本地框架图片"></p><p>JNI 的代码位于 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/core/jni" target="_blank" rel="noopener">frameworks/base/core/jni</a> 目录下，主要是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp" target="_blank" rel="noopener">android_util_Binder.cpp</a> 文件和头文件 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.h" target="_blank" rel="noopener">android_util_Binder.h</a></p><p>Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 <code>libandroid_runtime.so</code> 系统库。</p><p>Binder 本地层的代码在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/libs/binder" target="_blank" rel="noopener">frameworks/native/libs/binder</a> 目录下， 此目录在 Android 系统编译后会生成 <code>libbinder.so</code> 文件，供 JNI 调用。<code>libbinder</code> 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/native/include/binder" target="_blank" rel="noopener">frameworks/native/include/binder</a> 目录下。</p><h3 id="3-1-Binder-Native-的入口"><a href="#3-1-Binder-Native-的入口" class="headerlink" title="3.1 Binder Native 的入口"></a>3.1 Binder Native 的入口</h3><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IInterface.cpp#L33" target="_blank" rel="noopener">IInterface.cpp</a> 是 Binder 本地层入口，与 java 层的 <code>android.os.IInterface</code> 对应，提供 <code>asBinder()</code> 的实现，返回 <code>IBinder</code> 对象。</p><p>在头文件中有两个类 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L50" target="_blank" rel="noopener">BnInterface (Binder Native Interface)</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IInterface.h#L63" target="_blank" rel="noopener">BpInterface (Binder Proxy Interface)</a>, 对应于 java 层的 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">Stub</a> 和 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L92" target="_blank" rel="noopener">Proxy</a></p><pre><code class="c++">sp&lt;IBinder&gt; IInterface::asBinder(const IInterface* iface){    if (iface == NULL) return NULL;    return const_cast&lt;IInterface*&gt;(iface)-&gt;onAsBinder();}</code></pre><pre><code class="c++">template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder{public:    virtual sp&lt;IInterface&gt;      queryLocalInterface(const String16&amp; _descriptor);    virtual const String16&amp;     getInterfaceDescriptor() const;protected:    virtual IBinder*            onAsBinder();};// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase{public:                                BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected:    virtual IBinder*            onAsBinder();};</code></pre><p>其中 <code>BnInterface</code> 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。<code>BpInterface</code> 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。</p><h3 id="3-2-Binder-本地层的整个函数-方法调用过程"><a href="#3-2-Binder-本地层的整个函数-方法调用过程" class="headerlink" title="3.2 Binder 本地层的整个函数/方法调用过程"></a>3.2 Binder 本地层的整个函数/方法调用过程</h3><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_native_stack.png" alt="Binder本地函数调用图"></p><p>1. Java 层 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L147" target="_blank" rel="noopener">IRemoteService.Stub.Proxy</a> 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L501" target="_blank" rel="noopener">android.os.IBinder (实现在 android.os.Binder.BinderProxy)</a> 的 <code>transact()</code> 发送 <code>Stub.TRANSACTION_addUser</code> 命令。</p><p>2. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L507" target="_blank" rel="noopener">BinderProxy.transact()</a> 进入 native 层。</p><p>3. 由 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">jni</a> 转到 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1246" target="_blank" rel="noopener">android_os_BinderProxy_transact()</a> 函数。</p><p>4. 调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L1124" target="_blank" rel="noopener">IBinder-&gt;transact</a> 函数。</p><pre><code class="c++">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException{    IBinder* target = (IBinder*)        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);    status_t err = target-&gt;transact(code, *data, reply, flags);}</code></pre><p>而 <code>gBinderProxyOffsets.mObject</code> 则是在 java 层调用 <code>IBinder.getContextObject()</code> 时在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L580" target="_blank" rel="noopener">javaObjectForIBinder</a> 函数中设置的</p><pre><code class="c++">static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz){    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);    return javaObjectForIBinder(env, b);}jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val){    ...    LOGDEATH(&quot;objectForBinder %p: created new proxy %p !\n&quot;, val.get(), object);    // The proxy holds a reference to the native object.    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());    val-&gt;incStrong((void*)javaObjectForIBinder);    ...}</code></pre><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L85" target="_blank" rel="noopener">ProcessState::getContextObject()</a> 和 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L220" target="_blank" rel="noopener">ProcessState::getStrongProxyForHandle()</a></p><pre><code class="c++">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/){    return getStrongProxyForHandle(0);}sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle){    sp&lt;IBinder&gt; result;    ...    b = new BpBinder(handle);     result = b;    ...    return result;}</code></pre><p>可见 <a href="">android_os_BinderProxy_transact()</a> 函数实际上调用的是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L159" target="_blank" rel="noopener">BpBinder::transact()</a> 函数。</p><p>5. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/BpBinder.cpp#L164" target="_blank" rel="noopener">BpBinder::transact()</a> 则又调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L548" target="_blank" rel="noopener">IPCThreadState::self()-&gt;transact()</a> 函数。</p><pre><code class="c++">status_t IPCThreadState::transact(int32_t handle,                                  uint32_t code, const Parcel&amp; data,                                  Parcel* reply, uint32_t flags){    status_t err = data.errorCheck();    flags |= TF_ACCEPT_FDS;    if (err == NO_ERROR) {        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),            (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);    }    if ((flags &amp; TF_ONE_WAY) == 0) {        if (reply) {            err = waitForResponse(reply);        } else {            Parcel fakeReply;            err = waitForResponse(&amp;fakeReply);        }    } else {        err = waitForResponse(NULL, NULL);    }    return err;}status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer){    binder_transaction_data tr;    tr.target.ptr = 0; /* Don&#39;t pass uninitialized stack data to a remote process */    tr.target.handle = handle;    tr.code = code;    ...    mOut.writeInt32(cmd);    mOut.write(&amp;tr, sizeof(tr));    return NO_ERROR;}</code></pre><p>由函数内容可以看出， 数据再一次通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L904" target="_blank" rel="noopener">writeTransactionData()</a> 传递给 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L934" target="_blank" rel="noopener">mOut</a> 进行写入操作。 <code>mOut</code> 是一个 Parcel 对象， 声明在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/include/binder/IPCThreadState.h#L123" target="_blank" rel="noopener">IPCThreadState.h</a> 文件中。之后则调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L583" target="_blank" rel="noopener">waitForResponse()</a> 函数。</p><p>6. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L712" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> 在一个 <code>while</code> 循环里不断的调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">talkWithDriver()</a> 并检查是否有数据返回。</p><pre><code class="c++">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){    uint32_t cmd;    int32_t err;    while (1) {        if ((err=talkWithDriver()) &lt; NO_ERROR) break;        ...        cmd = (uint32_t)mIn.readInt32();        switch (cmd) {        case BR_TRANSACTION_COMPLETE:            ...        case BR_REPLY:            {                binder_transaction_data tr;                err = mIn.read(&amp;tr, sizeof(tr));                ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);                if (err != NO_ERROR) goto finish;                if (reply) {                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {                        reply-&gt;ipcSetDataReference(                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                            tr.data_size,                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                            tr.offsets_size/sizeof(binder_size_t),                            freeBuffer, this);                    } else {                        err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);                        freeBuffer(NULL,                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                            tr.data_size,                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                            tr.offsets_size/sizeof(binder_size_t), this);                    }                } else {                    freeBuffer(NULL,                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                        tr.data_size,                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                        tr.offsets_size/sizeof(binder_size_t), this);                    continue;                }            }            goto finish;        }        default:            err = executeCommand(cmd);            if (err != NO_ERROR) goto finish;            break;        }    }    ...}</code></pre><p>7. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> 函数是真正与 binder 驱动交互的实现。<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 就是使用系统调用函数 <code>ioctl</code> 向 binder 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令。</p><pre><code class="c++">status_t IPCThreadState::talkWithDriver(bool doReceive){    if (mProcess-&gt;mDriverFD &lt;= 0) {        return -EBADF;    }    binder_write_read bwr;    // Is the read buffer empty?    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();    // We don&#39;t want to write anything if we are still reading    // from data left in the input buffer and the caller    // has requested to read the next data.    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;    bwr.write_size = outAvail;    bwr.write_buffer = (uintptr_t)mOut.data();    // This is what we&#39;ll read.    if (doReceive &amp;&amp; needRead) {        bwr.read_size = mIn.dataCapacity();        bwr.read_buffer = (uintptr_t)mIn.data();    } else {        bwr.read_size = 0;        bwr.read_buffer = 0;    }    // Return immediately if there is nothing to do.    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;    bwr.write_consumed = 0;    bwr.read_consumed = 0;    status_t err;#if defined(HAVE_ANDROID_OS)        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)            err = NO_ERROR;        else            err = -errno;#else        err = INVALID_OPERATION;#endif    do {        if (mProcess-&gt;mDriverFD &lt;= 0) {            err = -EBADF;        }    } while (err == -EINTR);    if (err &gt;= NO_ERROR) {        if (bwr.write_consumed &gt; 0) {            if (bwr.write_consumed &lt; mOut.dataSize())                mOut.remove(0, bwr.write_consumed);            else                mOut.setDataSize(0);        }        if (bwr.read_consumed &gt; 0) {            mIn.setDataSize(bwr.read_consumed);            mIn.setDataPosition(0);        }        return NO_ERROR;    }    return err;}</code></pre><p>经过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L718" target="_blank" rel="noopener">IPCThreadState::talkWithDriver()</a> ,就将数据发送给了 Binder 驱动。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L723" target="_blank" rel="noopener">IPCThreadState::waitForResponse()</a> ，可以从 第6步 发现 <code>IPCThreadState</code> 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L787" target="_blank" rel="noopener">executeCommand(cmd)</a> 函数。</p><p>8. <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L947" target="_blank" rel="noopener">IPCThreadState::executeCommand()</a> 处理 Binder 驱动返回命令</p><pre><code class="c++">status_t IPCThreadState::executeCommand(int32_t cmd){    BBinder* obj;    RefBase::weakref_type* refs;    status_t result = NO_ERROR;    switch ((uint32_t)cmd) {    ...    case BR_TRANSACTION:        {            binder_transaction_data tr;            result = mIn.read(&amp;tr, sizeof(tr));            ...            Parcel buffer;            buffer.ipcSetDataReference(                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),                tr.data_size,                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),                tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);            ...            Parcel reply;            status_t error;            if (tr.target.ptr) {                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);                error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);            } else {                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);            }            ...        }        break;    ...}</code></pre><p>9. 可以看出其调用了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">BBinder::transact()</a> 函数，将数据返回给上层。</p><pre><code class="c++">status_t BBinder::transact(    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags){    data.setDataPosition(0);    status_t err = NO_ERROR;    switch (code) {        case PING_TRANSACTION:            reply-&gt;writeInt32(pingBinder());            break;        default:            err = onTransact(code, data, reply, flags);            break;    }    if (reply != NULL) {        reply-&gt;setDataPosition(0);    }    return err;}</code></pre><p>10. 而这里的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L1085#L1091" target="_blank" rel="noopener">b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags)</a> 中的 <code>b (BBinder)</code> 是 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L217" target="_blank" rel="noopener">JavaBBinder</a> 的实例，所以会调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L247" target="_blank" rel="noopener">JavaBBinder::onTransact()</a> 函数</p><pre><code class="c++">// frameworks/base/core/jni/android_util_Binder.cppvirtual status_t onTransact(        uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)    {        JNIEnv* env = javavm_to_jnienv(mVM);        ...        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,            code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);    }static int int_register_android_os_Binder(JNIEnv* env){    ...    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, &quot;execTransact&quot;, &quot;(IJJI)Z&quot;);    ...}</code></pre><p>11. 可见 JNI 通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L260" target="_blank" rel="noopener">gBinderOffsets.mExecTransact</a> 最后执行了 <code>android.os.Binder</code> 的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/jni/android_util_Binder.cpp#L865" target="_blank" rel="noopener">execTransact()</a> 方法。</p><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/Binder.java#L442" target="_blank" rel="noopener">execTransact()</a> 方法是 jni 回调的入口。</p><pre><code class="java">// Entry point from android_util_Binder.cpp&#39;s onTransact    private boolean execTransact(int code, long dataObj, long replyObj,            int flags) {        Parcel data = Parcel.obtain(dataObj);        Parcel reply = Parcel.obtain(replyObj);        ...        try {            res = onTransact(code, data, reply, flags);        }         ...    }</code></pre><p>12. 而我们则在服务端 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L19" target="_blank" rel="noopener">IRemoteService.Stub</a> 重载了 <a href="https://github.com/xdtianyu/AidlExample/blob/master/app/build/generated/source/aidl/debug/org/xdty/remoteservice/IRemoteService.java#L51" target="_blank" rel="noopener">onTransact()</a> 方法，所以数据最后会回到我们的服务端并执行服务端实现的 <code>addUser()</code> 方法。</p><pre><code class="java">public static abstract class Stub extends android.os.Binder        implements org.xdty.remoteservice.IRemoteService {    ...    @Override    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply,            int flags) throws android.os.RemoteException {        switch (code) {            case INTERFACE_TRANSACTION: {                reply.writeString(DESCRIPTOR);                return true;            }            case TRANSACTION_basicTypes: {                ...                return true;            }            case TRANSACTION_addUser: {                data.enforceInterface(DESCRIPTOR);                org.xdty.remoteservice.User _arg0;                if ((0 != data.readInt())) {                    _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data);                } else {                    _arg0 = null;                }                this.addUser(_arg0);                reply.writeNoException();                return true;            }        }        return super.onTransact(code, data, reply, flags);    }}</code></pre><p>上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 <code>BC_TRANSACTION</code> 到 Binder 驱动，服务端进程监听返回的 <code>BR_TRANSACTION</code> 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 <code>BC_REPLY</code> 命令， 客户端监听 <code>BR_REPLY</code> 命令。</p><h3 id="3-3-Binder-设备文件的打开和读写"><a href="#3-3-Binder-设备文件的打开和读写" class="headerlink" title="3.3 Binder 设备文件的打开和读写"></a>3.3 Binder 设备文件的打开和读写</h3><p><strong>1. 设备的打开</strong></p><p>在上一小节中我们看到 JNI 过程中调用了 <code>ProcessState::getContextObject()</code> 函数， 在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">ProcessState</a> 初始化时会打开 binder 设备</p><pre><code class="c++">// ProcessState.cppProcessState::ProcessState()    : mDriverFD(open_driver())    ...{    ...}</code></pre><p><a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L311#L337" target="_blank" rel="noopener">open_driver()</a> 函数内容如下</p><pre><code class="c++">// ProcessState.cppstatic int open_driver(){    // 打开设备文件    int fd = open(&quot;/dev/binder&quot;, O_RDWR);    if (fd &gt;= 0) {        fcntl(fd, F_SETFD, FD_CLOEXEC);        int vers = 0;        // 获取驱动版本        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);        if (result == -1) {            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));            close(fd);            fd = -1;        }        // 检查驱动版本是否一致        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {            ALOGE(&quot;Binder driver protocol does not match user space protocol!&quot;);            close(fd);            fd = -1;        }        // 设置最多 15 个 binder 线程        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);        if (result == -1) {            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));        }    } else {        ALOGW(&quot;Opening &#39;/dev/binder&#39; failed: %s\n&quot;, strerror(errno));    }    return fd;}</code></pre><p><strong>2. 设备的读写</strong></p><p>打开设备文件后，文件描述符被保存在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/ProcessState.cpp#L340" target="_blank" rel="noopener">mDriverFD</a>， 通过系统调用 <code>ioctl</code> 函数操作 <code>mDriverFD</code> 就可以实现和 binder 驱动的交互。</p><p>对 Binder 设备文件的所有读写及关闭操作则都在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L805" target="_blank" rel="noopener">IPCThreadState</a> 中，如上一小节提及到的 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L803" target="_blank" rel="noopener">IPCThreadState::talkWithDriver</a> 函数</p><p><code>talkWithDriver()</code> 函数封装了 <code>BINDER_WRITE_READ</code> 命令，会从 binder 驱动读取或写入封装在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">binder_write_read</a> 结构体中的本地或远程对象。</p><pre><code class="c++">// IPCThreadState.cppstatus_t IPCThreadState::talkWithDriver(bool doReceive){       binder_write_read bwr;    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;    // 写入数据    bwr.write_size = outAvail;    bwr.write_buffer = (uintptr_t)mOut.data();    // 读取数据    if (doReceive &amp;&amp; needRead) {        bwr.read_size = mIn.dataCapacity();        bwr.read_buffer = (uintptr_t)mIn.data();    } else {        bwr.read_size = 0;        bwr.read_buffer = 0;    }    ...    // 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动    if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)        err = NO_ERROR;    ...}</code></pre><p>可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。</p><h2 id="4-Binder-驱动"><a href="#4-Binder-驱动" class="headerlink" title="4. Binder 驱动"></a>4. Binder 驱动</h2><p>关于 binder 驱动建议参考另一篇文章 <a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a> <a href="[Android Binder](https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11">原文</a>，本小节仍需要完善。</p><p>Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。</p><p><img src="https://raw.githubusercontent.com/xdtianyu/SourceAnalysis/master/art/binder_reference.png" alt="Binder reference"></p><p>Binder 驱动的代码位于 kernel 代码的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/tree/master/drivers/staging/android" target="_blank" rel="noopener">drivers/staging/android</a> 目录下。主文件是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c" target="_blank" rel="noopener">binder.c</a></p><p>进程间传输的数据被称为 Binder 对象，它是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L49" target="_blank" rel="noopener">flat_binder_object</a>，结构如下</p><pre><code class="c">struct flat_binder_object {    /* 8 bytes for large_flat_header. */    unsigned long       type;    unsigned long       flags;    /* 8 bytes of data. */    union {        void        *binder;    /* local object */        signed long handle;     /* remote object */    };    /* extra data associated with local object */    void            *cookie;};</code></pre><p>其中 类型 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">type</a> 描述了 Binder 对象的类型，包含 <code>BINDER</code>(本地对象)、<code>HANDLE</code>(远程对象)、 <code>FD</code> 三大类(五种)</p><pre><code class="c">enum {    BINDER_TYPE_BINDER  = B_PACK_CHARS(&#39;s&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&#39;w&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_HANDLE  = B_PACK_CHARS(&#39;s&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(&#39;w&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_FD      = B_PACK_CHARS(&#39;f&#39;, &#39;d&#39;, &#39;*&#39;, B_TYPE_LARGE),};</code></pre><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L52" target="_blank" rel="noopener">flags</a> 则表述了<a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L110" target="_blank" rel="noopener">传输方式</a>，如异步、无返回等</p><pre><code class="c">enum transaction_flags {    TF_ONE_WAY  = 0x01, /* this is a one-way call: async, no return */    TF_ROOT_OBJECT  = 0x04, /* contents are the component&#39;s root object */    TF_STATUS_CODE  = 0x08, /* contents are a 32-bit status code */    TF_ACCEPT_FDS   = 0x10, /* allow replies with file descriptors */};</code></pre><p>而 <code>flat_binder_object</code> 中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L55" target="_blank" rel="noopener">union 联合体</a> 就是要传输的数据，当类型为 <code>BINDER</code> 时， 数据就是一个本地对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L56" target="_blank" rel="noopener">*binder</a>，而类型为 <code>HANDLE</code> 时，数据则是一个远程对象 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L57" target="_blank" rel="noopener">handle</a>。</p><p>当 <code>flat_binder_object</code> 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1671" target="_blank" rel="noopener">binder_transaction</a> 的实现。</p><p>该如何理解本地 <code>BINDER</code> 对象和远程 <code>HANDLE</code> 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 <code>RemoteService</code> 有个对象 <a href="https://github.com/xdtianyu/AidlExample/blob/master/remoteservice/src/main/java/org/xdty/remoteservice/RemoteService.java#L11" target="_blank" rel="noopener">mBinder</a>，对于 <code>RemoteService</code> 来说，<code>mBinder</code> 就是一个本地的 <code>BINDER</code> 对象；如果进程 <code>app</code> 通过 Binder 驱动访问 <code>RemoteService</code> 的 <code>mBinder</code> 对象，对于 <code>app</code> 来说， <code>mBinder</code> 就是一个 <code>HANDLE</code>。因此，从根本上来说 <code>handle</code> 和 <code>binder</code> 都指向 <code>RemoteService</code> 的 <code>mBinder</code>。本地对象还可以带有额外的数据，保存在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L61" target="_blank" rel="noopener">cookie</a> 中。</p><p>Binder 驱动直接操作的最外层数据结构是 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L117" target="_blank" rel="noopener">binder_transaction_data</a>， Binder 对象 <code>flat_binder_object</code> 被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">binder_transaction_data</a> 结构体中。</p><p><code>binder_transaction_data</code> 数据结构才是真正传输的数据，其定义如下</p><pre><code class="c">struct binder_transaction_data {    /* The first two are only used for bcTRANSACTION and brTRANSACTION,     * identifying the target and contents of the transaction.     */    union {        size_t  handle; /* target descriptor of command transaction */        void    *ptr;   /* target descriptor of return transaction */    } target;    void        *cookie;    /* target object cookie */    unsigned int    code;       /* transaction command */    /* General information about the transaction. */    unsigned int    flags;    pid_t       sender_pid;    uid_t       sender_euid;    size_t      data_size;  /* number of bytes of data */    size_t      offsets_size;   /* number of bytes of offsets */    /* If this transaction is inline, the data immediately     * follows here; otherwise, it ends with a pointer to     * the data buffer.     */    union {        struct {            /* transaction data */            const void  *buffer;            /* offsets from buffer to flat_binder_object structs */            const void  *offsets;        } ptr;        uint8_t buf[8];    } data;};</code></pre><p><code>flat_binder_object</code> 就被封装在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L142" target="_blank" rel="noopener">*buffer</a>中，其中的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L126" target="_blank" rel="noopener">unsigned int   code;</a> 则是传输命令，描述了 Binder 对象执行的操作。</p><h3 id="4-1-binder-设备的创建"><a href="#4-1-binder-设备的创建" class="headerlink" title="4.1 binder 设备的创建"></a>4.1 binder 设备的创建</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3747" target="_blank" rel="noopener">device_initcall()</a> 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。</p><pre><code class="c">static struct miscdevice binder_miscdev = {    .minor = MISC_DYNAMIC_MINOR,    // 设备文件 /dev/binder    .name = &quot;binder&quot;,    // 设备文件操作    .fops = &amp;binder_fops};static int __init binder_init(void){    int ret;    ...    // 注册字符设备    ret = misc_register(&amp;binder_miscdev);    ...    // 调试文件， 在 /sys/kernel/debug/binder 目录下    if (binder_debugfs_dir_entry_root) {        debugfs_create_file(&quot;state&quot;,                    S_IRUGO,                    binder_debugfs_dir_entry_root,                    NULL,                    &amp;binder_state_fops);        ...    }    return ret;}device_initcall(binder_init);</code></pre><p>可以看出 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3704" target="_blank" rel="noopener">binder_init()</a> 使用 <code>misc_register()</code> 函数创建了 binder 设备。从 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3716" target="_blank" rel="noopener">misc_register(&amp;binder_miscdev);</a> 及 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3695" target="_blank" rel="noopener">.name = “binder”</a> 可以看出， binder 向 kernel 注册了一个 <code>/dev/binder</code> 的字符设备，而文件操作都在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中定义。</p><pre><code class="c">static const struct file_operations binder_fops = {    .owner = THIS_MODULE,    .poll = binder_poll,    .unlocked_ioctl = binder_ioctl,    .mmap = binder_mmap,    .open = binder_open,    .flush = binder_flush,    .release = binder_release,};</code></pre><p>从上面 <code>binder_fops</code> 结构体可以看出，主要的操作是 <code>binder_ioctl()</code> <code>binder_mmap()</code> <code>binder_open()</code> 等函数实现的。</p><h3 id="4-2-binder-协议和数据结构"><a href="#4-2-binder-协议和数据结构" class="headerlink" title="4.2 binder 协议和数据结构"></a>4.2 binder 协议和数据结构</h3><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h" target="_blank" rel="noopener">binder.h</a> 文件中定义了 binder 协议和重要的数据结构。</p><p>首先在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L29" target="_blank" rel="noopener">enum</a> 中定义了 binder 处理的类型，引用或是句柄</p><pre><code class="c">enum {    BINDER_TYPE_BINDER  = B_PACK_CHARS(&#39;s&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&#39;w&#39;, &#39;b&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_HANDLE  = B_PACK_CHARS(&#39;s&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(&#39;w&#39;, &#39;h&#39;, &#39;*&#39;, B_TYPE_LARGE),    BINDER_TYPE_FD      = B_PACK_CHARS(&#39;f&#39;, &#39;d&#39;, &#39;*&#39;, B_TYPE_LARGE),};</code></pre><p>下面这段宏定义则是在 <code>ioctl</code> 函数调用时可用的具体命令。</p><pre><code class="c">#define BINDER_WRITE_READ       _IOWR(&#39;b&#39;, 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT     _IOW(&#39;b&#39;, 3, int64_t)#define BINDER_SET_MAX_THREADS      _IOW(&#39;b&#39;, 5, size_t)#define BINDER_SET_IDLE_PRIORITY    _IOW(&#39;b&#39;, 6, int)#define BINDER_SET_CONTEXT_MGR      _IOW(&#39;b&#39;, 7, int)#define BINDER_THREAD_EXIT      _IOW(&#39;b&#39;, 8, int)#define BINDER_VERSION          _IOWR(&#39;b&#39;, 9, struct binder_version)</code></pre><p>在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L166" target="_blank" rel="noopener">BinderDriverReturnProtocol</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L254" target="_blank" rel="noopener">BinderDriverCommandProtocol</a> 中 则分别定义了 客户端调用 和 服务端 返回的命令。</p><h3 id="4-3-binder-驱动文件操作"><a href="#4-3-binder-驱动文件操作" class="headerlink" title="4.3 binder 驱动文件操作"></a>4.3 binder 驱动文件操作</h3><p>上文已经提到，所有的操作定义在 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3683" target="_blank" rel="noopener">binder_fops</a> 结构体中，下面讲述这些操作。</p><p><strong>设备的打开 - binder_open() 函数</strong></p><p>用户空间在打开 <code>/dev/binder</code> 设备时，驱动会出发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3004" target="_blank" rel="noopener">binder_open()</a> 函数的响应。</p><pre><code class="c">static int binder_open(struct inode *nodp, struct file *filp){    struct binder_proc *proc;    // 分配 binder_proc 数据结构内存    proc = kzalloc(sizeof(*proc), GFP_KERNEL);    if (proc == NULL)        return -ENOMEM;    // 增加当前线程/进程的引用计数并赋值给tsk    get_task_struct(current);    proc-&gt;tsk = current;    // 初始化队列    INIT_LIST_HEAD(&amp;proc-&gt;todo);    init_waitqueue_head(&amp;proc-&gt;wait);    proc-&gt;default_priority = task_nice(current);    binder_lock(__func__);    // 增加BINDER_STAT_PROC的对象计数    binder_stats_created(BINDER_STAT_PROC);    // 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);    // 保存进程 id    proc-&gt;pid = current-&gt;group_leader-&gt;pid;    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);    // 驱动文件 private_data 指向 proc    filp-&gt;private_data = proc;    binder_unlock(__func__);    return 0;}</code></pre><p><strong>驱动文件释放 - binder_release() 函数</strong></p><p>在用户空间关闭驱动设备文件时，会调用 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L3068" target="_blank" rel="noopener">binder_release()</a> 函数，清理 binder_proc 对象，释放占用的内存。</p><pre><code class="c">static int binder_release(struct inode *nodp, struct file *filp){    struct binder_proc *proc = filp-&gt;private_data;    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);    return 0;}static voidbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer){    mutex_lock(&amp;binder_deferred_lock);    proc-&gt;deferred_work |= defer;    if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) {        // 添加到释放队列中        hlist_add_head(&amp;proc-&gt;deferred_work_node,                &amp;binder_deferred_list);        queue_work(binder_deferred_workqueue, &amp;binder_deferred_work);    }    mutex_unlock(&amp;binder_deferred_lock);}</code></pre><p><strong>内存映射 - binder_mmap() 函数</strong></p><p><a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2905" target="_blank" rel="noopener">binder_mmap()</a> 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。</p><pre><code class="c">static int binder_mmap(struct file *filp, struct vm_area_struct *vma){    int ret;    struct vm_struct *area;    // 获得 binder_proc 对象    struct binder_proc *proc = filp-&gt;private_data;    const char *failure_string;    struct binder_buffer *buffer;    // 最多只分配 4M 的内存    if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;    // 检查 flags    if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) {        ret = -EPERM;        failure_string = &quot;bad vm_flags&quot;;        goto err_bad_arg;    }    vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;    mutex_lock(&amp;binder_mmap_lock);    // 检查是否已经映射    if (proc-&gt;buffer) {        ret = -EBUSY;        failure_string = &quot;already mapped&quot;;        goto err_already_mapped;    }    // 申请内核虚拟内存空间    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);    if (area == NULL) {        ret = -ENOMEM;        failure_string = &quot;get_vm_area&quot;;        goto err_get_vm_area_failed;    }    // 将申请到的内存地址保存到 binder_proc 对象中    proc-&gt;buffer = area-&gt;addr;    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;    mutex_unlock(&amp;binder_mmap_lock);    // 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针    proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);    if (proc-&gt;pages == NULL) {        ret = -ENOMEM;        failure_string = &quot;alloc page array&quot;;        goto err_alloc_pages_failed;    }    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;    vma-&gt;vm_ops = &amp;binder_vm_ops;    vma-&gt;vm_private_data = proc;    // 分配一个页的物理内存    if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) {        ret = -ENOMEM;        failure_string = &quot;alloc small buf&quot;;        goto err_alloc_small_buf_failed;    }    // 内存提供给 binder_buffer    buffer = proc-&gt;buffer;    // 初始化 proc-&gt;buffers 链表    INIT_LIST_HEAD(&amp;proc-&gt;buffers);    // 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);    buffer-&gt;free = 1;    binder_insert_free_buffer(proc, buffer);    proc-&gt;free_async_space = proc-&gt;buffer_size / 2;    barrier();    proc-&gt;files = get_files_struct(proc-&gt;tsk);    proc-&gt;vma = vma;    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;    return 0;}</code></pre><p><strong>驱动命令接口 - binder_ioctl() 函数</strong></p><p>用户态程序调用 <code>ioctl</code> 系统函数向 <code>/dev/binder</code> 设备发送数据时，会触发 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2734" target="_blank" rel="noopener">binder_ioctl()</a> 函数响应。</p><p>上文数据结构中已经提到了 <code>binder_ioctl</code> 可以处理的 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L87" target="_blank" rel="noopener">命令</a></p><pre><code class="c">// 核心命令，数据的读写#define BINDER_WRITE_READ       _IOWR(&#39;b&#39;, 1, struct binder_write_read)// 设置最大线程数#define BINDER_SET_MAX_THREADS      _IOW(&#39;b&#39;, 5, size_t)// 设置 context manager#define BINDER_SET_CONTEXT_MGR      _IOW(&#39;b&#39;, 7, int)// 线程退出命令#define BINDER_THREAD_EXIT      _IOW(&#39;b&#39;, 8, int)// binder 驱动的版本#define BINDER_VERSION          _IOWR(&#39;b&#39;, 9, struct binder_version)</code></pre><pre><code class="c">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){    int ret;    struct binder_proc *proc = filp-&gt;private_data;    struct binder_thread *thread;    unsigned int size = _IOC_SIZE(cmd);    void __user *ubuf = (void __user *)arg;    // 检查是否有错误    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);    if (ret)        goto err_unlocked;    binder_lock(__func__);    // 获取 binder_thread 对象    thread = binder_get_thread(proc);    if (thread == NULL) {        ret = -ENOMEM;        goto err;    }    switch (cmd) {    case BINDER_WRITE_READ: {        struct binder_write_read bwr;        if (size != sizeof(struct binder_write_read)) {            ret = -EINVAL;            goto err;        }        // 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr        if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) {            ret = -EFAULT;            goto err;        }        if (bwr.write_size &gt; 0) {            // 执行写入操作            ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);            if (ret &lt; 0) {                bwr.read_consumed = 0;                if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))                    ret = -EFAULT;                goto err;            }        }        if (bwr.read_size &gt; 0) {            // 执行读取操作            ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);            if (!list_empty(&amp;proc-&gt;todo))                wake_up_interruptible(&amp;proc-&gt;wait);            if (ret &lt; 0) {                if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))                    ret = -EFAULT;                goto err;            }        }        // 操作完成后将数据返回给用户空间        if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) {            ret = -EFAULT;            goto err;        }        break;    }    case BINDER_SET_MAX_THREADS:        // 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) {            ret = -EINVAL;            goto err;        }        break;    case BINDER_SET_CONTEXT_MGR:        // 检查是否已经设置        if (binder_context_mgr_node != NULL) {            ret = -EBUSY;            goto err;        }        // 设置 context manager        ret = security_binder_set_context_mgr(proc-&gt;tsk);        if (ret &lt; 0)            goto err;        if (binder_context_mgr_uid != -1) {            if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {                ret = -EPERM;                goto err;            }        } else            binder_context_mgr_uid = current-&gt;cred-&gt;euid;        // 创建 binder_context_mgr_node 节点        binder_context_mgr_node = binder_new_node(proc, NULL, NULL);        if (binder_context_mgr_node == NULL) {            ret = -ENOMEM;            goto err;        }        // 初始化节点数据        binder_context_mgr_node-&gt;local_weak_refs++;        binder_context_mgr_node-&gt;local_strong_refs++;        binder_context_mgr_node-&gt;has_strong_ref = 1;        binder_context_mgr_node-&gt;has_weak_ref = 1;        break;    case BINDER_THREAD_EXIT:        // 线程退出，释放资源        binder_free_thread(proc, thread);        thread = NULL;        break;    case BINDER_VERSION:        // 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中        if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) {            ret = -EINVAL;            goto err;        }        break;    default:        ret = -EINVAL;        goto err;    }    ret = 0;...}</code></pre><pre><code class="c">static struct binder_node *binder_new_node(struct binder_proc *proc,                       void __user *ptr,                       void __user *cookie){    struct rb_node **p = &amp;proc-&gt;nodes.rb_node;    struct rb_node *parent = NULL;    struct binder_node *node;    // 查找要插入节点的父节点    while (*p) {        parent = *p;        node = rb_entry(parent, struct binder_node, rb_node);        if (ptr &lt; node-&gt;ptr)            p = &amp;(*p)-&gt;rb_left;        else if (ptr &gt; node-&gt;ptr)            p = &amp;(*p)-&gt;rb_right;        else            return NULL;    }    // 为要插入节点分配内存空间    node = kzalloc(sizeof(*node), GFP_KERNEL);    if (node == NULL)        return NULL;    binder_stats_created(BINDER_STAT_NODE);    // 插入节点    rb_link_node(&amp;node-&gt;rb_node, parent, p);    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);    // 初始化    node-&gt;debug_id = ++binder_last_id;    node-&gt;proc = proc;    node-&gt;ptr = ptr;    node-&gt;cookie = cookie;    node-&gt;work.type = BINDER_WORK_NODE;    INIT_LIST_HEAD(&amp;node-&gt;work.entry);    INIT_LIST_HEAD(&amp;node-&gt;async_todo);    return node;}</code></pre><p><strong>BINDER_WRITE_READ 处理过程</strong></p><p>在 binder 本地层中，我们看到在 <code>IPCThreadState::talkWithDriver()</code> 函数中， binder 本地层通过 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/native/libs/binder/IPCThreadState.cpp#L856" target="_blank" rel="noopener">ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</a> 命令的形式，与 binder 驱动交互。</p><p>可以看出 <code>ioctl()</code> 的第三个参数是一个 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.h#L69" target="_blank" rel="noopener">binder_write_read</a> 结构体</p><p>binder.h 头文件中定义了两个数据类型, 一个是 <code>binder_write_read</code></p><pre><code class="c">struct binder_write_read {    signed long write_size; /* bytes to write */    signed long write_consumed; /* bytes consumed by driver */    unsigned long   write_buffer;    signed long read_size;  /* bytes to read */    signed long read_consumed;  /* bytes consumed by driver */    unsigned long   read_buffer;};</code></pre><p>其中 <code>write_size</code> 和 <code>read_size</code> 表示需要被读写的字节数， <code>write_consumed</code> 和 <code>read_consumed</code> 表示已经被 binder 驱动读写的字节数， <code>write_buffer</code> 和 <code>read_buffer</code> 则是指向被读写数据的指针。</p><p>具体的读写操作被 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1852" target="_blank" rel="noopener">binder_thread_write</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2266" target="_blank" rel="noopener">binder_thread_read</a> 实现。</p><p><strong>数据写入 - binder_thread_write() 函数</strong></p><p>将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。</p><pre><code class="c">int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,            void __user *buffer, int size, signed long *consumed){    uint32_t cmd;    // 用户空间数据，起始地址和结束地址    void __user *ptr = buffer + *consumed;    void __user *end = buffer + size;    // 循环读取    while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {        // 从用户空间获取操作命令        if (get_user(cmd, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);        if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {            // 增加命令计数器            binder_stats.bc[_IOC_NR(cmd)]++;            proc-&gt;stats.bc[_IOC_NR(cmd)]++;            thread-&gt;stats.bc[_IOC_NR(cmd)]++;        }        switch (cmd) {        // 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref        case BC_INCREFS:        case BC_ACQUIRE:        case BC_RELEASE:        case BC_DECREFS: {            uint32_t target;            struct binder_ref *ref;            const char *debug_string;            // 获取目标进程节点描述 desc            if (get_user(target, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 索描述为 0 表示 context manager 进程            if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp;                (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {                // 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用                ref = binder_get_ref_for_node(proc,                           binder_context_mgr_node);            } else                // 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用                ref = binder_get_ref(proc, target);            switch (cmd) {            case BC_INCREFS:                debug_string = &quot;IncRefs&quot;;                // 增加弱引用计数                binder_inc_ref(ref, 0, NULL);                break;            case BC_ACQUIRE:                debug_string = &quot;Acquire&quot;;                // 增加强引用计数                binder_inc_ref(ref, 1, NULL);                break;            case BC_RELEASE:                debug_string = &quot;Release&quot;;                // 减少强引用计数                binder_dec_ref(ref, 1);                break;            case BC_DECREFS:            default:                debug_string = &quot;DecRefs&quot;;                // 减少弱引用计数                binder_dec_ref(ref, 0);                break;            }            break;        }        case BC_INCREFS_DONE:        case BC_ACQUIRE_DONE: {            void __user *node_ptr;            void *cookie;            struct binder_node *node;            // 从用户空间读取 node_ptr            if (get_user(node_ptr, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 从用户空间读取 cookie            if (get_user(cookie, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 获得节点            node = binder_get_node(proc, node_ptr);            // 没有找到则返回            if (node == NULL) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;%s u%p no match\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_INCREFS_DONE ?                    &quot;BC_INCREFS_DONE&quot; :                    &quot;BC_ACQUIRE_DONE&quot;,                    node_ptr);                break;            }            // cookie 不匹配则返回            if (cookie != node-&gt;cookie) {                binder_user_error(&quot;binder: %d:%d %s u%p node %d&quot;                    &quot; cookie mismatch %p != %p\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_INCREFS_DONE ?                    &quot;BC_INCREFS_DONE&quot; : &quot;BC_ACQUIRE_DONE&quot;,                    node_ptr, node-&gt;debug_id,                    cookie, node-&gt;cookie);                break;            }            if (cmd == BC_ACQUIRE_DONE) {                node-&gt;pending_strong_ref = 0;            } else {                node-&gt;pending_weak_ref = 0;            }            // 减少节点使用计数            binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);            break;        }        // 释放 binder_bffer        case BC_FREE_BUFFER: {            void __user *data_ptr;            struct binder_buffer *buffer;            // 从用户空间获取 data_ptr            if (get_user(data_ptr, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 查找 binder_buffer            buffer = binder_buffer_lookup(proc, data_ptr);            // 没有找到则返回            if (buffer == NULL) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;BC_FREE_BUFFER u%p no match\n&quot;,                    proc-&gt;pid, thread-&gt;pid, data_ptr);                break;            }            // 不允许用户释放则返回            if (!buffer-&gt;allow_user_free) {                binder_user_error(&quot;binder: %d:%d &quot;                    &quot;BC_FREE_BUFFER u%p matched &quot;                    &quot;unreturned buffer\n&quot;,                    proc-&gt;pid, thread-&gt;pid, data_ptr);                break;            }            // 将 buffer-&gt;transaction 置空            if (buffer-&gt;transaction) {                buffer-&gt;transaction-&gt;buffer = NULL;                buffer-&gt;transaction = NULL;            }            if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) {                if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))                    buffer-&gt;target_node-&gt;has_async_transaction = 0;                else                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);            }            // 释放 binder_buffer 对象            trace_binder_transaction_buffer_release(buffer);            binder_transaction_buffer_release(proc, buffer, NULL);            binder_free_buf(proc, buffer);            break;        }        // binder 数据传递处理        case BC_TRANSACTION:        case BC_REPLY: {            struct binder_transaction_data tr;            // 从用户空间拷贝 binder_transaction_data 对象            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))                return -EFAULT;            ptr += sizeof(tr);            // 实际的传输函数，在下文讲解            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);            break;        }        // 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态        case BC_REGISTER_LOOPER:            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_REGISTER_LOOPER called &quot;                    &quot;after BC_ENTER_LOOPER\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            } else if (proc-&gt;requested_threads == 0) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_REGISTER_LOOPER called &quot;                    &quot;without request\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            } else {                proc-&gt;requested_threads--;                proc-&gt;requested_threads_started++;            }            thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;            break;        // 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态        case BC_ENTER_LOOPER:            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) {                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;                binder_user_error(&quot;binder: %d:%d ERROR:&quot;                    &quot; BC_ENTER_LOOPER called after &quot;                    &quot;BC_REGISTER_LOOPER\n&quot;,                    proc-&gt;pid, thread-&gt;pid);            }            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;            break;        // 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态        case BC_EXIT_LOOPER:            thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;            break;        // 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知        case BC_REQUEST_DEATH_NOTIFICATION:        case BC_CLEAR_DEATH_NOTIFICATION: {            uint32_t target;            void __user *cookie;            struct binder_ref *ref;            struct binder_ref_death *death;            // 从用户空间获取 binder_ref 描述 desc            if (get_user(target, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 从用户空间获取 cookie            if (get_user(cookie, (void __user * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            // 获取 binder_ref 引用            ref = binder_get_ref(proc, target);            if (ref == NULL) {                binder_user_error(&quot;binder: %d:%d %s &quot;                    &quot;invalid ref %d\n&quot;,                    proc-&gt;pid, thread-&gt;pid,                    cmd == BC_REQUEST_DEATH_NOTIFICATION ?                    &quot;BC_REQUEST_DEATH_NOTIFICATION&quot; :                    &quot;BC_CLEAR_DEATH_NOTIFICATION&quot;,                    target);                break;            }            if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {                if (ref-&gt;death) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_REQUEST_DEATH_NOTI&quot;                        &quot;FICATION death notific&quot;                        &quot;ation already set\n&quot;,                        proc-&gt;pid, thread-&gt;pid);                    break;                }                // 为 binder_ref_death 对象分配内存空间                death = kzalloc(sizeof(*death), GFP_KERNEL);                if (death == NULL) {                    thread-&gt;return_error = BR_ERROR;                    break;                }                // 初始化 binder_ref_death 对象                binder_stats_created(BINDER_STAT_DEATH);                INIT_LIST_HEAD(&amp;death-&gt;work.entry);                death-&gt;cookie = cookie;                ref-&gt;death = death;                if (ref-&gt;node-&gt;proc == NULL) {                    ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);                    } else {                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);                        // 唤醒目标进程                        wake_up_interruptible(&amp;proc-&gt;wait);                    }                }            } else {                if (ref-&gt;death == NULL) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_CLEAR_DEATH_NOTIFI&quot;                        &quot;CATION death notificat&quot;                        &quot;ion not active\n&quot;,                        proc-&gt;pid, thread-&gt;pid);                    break;                }                death = ref-&gt;death;                if (death-&gt;cookie != cookie) {                    binder_user_error(&quot;binder: %d:%&quot;                        &quot;d BC_CLEAR_DEATH_NOTIFI&quot;                        &quot;CATION death notificat&quot;                        &quot;ion cookie mismatch &quot;                        &quot;%p != %p\n&quot;,                        proc-&gt;pid, thread-&gt;pid,                        death-&gt;cookie, cookie);                    break;                }                // 将 ref-&gt;death 置空                ref-&gt;death = NULL;                if (list_empty(&amp;death-&gt;work.entry)) {                    death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);                    } else {                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);                        // 唤醒目标进程                        wake_up_interruptible(&amp;proc-&gt;wait);                    }                } else {                    BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);                    death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;                }            }        } break;        case BC_DEAD_BINDER_DONE: {            struct binder_work *w;            void __user *cookie;            struct binder_ref_death *death = NULL;            // 从用户空间获取 cookie            if (get_user(cookie, (void __user * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) {                struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);                if (tmp_death-&gt;cookie == cookie) {                    death = tmp_death;                    break;                }            }            if (death == NULL) {                binder_user_error(&quot;binder: %d:%d BC_DEAD&quot;                    &quot;_BINDER_DONE %p not found\n&quot;,                    proc-&gt;pid, thread-&gt;pid, cookie);                break;            }            list_del_init(&amp;death-&gt;work.entry);            // 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION            if (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) {                death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;                if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);                } else {                    list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);                    // 唤醒目标进程                    wake_up_interruptible(&amp;proc-&gt;wait);                }            }        } break;        default:            return -EINVAL;        }        *consumed = ptr - buffer;    }    return 0;}</code></pre><p><strong>binder_transaction() 函数</strong></p><p>在上文处理 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2041" target="_blank" rel="noopener">BC_TRANSACTION</a> 和 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L2042" target="_blank" rel="noopener">BC_REPLY</a> 时，调用了 <a href="https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow/blob/master/drivers/staging/android/binder.c#L1417" target="_blank" rel="noopener">binder_transaction()</a> 函数。我们继续追踪</p><pre><code class="c">static void binder_transaction(struct binder_proc *proc,                   struct binder_thread *thread,                   struct binder_transaction_data *tr, int reply){    struct binder_transaction *t;    struct binder_work *tcomplete;    size_t *offp, *off_end;    struct binder_proc *target_proc;    struct binder_thread *target_thread = NULL;    struct binder_node *target_node = NULL;    struct list_head *target_list;    wait_queue_head_t *target_wait;    struct binder_transaction *in_reply_to = NULL;    if (reply) {        // BC_REPLY 处理流程        // 得到 binder_transaction 对象        in_reply_to = thread-&gt;transaction_stack;        if (in_reply_to == NULL) {            return_error = BR_FAILED_REPLY;            goto err_empty_call_stack;        }        binder_set_nice(in_reply_to-&gt;saved_priority);        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;        // 获取目标线程        target_thread = in_reply_to-&gt;from;        target_proc = target_thread-&gt;proc;    } else {        // BC_TRANSACTION 处理流程        // 查找目标节点        if (tr-&gt;target.handle) {            struct binder_ref *ref;            // 获取 binder_ref 对象            ref = binder_get_ref(proc, tr-&gt;target.handle);            target_node = ref-&gt;node;        } else {            // 索引为 0 则返回 context manager            target_node = binder_context_mgr_node;        }        // 得到目标进程        target_proc = target_node-&gt;proc;        if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) {            struct binder_transaction *tmp;            tmp = thread-&gt;transaction_stack;            while (tmp) {                if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)                    // 获得目标线程                    target_thread = tmp-&gt;from;                tmp = tmp-&gt;from_parent;            }        }    }    // 设置要处理的目标进程或目标线程任务    if (target_thread) {        target_list = &amp;target_thread-&gt;todo;        target_wait = &amp;target_thread-&gt;wait;    } else {        target_list = &amp;target_proc-&gt;todo;        target_wait = &amp;target_proc-&gt;wait;    }    // 为 binder_transaction 对象分配内存空间    t = kzalloc(sizeof(*t), GFP_KERNEL);    binder_stats_created(BINDER_STAT_TRANSACTION);    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);    // 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))        t-&gt;from = thread;    else        t-&gt;from = NULL;    // 设置 binder_transaction 对象    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;    t-&gt;to_proc = target_proc;    t-&gt;to_thread = target_thread;    t-&gt;code = tr-&gt;code;    t-&gt;flags = tr-&gt;flags;    t-&gt;priority = task_nice(current);    // 为 binder_buffer 分配内存空间    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));    // 设置 binder_buffer    t-&gt;buffer-&gt;allow_user_free = 0;    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;    t-&gt;buffer-&gt;transaction = t;    t-&gt;buffer-&gt;target_node = target_node;    if (target_node)        binder_inc_node(target_node, 1, 0, NULL);    offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));    // 从用户空间拷贝数据到 binder_buffer    if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {        return_error = BR_FAILED_REPLY;        goto err_copy_data_failed;    }    if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {        return_error = BR_FAILED_REPLY;        goto err_copy_data_failed;    }    off_end = (void *)offp + tr-&gt;offsets_size;    for (; offp &lt; off_end; offp++) {        struct flat_binder_object *fp;        // 为 flat_binder_object 赋值        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);        // 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE        switch (fp-&gt;type) {        case BINDER_TYPE_BINDER:        case BINDER_TYPE_WEAK_BINDER: {            struct binder_ref *ref;            // 获取 binder_node 节点            struct binder_node *node = binder_get_node(proc, fp-&gt;binder);            if (node == NULL) {                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);                if (node == NULL) {                    return_error = BR_FAILED_REPLY;                    goto err_binder_new_node_failed;                }                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);            }            if (fp-&gt;cookie != node-&gt;cookie) {                goto err_binder_get_ref_for_node_failed;            }            // 获取 binder_ref 对象            ref = binder_get_ref_for_node(target_proc, node);            // 转换类型            if (fp-&gt;type == BINDER_TYPE_BINDER)                fp-&gt;type = BINDER_TYPE_HANDLE;            else                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;            fp-&gt;handle = ref-&gt;desc;            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,                       &amp;thread-&gt;todo);        } break;        case BINDER_TYPE_HANDLE:        case BINDER_TYPE_WEAK_HANDLE: {            // 获取 binder_ref 对象            struct binder_ref*ref = binder_get_ref(proc, fp-&gt;handle);            // 转换类型            if (ref-&gt;node-&gt;proc == target_proc) {                if (fp-&gt;type == BINDER_TYPE_HANDLE)                    fp-&gt;type = BINDER_TYPE_BINDER;                else                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;                fp-&gt;binder = ref-&gt;node-&gt;ptr;                fp-&gt;cookie = ref-&gt;node-&gt;cookie;                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, NULL);            } else {                struct binder_ref *new_ref;                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);                fp-&gt;handle = new_ref-&gt;desc;                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);            }        } break;        // 文件类型        case BINDER_TYPE_FD: {            int target_fd;            struct file *file;            // 获得文件对象            file = fget(fp-&gt;handle);            // 分配一个新的文件描述符            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);            task_fd_install(target_proc, target_fd, file);            fp-&gt;handle = target_fd;        } break;        default:            return_error = BR_FAILED_REPLY;            goto err_bad_object_type;        }    }    if (reply) {        // BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象        binder_pop_transaction(target_thread, in_reply_to);    } else if (!(t-&gt;flags &amp; TF_ONE_WAY)) {        // 同步状态(双向)需要设置回复        t-&gt;need_reply = 1;        t-&gt;from_parent = thread-&gt;transaction_stack;        thread-&gt;transaction_stack = t;    } else {        // 异步传输不需要设置回复        if (target_node-&gt;has_async_transaction) {            target_list = &amp;target_node-&gt;async_todo;            target_wait = NULL;        } else            target_node-&gt;has_async_transaction = 1;    }    t-&gt;work.type = BINDER_WORK_TRANSACTION;    list_add_tail(&amp;t-&gt;work.entry, target_list);    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);    if (target_wait)        // 唤醒目标线程        wake_up_interruptible(target_wait);    return;}</code></pre><p><strong>数据读取 - binder_thread_read() 函数</strong></p><p>用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。</p><pre><code class="c">static int binder_thread_read(struct binder_proc *proc,                  struct binder_thread *thread,                  void  __user *buffer, int size,                  signed long *consumed, int non_block){    void __user *ptr = buffer + *consumed;    void __user *end = buffer + size;    int ret = 0;    int wait_for_proc_work;    if (*consumed == 0) {        // 第一次操作时向用户空间返回 BR_NOOP 命令        if (put_user(BR_NOOP, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);    }retry:    // 获取将要处理的任务    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;                list_empty(&amp;thread-&gt;todo);    if (wait_for_proc_work) {        if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |                    BINDER_LOOPER_STATE_ENTERED))) {            binder_user_error(&quot;binder: %d:%d ERROR: Thread waiting &quot;                &quot;for process work before calling BC_REGISTER_&quot;                &quot;LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;,                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);            wait_event_interruptible(binder_user_error_wait,                         binder_stop_on_user_error &lt; 2);        }        binder_set_nice(proc-&gt;default_priority);        if (non_block) {            // 非阻塞且没有数据则返回 EAGAIN            if (!binder_has_proc_work(proc, thread))                ret = -EAGAIN;        } else            // 阻塞则进入睡眠状态，等待可操作的任务            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));    } else {        if (non_block) {            if (!binder_has_thread_work(thread))                ret = -EAGAIN;        } else            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));    }    binder_lock(__func__);    if (wait_for_proc_work)        proc-&gt;ready_threads--;    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;    if (ret)        return ret;    while (1) {        uint32_t cmd;        struct binder_transaction_data tr;        struct binder_work *w;        struct binder_transaction *t = NULL;        // 获取 binder_work 对象        if (!list_empty(&amp;thread-&gt;todo))            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);        else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);        else {            if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */                goto retry;            break;        }        if (end - ptr &lt; sizeof(tr) + 4)            break;        switch (w-&gt;type) {        case BINDER_WORK_TRANSACTION: {            // 获取 binder_transaction 对象            t = container_of(w, struct binder_transaction, work);        } break;        case BINDER_WORK_TRANSACTION_COMPLETE: {            cmd = BR_TRANSACTION_COMPLETE;            // 返回 BR_TRANSACTION_COMPLETE 命令            if (put_user(cmd, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            binder_stat_br(proc, thread, cmd);            // 从 work 链表中删除并释放内存            list_del(&amp;w-&gt;entry);            kfree(w);            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);        } break;        case BINDER_WORK_NODE: {            // 获得 binder_node 节点            struct binder_node *node = container_of(w, struct binder_node, work);            uint32_t cmd = BR_NOOP;            const char *cmd_name;            // 根据节点类型，增加/获取、减少/释放节点索引            int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs;            int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong;            // 构造 BR_* 命令            if (weak &amp;&amp; !node-&gt;has_weak_ref) {                cmd = BR_INCREFS;                cmd_name = &quot;BR_INCREFS&quot;;                node-&gt;has_weak_ref = 1;                node-&gt;pending_weak_ref = 1;                node-&gt;local_weak_refs++;            } else if (strong &amp;&amp; !node-&gt;has_strong_ref) {                cmd = BR_ACQUIRE;                cmd_name = &quot;BR_ACQUIRE&quot;;                node-&gt;has_strong_ref = 1;                node-&gt;pending_strong_ref = 1;                node-&gt;local_strong_refs++;            } else if (!strong &amp;&amp; node-&gt;has_strong_ref) {                cmd = BR_RELEASE;                cmd_name = &quot;BR_RELEASE&quot;;                node-&gt;has_strong_ref = 0;            } else if (!weak &amp;&amp; node-&gt;has_weak_ref) {                cmd = BR_DECREFS;                cmd_name = &quot;BR_DECREFS&quot;;                node-&gt;has_weak_ref = 0;            }            // 向用户空间返回命令            if (cmd != BR_NOOP) {                if (put_user(cmd, (uint32_t __user *)ptr))                    return -EFAULT;                ptr += sizeof(uint32_t);                if (put_user(node-&gt;ptr, (void * __user *)ptr))                    return -EFAULT;                ptr += sizeof(void *);                if (put_user(node-&gt;cookie, (void * __user *)ptr))                    return -EFAULT;                ptr += sizeof(void *);                binder_stat_br(proc, thread, cmd);            } else {                list_del_init(&amp;w-&gt;entry);                if (!weak &amp;&amp; !strong) {                    rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);                    kfree(node);                    binder_stats_deleted(BINDER_STAT_NODE);                }            }        } break;        case BINDER_WORK_DEAD_BINDER:        case BINDER_WORK_DEAD_BINDER_AND_CLEAR:        case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {            struct binder_ref_death *death;            uint32_t cmd;            // 获取 binder_ref_death 对象            death = container_of(w, struct binder_ref_death, work);            // 构造返回命令            if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;            else                cmd = BR_DEAD_BINDER;            // 向用户空间返回命令            if (put_user(cmd, (uint32_t __user *)ptr))                return -EFAULT;            ptr += sizeof(uint32_t);            // 将 cookie 返回给用户空间            if (put_user(death-&gt;cookie, (void * __user *)ptr))                return -EFAULT;            ptr += sizeof(void *);            binder_stat_br(proc, thread, cmd);            if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {                list_del(&amp;w-&gt;entry);                kfree(death);                binder_stats_deleted(BINDER_STAT_DEATH);            } else                list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);            if (cmd == BR_DEAD_BINDER)                goto done; /* DEAD_BINDER notifications can cause transactions */        } break;        }        if (!t)            continue;        if (t-&gt;buffer-&gt;target_node) {            // 获得 binder_node 节点            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;            // 将数据封装到 binder_transaction_data 对象            tr.target.ptr = target_node-&gt;ptr;            tr.cookie =  target_node-&gt;cookie;            t-&gt;saved_priority = task_nice(current);            if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;                !(t-&gt;flags &amp; TF_ONE_WAY))                binder_set_nice(t-&gt;priority);            else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)                binder_set_nice(target_node-&gt;min_priority);            // 设置返回的命令类型            cmd = BR_TRANSACTION;        } else {            tr.target.ptr = NULL;            tr.cookie = NULL;            cmd = BR_REPLY;        }        tr.code = t-&gt;code;        tr.flags = t-&gt;flags;        tr.sender_euid = t-&gt;sender_euid;        if (t-&gt;from) {            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;            tr.sender_pid = task_tgid_nr_ns(sender,                            current-&gt;nsproxy-&gt;pid_ns);        } else {            tr.sender_pid = 0;        }        tr.data_size = t-&gt;buffer-&gt;data_size;        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data +                    proc-&gt;user_buffer_offset;        tr.data.ptr.offsets = tr.data.ptr.buffer +                    ALIGN(t-&gt;buffer-&gt;data_size,                        sizeof(void *));        if (put_user(cmd, (uint32_t __user *)ptr))            return -EFAULT;        ptr += sizeof(uint32_t);        // 拷贝 binder_transaction_data 对象到用户空间        if (copy_to_user(ptr, &amp;tr, sizeof(tr)))            return -EFAULT;        ptr += sizeof(tr);        binder_stat_br(proc, thread, cmd);        // 移除 binder_transaction 并释放空间        list_del(&amp;t-&gt;work.entry);        t-&gt;buffer-&gt;allow_user_free = 1;        // 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象        if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {            t-&gt;to_parent = thread-&gt;transaction_stack;            t-&gt;to_thread = thread;            thread-&gt;transaction_stack = t;        } else {            t-&gt;buffer-&gt;transaction = NULL;            kfree(t);            binder_stats_deleted(BINDER_STAT_TRANSACTION);        }        break;    }}</code></pre><p>从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。</p><h2 id="5-Binder-与系统服务"><a href="#5-Binder-与系统服务" class="headerlink" title="5. Binder 与系统服务"></a>5. Binder 与系统服务</h2><h3 id="5-1-Context-getSystemService"><a href="#5-1-Context-getSystemService" class="headerlink" title="5.1 Context.getSystemService()"></a>5.1 Context.getSystemService()</h3><p>Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.Class&lt;T" target="_blank" rel="noopener">服务</a>) 主要有 <code>WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager</code></p><p>我们可以通过 <code>Context.getSystemService(String name)</code> 来获取 <a href="http://developer.android.com/reference/android/content/Context.html#getSystemService(java.lang.String" target="_blank" rel="noopener">服务</a>)。</p><p>例如 可以通过如下方法从 xml 中插入新的视图</p><pre><code>LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);inflater.inflate(R.layout.view, root, true);</code></pre><h3 id="5-2-Context-getSystemService-源码分析"><a href="#5-2-Context-getSystemService-源码分析" class="headerlink" title="5.2 Context.getSystemService() 源码分析"></a>5.2 Context.getSystemService() 源码分析</h3><p>追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/ContextImpl.java#L1364" target="_blank" rel="noopener">ContextImpl</a> <code>getSystemService()</code> 源代码</p><pre><code class="java">    @Override    public Object getSystemService(String name) {        return SystemServiceRegistry.getSystemService(this, name);    }</code></pre><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L719" target="_blank" rel="noopener">SystemServiceRegistry</a> 源代码</p><pre><code class="java">    /**     * Gets a system service from a given context.     */    public static Object getSystemService(ContextImpl ctx, String name) {        ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);        return fetcher != null ? fetcher.getService(ctx) : null;    }</code></pre><p>追踪 <code>SYSTEM_SERVICE_FETCHERS</code> 可以发现在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L318" target="_blank" rel="noopener">SystemServiceRegistry</a> 静态区中注册了几乎所有的系统服务</p><pre><code class="java">    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,            new CachedServiceFetcher&lt;LayoutInflater&gt;() {        @Override        public LayoutInflater createService(ContextImpl ctx) {            return new PhoneLayoutInflater(ctx.getOuterContext());        }});    registerService(Context.LOCATION_SERVICE, LocationManager.class,            new CachedServiceFetcher&lt;LocationManager&gt;() {        @Override        public LocationManager createService(ContextImpl ctx) {            IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);            return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));        }});</code></pre><p>上面代码片断中，<a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/app/SystemServiceRegistry.java#L322" target="_blank" rel="noopener">PhoneLayoutInflater</a> 最终回到了 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/view/LayoutInflater.java#L204" target="_blank" rel="noopener">LayoutInflater</a>。而 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/LocationManager.java#L315" target="_blank" rel="noopener">LocationManager</a> 则是对 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/location/java/android/location/ILocationManager.aidl#L39" target="_blank" rel="noopener">ILocationManager</a> 的封装。可以发现，在 <a href="https://github.com/xdtianyu/android-6.0.0_r1/tree/master/frameworks/base/location/java/android/location" target="_blank" rel="noopener">frameworks/base/location/java/android/location</a> 包下含有大量的 AIDL 文件。</p><p>继续追踪 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L49" target="_blank" rel="noopener">ServiceManager.getService(Context.LOCATION_SERVICE)</a> </p><pre><code class="java">    private static IServiceManager getIServiceManager() {        if (sServiceManager != null) {            return sServiceManager;        }        // Find the service manager        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());        return sServiceManager;    }    /**     * Returns a reference to a service with the given name.     *      * @param name the name of the service to get     * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&#39;t exist     */    public static IBinder getService(String name) {        try {            IBinder service = sCache.get(name);            if (service != null) {                return service;            } else {                return getIServiceManager().getService(name);            }        } catch (RemoteException e) {            Log.e(TAG, &quot;error in getService&quot;, e);        }        return null;    }</code></pre><p>从上面代码片断可以看出，<code>ServiceManager</code> 会从 <code>sCache</code> 缓存或 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">IServiceManager</a> 中查找服务并返回一个 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L85" target="_blank" rel="noopener">IBinder</a> 对象。这个 <code>IBinder</code> 就是一个远程对象，可以通过它与其他进程交互。 </p><p>继续深入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManager.java#L55" target="_blank" rel="noopener">getIServiceManager().getService(name)</a> , 进入 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/ServiceManagerNative.java#L33" target="_blank" rel="noopener">ServiceManagerNative</a> </p><pre><code class="java">    /**     * Cast a Binder object into a service manager interface, generating     * a proxy if needed.     */    static public IServiceManager asInterface(IBinder obj)    {        if (obj == null) {            return null;        }        IServiceManager in =            (IServiceManager)obj.queryLocalInterface(descriptor);        if (in != null) {            return in;        }        return new ServiceManagerProxy(obj);    }    class ServiceManagerProxy implements IServiceManager {        public ServiceManagerProxy(IBinder remote) {            mRemote = remote;        }        public IBinder asBinder() {            return mRemote;        }        public IBinder getService(String name) throws RemoteException {            Parcel data = Parcel.obtain();            Parcel reply = Parcel.obtain();            data.writeInterfaceToken(IServiceManager.descriptor);            data.writeString(name);            mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);            IBinder binder = reply.readStrongBinder();            reply.recycle();            data.recycle();            return binder;        }        private IBinder mRemote;    }</code></pre><p>从上边代码片断可以看到，<code>ServiceManager.getIServiceManager()</code> 返回的是一个 <code>ServiceManagerProxy</code>, 而 <code>ServiceManager.getService()</code> 则是在 <code>ServiceManagerProxy</code> 中通过 <code>ServiceManager</code> 的远程 <code>Binder</code> 对象 <code>mRemote</code>，操作 <code>Parcel</code> 数据，调用 <a href="https://github.com/xdtianyu/android-6.0.0_r1/blob/master/frameworks/base/core/java/android/os/IBinder.java#L223" target="_blank" rel="noopener">IBinder.transact(int code, Parcel data, Parcel reply, int flags)</a> 方法来发送请求，并通过 <code>reply.readStrongBinder()</code> 返回了要查找的服务的远程对象。</p><p>可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。</p><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。</p><p>2. 上层的 <code>android.os.Binder</code> 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。</p><p>3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 <code>transact</code> 和 <code>onTransact</code> 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p><a href="http://wangkuiwu.github.io/2014/09/01/Binder-Introduce/" target="_blank" rel="noopener">Android Binder机制</a></p><p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder</a></p><p><a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://rts.lab.asu.edu/web_438/project_final/CSE_598_Android_Architecture_Binder.pdf" target="_blank" rel="noopener">Android Architecture Binder</a></p><p><a href="http://liuxiangtian.github.io/2016/01/07/AIDL%E4%B8%8EBinder%E6%A1%86%E6%9E%B6%E6%B5%85%E8%B0%88/" target="_blank" rel="noopener">AIDL与Binder框架浅谈</a></p><p><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a></p><p><a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf" target="_blank" rel="noopener">Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013</a></p><p><a href="https://www.youtube.com/watch?v=NWhyADzgoiI" target="_blank" rel="noopener">Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video)</a></p><p><a href="http://blog.csdn.net/u010961631/article/details/20479507" target="_blank" rel="noopener">Binder源码分析之驱动层（原）</a></p><p><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="noopener">深入分析Android Binder 驱动</a></p><p><a href="http://blog.csdn.net/qq429205464/article/details/7822442" target="_blank" rel="noopener">构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解</a></p><p><a href="http://blog.csdn.net/21cnbao/article/details/8087354" target="_blank" rel="noopener">Service与Android系统设计（7）— Binder驱动</a></p><p><a href="https://web.archive.org/web/20101016004342/http://www.gmier.com/node/11" target="_blank" rel="noopener">Android Binder</a></p><p><a href="http://www.cnblogs.com/zhangxinyan/p/3487889.html" target="_blank" rel="noopener">Binder机制，从Java到C （7. Native Service）</a></p><hr><p><strong>待补充的内容</strong></p><p>1. 客户端 bindService() 流程及源码分析</p><p>2. Binder Native 层其他源码文件分析</p><p>3. 系统服务（SystemService）详细列表及在本地层的源码分析</p><p>4. SystemManager 源码分析</p><p>5. 完善 binder 驱动内容，补充关系图</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;forked from &lt;a href=&quot;https://github.com/xdtianyu/SourceAnalysis&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xdtianyu/SourceAnalysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是基于 &lt;a href=&quot;https://github.com/xdtianyu/android-6.0.0_r1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 6.0.0&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/xdtianyu/android-msm-hammerhead-3.4-marshmallow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kernel 3.4&lt;/a&gt; 源码 及 Android SDK 23 展开的。&lt;/p&gt;
&lt;p&gt;先上一张图，直白的了解 Binder 通信过程。(摘自&lt;a href=&quot;http://mp.weixin.qq.com/s/YVvV3-RUjbqYo-DYY3E6nA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;超详细 Android 面试的准备与经历分享 | 百度 (offer)&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/学习资料/面试小札/Binder通信过程.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="Binder" scheme="https://yangxiaoge.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android O上手体验</title>
    <link href="https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://yangxiaoge.github.io/2017/05/19/2017-05-19-Android-O上手体验/</id>
    <published>2017-05-19T13:34:15.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 <a href="http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">stormzhang</a> （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。<a id="more"></a><br>有几个重要的事件：Google AI，Android O，Kotlin，等等<br>本文重点是 Android O 的上手视频，迫不及待的把测试机 Nexus 5X 刷成了 Android 0，<a href="https://developer.android.com/preview/download.html" target="_blank" rel="noopener">Android O 系统映像文件下载</a>，官网介绍特性：<a href="https://developer.android.com/preview/index.html" target="_blank" rel="noopener">Android O 新特性介绍</a>。</p><p><strong>上手视频：</strong><br><!--<video height="800" controls>    <source src="/img/video/Android8.0device-2017-05-19-131435.mp4"></video>--><br><!--宽占满，高度自适应。 poster 预加载显示的图像--></p><video height="700" id="video" controls preload="none" poster="/img/video/Android_O_Preload.png"><br>      <source id="mp4" src="/img/video/Android8.0device-2017-05-19-131435.mp4" type="video/mp4"><br></video>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 &lt;a href=&quot;http://blog.csdn.net/googdev/article/details/72514716#0-tsina-1-11403-397232819ff9a47a7b7e80a40613cfe1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stormzhang&lt;/a&gt; （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。
    
    </summary>
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/categories/Android-O/"/>
    
    
      <category term="Android O" scheme="https://yangxiaoge.github.io/tags/Android-O/"/>
    
  </entry>
  
  <entry>
    <title>Android输入法加密研究</title>
    <link href="https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android%E8%BE%93%E5%85%A5%E6%B3%95%E5%8A%A0%E5%AF%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://yangxiaoge.github.io/2017/05/09/2017-05-09-Android输入法加密研究/</id>
    <published>2017-05-09T09:51:03.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>近期接到一个微信，QQ 聊天时加密文字的需求。<br>我当时的心情是这样的：<br><img src="/img/Android输入法加密研究/kidding_me.png" width="150" alt="are you kidding me?" align="center"><br><a id="more"></a></p><h2 id="开源项目入手"><a href="#开源项目入手" class="headerlink" title="开源项目入手"></a>开源项目入手</h2><p>冷静下来，细细思考，要不开发一个输入法？我这是要挑战搜狗输入法一个团队吗，不现实呀！然后就找到了 Goolge 开源的 PinyinIME（Android 4.4.4）。<br>毕竟输入法将输入的文字设置到编辑框要走 BaseInputConnection 中 commitText 方法，那么我就想在这个地方动手脚呗。嗯，说干就干，我就撸了一下 PinyinIME 项目中的代码，实现效果如下：(加密后的文字后面我加了一个 “中” 字)<br><img src="/img/Android输入法加密研究/撸了个加密.png" width="350" alt="加密前后" align="center"></p><p>哎呦，看着也还凑活哈。嗯，然后打开搜狗，百度输入法一看，用户就不乐意了，你家输入法真挫！一怒之下不用了。虽然这是个笑话，但是开发输入法代价太大了，毕竟要大量时间，人力。</p><h2 id="源码分析入手"><a href="#源码分析入手" class="headerlink" title="源码分析入手"></a>源码分析入手</h2><p>所以啊，我想要不从系统层入手？（<a href="https://developer.android.com/reference/android/inputmethodservice/InputMethodService.html?hl=zh-cn" target="_blank" rel="noopener">查了下 Api</a>）</p><ul><li><p><code>frameworks/base/...</code> 下有个类 <code>InputMethodManager</code> (输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的 context 中，用来沟通管理所有进程间交互的全局系统服务。) 中有个方法 showSoftInput (View view, int flags, ResultReceiver resultReceiver)。 注意到一个 view 参数，此参数就是输入框（微信，QQ，等输入框，webview除外）的 View，既然有了 view，那么我就可以 getText，setText 等等操作。<br>我将 view 中的内容 Toast 出来效果如下：<br><img src="/img/Android输入法加密研究/input_method2.png" width="350" alt="InputMethodManager中获取输入框对象，随时可以获取文本" align="center"></p></li><li><p><code>InputMethodService</code>，每个<code>输入法 App</code> 应用都是继承自它！那么就可以对它的生命周期下手了。输入法显示的时候开启一个自定义的服务（有悬浮窗的），输入法关闭的时候结束服务并且释放相应的静态变量。重点就在于生命周期的研究！</p></li><li><p>目的是，将 <code>InputMethodManager</code> 中的 编辑框 View 对象存起来，然后在 InputMethodService 中启动的服务 暂且叫做 <code>MyFloatEncryService</code> 中获取这个 View，之后就直接可以 get，set 加密了。</p></li></ul><p>实现方案在开发中，后续补充~~~ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期接到一个微信，QQ 聊天时加密文字的需求。&lt;br&gt;我当时的心情是这样的：&lt;br&gt;&lt;img src=&quot;/img/Android输入法加密研究/kidding_me.png&quot; width=&quot;150&quot; alt=&quot;are you kidding me?&quot; align=&quot;center&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/categories/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    
      <category term="输入法" scheme="https://yangxiaoge.github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译</title>
    <link href="https://yangxiaoge.github.io/2017/05/04/2017-05-04-Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
    <id>https://yangxiaoge.github.io/2017/05/04/2017-05-04-Android源码编译/</id>
    <published>2017-05-04T11:40:24.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<p>进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）</p><ul><li><code>source build/envsetup.sh</code></li><li><code>lunch</code> (我的项目中选了 79)</li><li><code>make -j8</code>（第一次编译耗时 2 小时，机器性能好的可以 j32 等等）<a id="more"></a><blockquote><p>Android 编译命令 <a href="http://www.cnblogs.com/ifzy/p/3854560.html" target="_blank" rel="noopener">make -j8 -k 2&gt;&amp;1 | tee build.log</a> 解释: 其中 make 是编译命令，-j8 这里的 8 指的是线程数量，就是开启几个线程去编译这个工程，一般会是 CPU 核心数的 2 倍, 开多的话电脑会卡死。-k 2 是标准错误，&amp;1 是标准输出，2&gt;&amp;1 意思就是将标准错误输出到标准输出中。如果没有 2&gt;&amp;1，只会有标准输出，没有错误；tee 的作用同时输出到控制台和文件，make &gt; build.log  是将所有标准输出到这个文件中，并没有定义标准错误应该是定义到了标准输出，也就是说如果 make 执行出现错误，那么就不会写到 build.log 中，而是输出到屏幕上，2&gt;&amp;1 是错误和结果都重定向到 build.log 中！可以到根目录看到 build.log。</p></blockquote></li><li>模块编译，节约时间(比方说我修改了 frameworks/base 下的某个文件直接编译这个模块就行)<ul><li><code>mmm frameworks/base</code> （单独编译某个模块）</li><li><code>make snod</code> （重新打包 Android 系统镜像文件 system.img， 这个不要忘！）<blockquote><p>编译源码等指令可以看老罗的 <a href="http://0xcc0xcd.com/p/books/978-7-121-18108-5/c161.php" target="_blank" rel="noopener">Android 系统源代码情景分析教程</a></p></blockquote></li></ul></li></ul><p>刷机</p><ul><li><a href="https://share.weiyun.com/aef417d93a44dce31802087732ac4d8b" target="_blank" rel="noopener">刷机工具下载</a><br><img src="/img/刷机工具.png" alt="4个刷机工具"></li><li>安装下载的工具</li><li>打开 SP_Flash_Tool_exe_Windows_v5.1644.00.000\flash_tool.exe<br><img src="/img/flash_tool.png" alt="flash_tool"></li></ul><p>刷机开始</p><ul><li><code>MTK 刷机</code>（KONKAS6 代码）使用 <code>Smart Phone Flash Tool</code> 工具： 注意 KONKA 手机关机即可，首先选中 <code>Scatter-loading File</code> 这行的 <code>choose</code> ，然后<code>右击计算机</code>选择<code>映射网络驱动器</code>输入 <code>\\192.168.20.220\share</code>（这个是 <code>ubuntu</code> 共享的文件夹），然后进入对于源码目录找到 <code>KONKAS6\alps\out\target\product\kon6753_66c_s6_m0\MT6753_Android_scatter.txt</code></li><li><code>原生 AOSP</code> 用 Nexus 刷机（AOSP-6.0.1_r17 代码）：注意手机关机进入 <code>fastboot</code> 界面，进入编译生成的目录下 <code>begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/out/target/product/bullhead$</code>，然后依次刷入如下命令：<ul><li>sudo fastboot flash system system.img</li><li>sudo fastboot flash recovery recovery.img</li><li>sudo fastboot flash vendor vendor.img</li><li>sudo fastboot flash cache cache.img</li><li>sudo fastboot flash userdata userdata.img</li><li>sudo fastboot reboot 最后一步，重启手机。</li></ul></li><li>刷机录像：注意，gif 最后点击 <code>download</code> 之后再用 usb 连接关机的 KONKA 手机<br><img src="/img/MTK刷机录制.gif" alt="MTK刷机录制"></li></ul><p><code>Attention</code>： /home/begoit/temp/KONKAS6/alps/packages/apps/Provision/src/com/android/provision/DefaultActivity.java (注释 onCreate 中的部分代码，略去登录注册等功能)</p><p><strong>打 Patch 包</strong>（将 A 项目的提交打 Patch 导入到 B 项目中） <code>2017-9-18 18:14:57</code> add</p><ol><li><code>git format-patch -1</code>（-1 指最近一次 Git 提交） - A 项目根目录，生成 Patch 包</li><li>将生成的 <code>0001-.patch</code> 拷贝到 B 项目根目录下</li><li><code>git am 0001-.patch</code> - B 项目根目录打入 Patch 包</li></ol><p><strong>Android Ubuntu 编译源码依赖</strong> <code>2017-12-26 14:24:45</code><br><code>sudo  apt-get  install  git-core  gnupg  flex  bison  gperf  build-essential  zip  curl  zlib1g-dev  gcc-multilib  g++-multilib  libc6-dev-i386  lib32ncurses5-dev  x11proto-core-dev  libx11-dev  lib32z-dev  ccache  libgl1-mesa-dev  libxml2-utils  xsltproc  unzip</code></p><p><strong>源码代码提示的命令</strong> <code>2017-6-13 15:46:06</code> add<br>运行 <code>source build/envsetup.sh</code><br><code>mmm development/tools/idegen/</code><br><code>sh ./development/tools/idegen/idegen.sh</code> （三行全选运行），会在项目的更目录下会生成 <code>android.ipr</code>，用 <code>Android Studio</code> 打开这个文件，源码代码就有提示了!</p><p><strong>内置 apk</strong> <code>2017-6-27 11:08:49</code> add</p><ul><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/begoit 路径下将需要的 apk(TopActivity.apk) 安装包放进来</li><li>在上述路径下 Android.mk 文件中将 apk 信息加进来（这个模仿其他的内置apk）</li><li>KONKAS6/alps/device/konka/kon6753_66c_s6_m0/full_kon6753_66c_s6_m0.mk 文件中增加 <code>TopActivity \</code></li><li>如果 apk 中有 so 库那么需要加别的东西，目前没有用到，可自行 google</li><li>以上操作完成之后需要重新编译项目</li></ul><p><strong>加快编译速度</strong> <code>2017-6-30 17:46:53</code> add<br><code>prebuilts/misc/linux-x86/ccache/ccache -M 50G</code> 设置 cache 缓存为 50 G</p><p>如下是编译的录屏, 临时弄个 <code>枪火</code> 先占坑，视频抽空录制（视频太大暂不录制）。<br>以下是哔哩哔哩的 html5 播放视频，参考文章：<a href="http://login926.github.io/2016/12/24/Bilibilihtml5Player/" target="_blank" rel="noopener">http://login926.github.io/2016/12/24/Bilibilihtml5Player/</a> </p><iframe src="https://www.bilibili.com/html/html5player.html?cid=5465980&aid=3444552" width="640" height="480" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe><!--宽占满，高度自适应。 poster 预加载显示的图像--><!--<video width="100%" height="auto" id="video" controls="" preload="none"       poster="http://media.w3.org/2010/05/sintel/poster.png">      <source id="mp4" src="http://cn-fjxm2-dx-v-03.acgvideo.com/vg1/f/84/5465980-1.mp4?expires=1494488400&platform=html5&ssig=sFyLhO5klFhNKadv0P9gtA&oi=1968780062&nfa=fkYkF/LEe5xFyJPq/bZ9eQ==&dynamic=1&hfa=2066162576" type="video/mp4">      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg"></video>--><p><strong>未完待续。。。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;source build/envsetup.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lunch&lt;/code&gt; (我的项目中选了 79)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make -j8&lt;/code&gt;（第一次编译耗时 2 小时，机器性能好的可以 j32 等等）
    
    </summary>
    
      <category term="Android源码" scheme="https://yangxiaoge.github.io/categories/Android%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://yangxiaoge.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>《Android开发艺术探索》读书笔记 (1)</title>
    <link href="https://yangxiaoge.github.io/2017/03/03/2017-03-03-Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AFnotes1/"/>
    <id>https://yangxiaoge.github.io/2017/03/03/2017-03-03-Android开发艺术notes1/</id>
    <published>2017-03-03T13:14:14.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<center><font color="SkyBlue" size="6px"><strong>重拾课本, 温故Android开发艺术探索!</strong></font></center><p>本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。<br><a href="https://github.com/singwhatiwanna/android-art-res" target="_blank" rel="noopener">书中源码地址 Github</a><br><a id="more"></a></p><h2 id="第1章-Activity的生命周期和启动模式"><a href="#第1章-Activity的生命周期和启动模式" class="headerlink" title="第1章 Activity的生命周期和启动模式"></a>第1章 Activity的生命周期和启动模式</h2><h3 id="1-1-Activity生命周期全面分析"><a href="#1-1-Activity生命周期全面分析" class="headerlink" title="1.1 Activity生命周期全面分析"></a>1.1 Activity生命周期全面分析</h3><h4 id="1-1-1-典型情况下生命周期分析"><a href="#1-1-1-典型情况下生命周期分析" class="headerlink" title="1.1.1 典型情况下生命周期分析"></a>1.1.1 典型情况下生命周期分析</h4><ul><li>通常, <code>Activity</code>从<code>invisible</code>(即onStop)到<code>visible</code>(即onStart)时, <code>onRestart</code>方法就会被调用。</li><li>点击home键或者打开新<code>Activity</code>时, <code>onPause -&gt; onStop</code>, 如果按Home键回来回掉是: <code>onRestart -&gt;  onStart　-&gt;　onResume</code> ; 如果新<code>Activity</code>主题是透明的时, 只有<code>onPause</code>, 所以当用户返回<code>原来的Activity</code>时, 回掉过程是: <code>onRestart -&gt; onStart -&gt; onResume</code> (看<a href="/img/Activity金字塔型的生命周期图.png">Activity生命周期图</a>就知道了)。<!-- more --></li><li>分析生命周期图, 可知<code>onStart</code>和<code>onStop</code>对应(可见到不可见性), <code>onPause</code>和<code>onResume</code>对应(是否位于前台)。</li></ul><h4 id="1-1-2-异常生命周期分析"><a href="#1-1-2-异常生命周期分析" class="headerlink" title="1.1.2 异常生命周期分析"></a>1.1.2 异常生命周期分析</h4><ul><li>如果应用长时间处于<code>stopped</code>状态并且此时系统<code>内存极为紧张</code>的时候，系统就会回收Activity，此时系统在<code>回收之前</code>会回调<code>onSaveInstanceState</code>方法来保存应用的数据Bundle。当该Activity重新创建的时候，保存的Bundle数据就会传递到<code>onRestoreSaveInstanceState</code>方法和<code>onCreate</code>方法中，这就是onCreate方法中Bundle savedInstanceState参数的来源（onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原）。详情可以参考<a href="https://hujiaweibujidao.github.io/blog/2015/11/28/android-heroes-reading-notes-4/" target="_blank" rel="noopener">Android群英传_第八章 Activity和Activity调用栈分析</a></li><li>配置android:configChanges=”xxx”属性, 防止<code>Activity</code>随着<code>orientation</code>,<code>local</code>,<code>keyboardHidden</code>发生变化时重新创建。</li></ul><h3 id="1-2-Activity的启动模式"><a href="#1-2-Activity的启动模式" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h3><p>应用内的Activity是被任务栈Task来管理的，一个Task中的Activity可以来自不同的应用，同一个应用的Activity也可能不在同一个Task中。默认情况下，任务栈依据栈的后进先出原则管理Activity，但是Activity可以设置一些“特权”打破默认的规则，主要是通过在AndroidManifest文件中的属性<code>android:launchMode</code>或者通过<code>Intent的flag</code>来设置。</p><p><code>standard</code>：默认的启动模式，该模式下会生成一个新的Activity，同时将该Activity实例压入到栈中（不管该Activity是否已经存在在Task栈中，都是采用new操作）。例如： 栈中顺序是A B C D ，此时D通过Intent跳转到A，那么栈中结构就变成 A B C D A，点击返回按钮的 显示顺序是 D C B A，依次摧毁。</p><p><code>singleTop</code>：在singleTop模式下，如果当前Activity D位于栈顶，此时通过Intent跳转到它本身的Activity（即D），那么不会重新创建一个新的D实例（走onNewIntent()），所以栈中的结构依旧为A B C D，如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个activity。</p><p><code>singleTask</code>：在singleTask模式下，Task栈中只能有一个对应Activity的实例。例如：现在栈的结构为A B C D，此时D通过Intent跳转到B（走onNewIntent()），则栈的结构变成了：A B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法。通常应用于首页，首页肯定得在栈底部，也只能在栈底部。</p><p><code>singleInstance</code>：singleInstance模式下会将打开的Activity压入一个新建的任务栈中。例如：Task栈1中结构为：A B C，C通过Intent跳转到了D（D的启动模式为singleInstance），那么则会新建一个Task 栈2，栈1中结构依旧为A B C，栈2中结构为D，此时屏幕中显示D，之后D通过Intent跳转到D，栈2中不会压入新的D，所以2个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的启动模式在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C，此时点击返回按钮，还是在C，栈1的结构变为A B C，而不会回到D。</p><h3 id="1-3-Intent-Flag启动模式"><a href="#1-3-Intent-Flag启动模式" class="headerlink" title="1.3 Intent Flag启动模式"></a>1.3 Intent Flag启动模式</h3><ul><li><code>Intent.FLAG_ACTIVITY_NEW_TASK</code>：使用一个新的task来启动Activity，一般用在service中启动Activity的场景，因为service中并不存在Activity栈。 </li><li><code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>：类似<code>andoid:launchMode=&quot;singleTop&quot;</code> </li><li><code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>：类似<code>andoid:launchMode=&quot;singleTask&quot;</code></li><li><code>Intent.FLAG_ACTIVITY_NO_HISTORY</code>：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在task栈中。例如A B，在B中以这种模式启动C，C再启动D，则当前的task栈变成A B D。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;SkyBlue&quot; size=&quot;6px&quot;&gt;&lt;strong&gt;重拾课本, 温故Android开发艺术探索!&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。&lt;br&gt;&lt;a href=&quot;https://github.com/singwhatiwanna/android-art-res&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书中源码地址 Github&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android开发艺术探索" scheme="https://yangxiaoge.github.io/categories/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://yangxiaoge.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 OkHttp 源码</title>
    <link href="https://yangxiaoge.github.io/2017/03/02/2017-03-02-OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://yangxiaoge.github.io/2017/03/02/2017-03-02-OkHttp源码分析/</id>
    <published>2017-03-02T15:29:20.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载 <a href="https://blog.fangjie.info/2017/03/05/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">JayFang-OkHttp源码分析</a></p></blockquote><p><code>OkHttp3</code>是<code>Square</code>出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的<a id="more"></a>，还有著名的<code>Retrofit</code>也是基于OkHttp封装的。</p><h2 id="OkHttp的基本使用"><a href="#OkHttp的基本使用" class="headerlink" title="OkHttp的基本使用"></a>OkHttp的基本使用</h2><pre><code>OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()    .url(ENDPOINT)    .build();//同步请求    Response response = client.newCall(request).execute();//异步请求client.newCall(request).enqueue(new Callback() {  @Override  public void onFailure(Call call, IOException e) {  }  @Override  public void onResponse(Call call, Response response) throws IOException {  }});</code></pre><p>最基本的用法就是先创建一个OkHttpClient，然后build出一个Requset对象，最后发送请求，可以是同步请求，也可以是异步请求。使用起来很简单，但背后是怎么实现的，下面从源码层面来分析下。</p><h2 id="OkHttp-调用流程"><a href="#OkHttp-调用流程" class="headerlink" title="OkHttp 调用流程"></a>OkHttp 调用流程</h2><p>OkHttp内部调用流程图<br><img src="/img/okhttp/1.jpg" alt=""></p><h3 id="第一步-new-OkHttpClient-Builder"><a href="#第一步-new-OkHttpClient-Builder" class="headerlink" title="第一步: new OkHttpClient(Builder)"></a>第一步: new OkHttpClient(Builder)</h3><pre><code>//OkHttpClient.javapublic OkHttpClient() {    this(new Builder());}OkHttpClient(Builder builder) {    this.dispatcher = builder.dispatcher;    this.proxy = builder.proxy;    this.protocols = builder.protocols;    this.connectionSpecs = builder.connectionSpecs;    this.interceptors = Util.immutableList(builder.interceptors);    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);    ......    this.readTimeout = builder.readTimeout;    this.writeTimeout = builder.writeTimeout;    this.pingInterval = builder.pingInterval;}</code></pre><p>这里创建了一个默认的OkHttpCient.Builder，用于配置各种参数。</p><h3 id="第二步-okhttpclient-newCall-request"><a href="#第二步-okhttpclient-newCall-request" class="headerlink" title="第二步:okhttpclient.newCall(request)"></a>第二步:okhttpclient.newCall(request)</h3><pre><code>//OkHttpClient.java@Override public Call newCall(Request request) {return new RealCall(this, request, false /* for web socket */);}//RealCall.javaRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {    this.client = client;    this.originalRequest = originalRequest;    this.forWebSocket = forWebSocket;    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);}</code></pre><p>这里用request对象创建了一个RealCall对象，把一些参数传到RealCall。</p><h3 id="第三步-execute-or-enqueue"><a href="#第三步-execute-or-enqueue" class="headerlink" title="第三步:execute() or enqueue()"></a>第三步:execute() or enqueue()</h3><pre><code>//RealCall.java@Override public Response execute() throws IOException {synchronized (this) {  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);  executed = true;}captureCallStackTrace();try {  client.dispatcher().executed(this);  //核心的函数  Response result = getResponseWithInterceptorChain();  if (result == null) throw new IOException(&quot;Canceled&quot;);  return result;} finally {  client.dispatcher().finished(this);}}</code></pre><p>同步请求，很直接就调用到了最核心的函数getResponseWithInterceptorChain()。再看下异步请求。</p><pre><code>//RealCall.java  @Override   public void enqueue(Callback responseCallback) {    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);      executed = true;    }    captureCallStackTrace();    client.dispatcher().enqueue(new AsyncCall(responseCallback));  }</code></pre><p>而异步请求，将用户接口的responseCallback对象封装成一个AsyncCall对象提交给Dispather来处理，这里的AsyncCall是RealCall的一个内部类。再看下这个Dispather怎么处理这个AsyncCall的。</p><pre><code>//Dispatcher.javasynchronized void enqueue(AsyncCall call) {if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {  runningAsyncCalls.add(call);  executorService().execute(call);} else {  readyAsyncCalls.add(call);}}</code></pre><p>Dispather管理了一些请求队列，如果正在执行的异步请求没有达到上限，就直接将这个请求提交给线程池，否则加入到等待队列中。而且这里直接把AsyncCall的对象给了线程池，其实这个AsyncCall就是一个Runnable的实现类。</p><pre><code>//RealCall.javafinal class AsyncCall extends NamedRunnable {    private final Callback responseCallback;    AsyncCall(Callback responseCallback) {      super(&quot;OkHttp %s&quot;, redactedUrl());      this.responseCallback = responseCallback;    }    ......    @Override     protected void execute() {      boolean signalledCallback = false;      try {        Response response = getResponseWithInterceptorChain();        if (retryAndFollowUpInterceptor.isCanceled()) {          signalledCallback = true;          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));        } else {          signalledCallback = true;          responseCallback.onResponse(RealCall.this, response);        }      } catch (IOException e) {        if (signalledCallback) {          // Do not signal the callback twice!          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);        } else {          responseCallback.onFailure(RealCall.this, e);        }      } finally {        client.dispatcher().finished(this);      }    }  }</code></pre><p><code>AsyncCall</code>父类的<code>run()</code>方法会调用抽象方法<code>execute()</code>，也就是将在Dispather里的线程池执行AsyncCall对象的时候，就会执行到<code>execute()</code>，在这个方法里同样调用了核心的网络请求方法<code>getResponseWithInterceptorChain()</code>。<br>而且在<code>execute()</code>里会回调用户接口<code>responseCallback</code>的回调方法。注意:这里的回调是在非主线程直接回调的，也就是在Android里使用的话要注意这里面不能直接更新UI操作。<br>至此，同步请求和异步请求最终都是调用的<code>getResponseWithInterceptorChain()</code>;来发送网络请求，只是异步请求涉及到一些线程池操作，包括请求的队列管理、调度。</p><h3 id="第四步-getResponseWithInterceptorChain"><a href="#第四步-getResponseWithInterceptorChain" class="headerlink" title="第四步:getResponseWithInterceptorChain()"></a>第四步:getResponseWithInterceptorChain()</h3><pre><code>//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException {// Build a full stack of interceptors.List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();interceptors.addAll(client.interceptors());interceptors.add(retryAndFollowUpInterceptor);interceptors.add(new BridgeInterceptor(client.cookieJar()));interceptors.add(new CacheInterceptor(client.internalCache()));interceptors.add(new ConnectInterceptor(client));if (!forWebSocket) {  interceptors.addAll(client.networkInterceptors());}interceptors.add(new CallServerInterceptor(forWebSocket));Interceptor.Chain chain = new RealInterceptorChain(    interceptors, null, null, null, 0, originalRequest);return chain.proceed(originalRequest);}</code></pre><p>在这个方法里就是添加了一些拦截器，然后启动一个拦截器调用链，拦截器递归调用之后最后返回请求的响应Response。这里的拦截器分层的思想就是借鉴的网络里的分层模型的思想。请求从最上面一层到最下一层，响应从最下一层到最上一层，每一层只负责自己的任务，对请求或响应做自己负责的那块的修改。</p><p><code>Q1</code>: 这里为什么每次都重新创建<code>RealInterceptorChain</code>对象，为什么不直接复用上一层的<code>RealInterceptorChain</code>对象？(文末给出答案)</p><h2 id="OkHttp拦截器分层结构"><a href="#OkHttp拦截器分层结构" class="headerlink" title="OkHttp拦截器分层结构"></a>OkHttp拦截器分层结构</h2><p><img src="/img/okhttp/2.jpg" alt=""></p><pre><code>//RealInterceptorChain.javapublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,  Connection connection) throws IOException {if (index &gt;= interceptors.size()) throw new AssertionError();calls++;......RealInterceptorChain next = new RealInterceptorChain(    interceptors, streamAllocation, httpCodec, connection, index + 1, request);Interceptor interceptor = interceptors.get(index);Response response = interceptor.intercept(next);...return response;}</code></pre><p>RealInterceptorChain的<code>proceed()</code>，每次重新创建一个<code>RealInterceptorChain</code>对象，然后调用下一层的拦截器的<code>interceptor.intercept()</code>方法。<br>每一个拦截器的<code>intercept()</code>方法都是这样的模型</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {    Request request = chain.request();    // 1、该拦截器在Request阶段负责的事情    // 2、调用RealInterceptorChain.proceed()，其实是递归调用下一层拦截器的intercept方法    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);    //3、该拦截器在Response阶段负责的事情，然后返回到上一层拦截器的 response阶段    return  response;         }  }</code></pre><p>这差不多就是OkHttp的分层拦截器模型，借鉴了网络里的OSI七层模型的思想。最底层是CallServerInterceptor，类比网络里的物理层。OkHttp还支持用户自定义拦截器，插入到最顶层和CallServerInterceptor上一层的位置。比如官方写了一个Logging Interceptor，用于打印网络请求日志的拦截器。</p><h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><pre><code>Request userRequest = chain.request();Request.Builder requestBuilder = userRequest.newBuilder();// Request阶段RequestBody body = userRequest.body();if (body != null) {  MediaType contentType = body.contentType();    ......  long contentLength = body.contentLength();  if (contentLength != -1) {    requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));    requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);  } else {    requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);    requestBuilder.removeHeader(&quot;Content-Length&quot;);  }  if (userRequest.header(&quot;Connection&quot;) == null) {  requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); }}    .....Response networkResponse = chain.proceed(requestBuilder.build());// Response阶段    .....if (transparentGzip    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {  GzipSource responseBody = new GzipSource(networkResponse.body().source());  Headers strippedHeaders = networkResponse.headers().newBuilder()      .removeAll(&quot;Content-Encoding&quot;)      .removeAll(&quot;Content-Length&quot;)      .build();  responseBuilder.headers(strippedHeaders);  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));}</code></pre><p>BridgeInterceptor拦截器在Request阶段，将用户的配置信息，重新创建Request.Builder对象，重新build出Request对象，并添加一些请求头，比如:host，content-length，keep-alive等。<br>BridgeInterceptor在Response阶段做gzip解压操作。</p><h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>CacheInterceptor拦截器在Request阶段判断该请求是否有缓存，是否需要重新请求，如果不需要重新请求，直接从缓存里取出内容，封装一个Response返回，不需要再调用下一层。<br>CacheInterceptor拦截器在Response阶段，就是把下面一层的Response做缓存。</p><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><pre><code>//ConnectInterceptor.javaRealInterceptorChain realChain = (RealInterceptorChain) chain;Request request = realChain.request();StreamAllocation streamAllocation = realChain.streamAllocation();// We need the network to satisfy this request. Possibly for validating a conditional GET.boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);RealConnection connection = streamAllocation.connection();return realChain.proceed(request, streamAllocation, httpCodec, connection);</code></pre><p>ConnectInterceptor拦截器只在Request阶段建立连接，Response阶段直接把下一层的Response返回给上一层。再看下建立连接的过程。</p><pre><code>public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {....try {  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);  HttpCodec resultCodec = resultConnection.newCodec(client, this);......} catch (IOException e) {  throw new RouteException(e);}}</code></pre><p>findHealthyConnection()函数寻找一条健康的网络连接，其内部主要调用了findConnection()。</p><pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,  boolean connectionRetryEnabled) throws IOException {Route selectedRoute;synchronized (connectionPool) { .....  // Attempt to get a connection from the pool.  Internal.instance.get(connectionPool, address, this);  if (connection != null) {    return connection;  }  selectedRoute = route;}// If we need a route, make one. This is a blocking operation.if (selectedRoute == null) {  selectedRoute = routeSelector.next();}// Create a connection and assign it to this allocation immediately. This makes it possible for// an asynchronous cancel() to interrupt the handshake we&#39;re about to do.RealConnection result;synchronized (connectionPool) {  route = selectedRoute;  refusedStreamCount = 0;  result = new RealConnection(connectionPool, selectedRoute);  acquire(result);  if (canceled) throw new IOException(&quot;Canceled&quot;);}// Do TCP + TLS handshakes. This is a blocking operation.result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);routeDatabase().connected(result.route());Socket socket = null;synchronized (connectionPool) {  // Pool the connection.  Internal.instance.put(connectionPool, result); .....}closeQuietly(socket);return result;}</code></pre><p>这里面大概就是从连接池里去找已有的网络连接，如果有，则复用，减少三次握手；没有的话，则创建一个RealConnection对象，三次握手，建立连接，然后将连接放到连接池。具体的内部connect过程，就不深入了。</p><pre><code>public ConnectionPool() {this(5, 5, TimeUnit.MINUTES);}public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {}</code></pre><p><code>ConnectionPool</code>最多支持保持5个地址的连接keep-alive，每个keep-alive 5分钟，并有异步线程循环清理无效的连接。</p><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><pre><code>@Override public Response intercept(Chain chain) throws IOException {...httpCodec.writeRequestHeaders(request);Response.Builder responseBuilder = null;if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {  ......  if (responseBuilder == null) {    Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());    BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);    request.body().writeTo(bufferedRequestBody);    bufferedRequestBody.close();  }}httpCodec.finishRequest();if (responseBuilder == null) {  responseBuilder = httpCodec.readResponseHeaders(false);}Response response = responseBuilder    .request(request)    .handshake(streamAllocation.connection().handshake())    .sentRequestAtMillis(sentRequestMillis)    .receivedResponseAtMillis(System.currentTimeMillis())    .build();int code = response.code();.....return response;}</code></pre><p>CallServerInterceptor 精简出来的代码就是writeRequestHeaders()，flushRequest()，finishRequest()，发送请求，然后readResponseHeaders，openResponseBody读取response。<br>CallServerInterceptor底层的IO流读写依赖于Square自家的Okio项目，HttpCodec是封装的IO编码和解码的实现。</p><p>至此，OkHttp中几个核心的拦截器就到此为止了，OkHttp最精髓的部分也就体现在这个拦截器上。最后补充几个关于OkHttp的面试问题。</p><ul><li>OkHttp是如何做链路复用？</li><li>OkHttp的Intereptor能不能取消一个request？<br>这两个问题在分析源码之后应该很容易回答了。</li></ul><p>回答上面留的一个问题:<br>每次重新创建一个<code>RealInterceptorChain</code>对象，因为这里是递归调用，在调用下一层拦截器的interupter()方法的时候，本层的 response阶段还没有执行完成，如果复用<code>RealInterceptorChain</code>对象，必然导致下一层修改<code>RealInterceptorChain</code>，所以需要重新创建<code>RealInterceptorChain</code>对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载 &lt;a href=&quot;https://blog.fangjie.info/2017/03/05/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JayFang-OkHttp源码分析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;OkHttp3&lt;/code&gt;是&lt;code&gt;Square&lt;/code&gt;出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="OkHttp" scheme="https://yangxiaoge.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Java与Android知识点</title>
    <link href="https://yangxiaoge.github.io/2017/02/28/2017-02-28-Java%E4%B8%8EAndroid%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://yangxiaoge.github.io/2017/02/28/2017-02-28-Java与Android知识点/</id>
    <published>2017-02-28T09:13:42.000Z</published>
    <updated>2018-01-09T17:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<center><font color="SkyBlue" size="6px"><strong>持续更行中</strong></font></center><h2 id="Fragment-中弹出-PopWindow-要使背景被透明（无效的问题）"><a href="#Fragment-中弹出-PopWindow-要使背景被透明（无效的问题）" class="headerlink" title="Fragment 中弹出 PopWindow 要使背景被透明（无效的问题）"></a>Fragment 中弹出 PopWindow 要使背景被透明（无效的问题）</h2><p>问题：单独在 pop 里面设置属性的话只会半透明掉 activity 的，因为 getactivity 的 getwindow 方法获取到的是 activity 的窗体，而不是 Fragment 的<br>实现：在 Fragment 的布局中设置半透明属性，而且是该布局最下面添加一个控件（eg:textview），将该控件设置半透明背景，然后pop显示和消失就让该控件显示和消失</p><h2 id="1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。"><a href="#1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。" class="headerlink" title="1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。"></a>1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。</h2><p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；<a id="more"></a>而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。<br><code>String str = new String(“hello”);</code><br>上面的语句中 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。</p><h2 id="2-重写equals方法时-为什么也需要重写hashCode方法。"><a href="#2-重写equals方法时-为什么也需要重写hashCode方法。" class="headerlink" title="2. 重写equals方法时,为什么也需要重写hashCode方法。"></a>2. 重写equals方法时,为什么也需要重写hashCode方法。</h2><ul><li><p>1、重写equals方法时需要重写hashCode方法，主要是针对Map、Set等集合类型的使用；</p><ul><li><p>a: Map、Set等集合类型存放的对象必须是唯一的；</p></li><li><p>b: 集合类判断两个对象是否相等，是先判断equals是否相等，如果equals返回TRUE，还要再判断HashCode返回值是否ture,只有两者都返回ture,才认为该两个对象是相等的。</p></li></ul></li><li><p>2、由于Object的hashCode返回的是对象的hash值，所以即使equals返回TRUE，集合也可能判定两个对象不等，所以必须重写hashCode方法，以保证当equals返回TRUE时，hashCode也返回Ture，这样才能使得集合中存放的对象唯一。</p></li></ul><h2 id="3-Android-中的Dalvik和ART是什么，有啥区别？"><a href="#3-Android-中的Dalvik和ART是什么，有啥区别？" class="headerlink" title="3. Android 中的Dalvik和ART是什么，有啥区别？"></a>3. <a href="http://www.jianshu.com/p/58f817d176b7" target="_blank" rel="noopener">Android 中的Dalvik和ART是什么，有啥区别？</a></h2><p>答: 在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率。在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p><h2 id="4-Glide-Picasso原理"><a href="#4-Glide-Picasso原理" class="headerlink" title="4. Glide, Picasso原理?"></a>4. Glide, Picasso原理?</h2><h2 id="5-事件传递机制-参考郭霖事件分发博客"><a href="#5-事件传递机制-参考郭霖事件分发博客" class="headerlink" title="5. 事件传递机制?(参考郭霖事件分发博客)"></a>5. 事件传递机制?(参考<a href="http://blog.csdn.net/guolin_blog/article/details/9097463/" target="_blank" rel="noopener">郭霖事件分发博客</a>)</h2><h2 id="6-Okhttp原理解析-优点"><a href="#6-Okhttp原理解析-优点" class="headerlink" title="6. Okhttp原理解析,优点"></a>6. <a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="noopener">Okhttp原理解析,优点</a></h2><p>答: 总结: <code>OkHttpClient</code> 实现 <code>Call.Factory</code>，负责为 <code>Request</code> 创建 <code>Call</code>；<br><code>RealCall</code> 为具体的 <code>Call</code> 实现，其 <code>enqueue()</code> 异步接口通过 <code>Dispatcher</code> 利用 <code>ExecutorService</code> 实现，而最终进行网络请求时和同步 <code>execute()</code> 接口一致，都是通过 <code>getResponseWithInterceptorChain()</code> 函数实现；<br><code>getResponseWithInterceptorChain()</code> 中利用 <code>Interceptor</code> 链条，分层实现缓存、透明压缩、网络 IO 等功能；</p><h2 id="7-内存泄漏全解析"><a href="#7-内存泄漏全解析" class="headerlink" title="7. 内存泄漏全解析"></a>7. <a href="http://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650238704&amp;idx=1&amp;sn=ad334840afdc2d9bdb8215e9f942e54e&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">内存泄漏全解析</a></h2><h2 id="8-热修复有所了解"><a href="#8-热修复有所了解" class="headerlink" title="8. 热修复有所了解?"></a>8. <a href="http://mp.weixin.qq.com/s/GuzbU1M1LY1VKmN7PyVbHQ" target="_blank" rel="noopener">热修复有所了解?</a></h2><h2 id="9-路由了解吗-routerSDK"><a href="#9-路由了解吗-routerSDK" class="headerlink" title="9. 路由了解吗?routerSDK"></a>9. 路由了解吗?<a href="https://github.com/Jomes/routerSDK" target="_blank" rel="noopener">routerSDK</a></h2><h2 id="10-foreach原理"><a href="#10-foreach原理" class="headerlink" title="10. foreach原理"></a>10. <a href="http://blog.csdn.net/cq1982/article/details/49121879" target="_blank" rel="noopener">foreach原理</a></h2><p>答: foreach语法最终被编译器转为了对Iterator.next()的调用。而作为使用者的我们，jdk并没用向我们暴露这些细节，我们甚至不需要知道Iterator的存在，认识到jdk的强大之处了吧。</p><h2 id="11-EventBus-源码解析"><a href="#11-EventBus-源码解析" class="headerlink" title="11. EventBus 源码解析"></a>11. <a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">EventBus 源码解析</a></h2><p>答: <a href="http://www.jianshu.com/p/e41e580eff10" target="_blank" rel="noopener">总结:</a> 底层也是回掉实现。优点：EventBus是很好地替代了回调的功能，松耦合，使用简单。缺点：只要用得一多，那消息类的数量必然是会爆炸性增长，调试的时候除非熟悉整块逻辑，不然不跑起来你是没办法了解Subscribe的方法的数据来源。</p><h2 id="12-Android进程保活的套路-文中源码"><a href="#12-Android进程保活的套路-文中源码" class="headerlink" title="12. Android进程保活的套路 - 文中源码"></a>12. <a href="http://www.jianshu.com/p/1da4541b70ad" target="_blank" rel="noopener">Android进程保活的套路</a> - <a href="https://github.com/herojing/KeepProcessLive" target="_blank" rel="noopener">文中源码</a></h2><p>答: 1,开启一个像素的Activity(手Q) 2,前台服务 3,相互唤醒 4,JobSheduler 5,粘性服务&amp;与系统服务捆绑<br><a href="http://www.jianshu.com/p/89f19d67b348" target="_blank" rel="noopener">常被问的问题- Android 进程不死从3个层面入手</a>, <a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577617&amp;idx=1&amp;sn=623256a2ff94641036a6c9eea17baab8&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">腾讯Bugly保活文章</a></p><h2 id="13-ButterKnife工作流程"><a href="#13-ButterKnife工作流程" class="headerlink" title="13. ButterKnife工作流程"></a>13. <a href="http://bxbxbai.github.io/2016/03/12/how-butterknife-works/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">ButterKnife工作流程</a></h2><p>答:当你编译你的Android工程时，ButterKnife工程中 ButterKnifeProcessor 类的 process() 方法会执行以下操作：</p><ul><li>开始它会扫描Java代码中所有的ButterKnife注解 @Bind 、 @OnClick 、 @OnItemClicked 等</li><li>当它发现一个类中含有任何一个注解时， ButterKnifeProcessor 会帮你生成一个Java类，名字类似 <classname>$$ViewBinder ，这个新生成的类实现了 ViewBinder<t> 接口</t></classname></li><li>这个 ViewBinder 类中包含了所有对应的代码，比如 @Bind 注解对应 findViewById() , @OnClick 对应了 view.setOnClickListener() 等等</li><li>最后当Activity启动 ButterKnife.bind(this) 执行时，ButterKnife会去加载对应的 ViewBinder 类调用它们的 bind() 方法</li></ul><h2 id="14-RxJava-amp-Retrofit结合的最佳实践-封装的思想值得学习-Retrofit"><a href="#14-RxJava-amp-Retrofit结合的最佳实践-封装的思想值得学习-Retrofit" class="headerlink" title="14. RxJava &amp; Retrofit结合的最佳实践- 封装的思想值得学习!!!, Retrofit"></a>14. <a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava &amp; Retrofit结合的最佳实践- 封装的思想值得学习!!!</a>, <a href="http://bxbxbai.github.io/2015/12/13/retrofit2/" target="_blank" rel="noopener">Retrofit</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;SkyBlue&quot; size=&quot;6px&quot;&gt;&lt;strong&gt;持续更行中&lt;/strong&gt;&lt;/font&gt;&lt;/center&gt;

&lt;h2 id=&quot;Fragment-中弹出-PopWindow-要使背景被透明（无效的问题）&quot;&gt;&lt;a href=&quot;#Fragment-中弹出-PopWindow-要使背景被透明（无效的问题）&quot; class=&quot;headerlink&quot; title=&quot;Fragment 中弹出 PopWindow 要使背景被透明（无效的问题）&quot;&gt;&lt;/a&gt;Fragment 中弹出 PopWindow 要使背景被透明（无效的问题）&lt;/h2&gt;&lt;p&gt;问题：单独在 pop 里面设置属性的话只会半透明掉 activity 的，因为 getactivity 的 getwindow 方法获取到的是 activity 的窗体，而不是 Fragment 的&lt;br&gt;实现：在 Fragment 的布局中设置半透明属性，而且是该布局最下面添加一个控件（eg:textview），将该控件设置半透明背景，然后pop显示和消失就让该控件显示和消失&lt;/p&gt;
&lt;h2 id=&quot;1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。&quot;&gt;&lt;a href=&quot;#1-解释内存中的栈（stack）、堆-heap-和静态存储区的用法。&quot; class=&quot;headerlink&quot; title=&quot;1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。&quot;&gt;&lt;/a&gt;1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。&lt;/h2&gt;&lt;p&gt;答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；
    
    </summary>
    
      <category term="知识点" scheme="https://yangxiaoge.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Android" scheme="https://yangxiaoge.github.io/tags/Android/"/>
    
      <category term="Java" scheme="https://yangxiaoge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Eshop-RN 成功运行爬坑记录</title>
    <link href="https://yangxiaoge.github.io/2017/02/09/2017-02-09-Eshop-RN-%E6%88%90%E5%8A%9F%E8%BF%90%E8%A1%8C%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://yangxiaoge.github.io/2017/02/09/2017-02-09-Eshop-RN-成功运行爬坑记录/</id>
    <published>2017-02-09T15:21:42.000Z</published>
    <updated>2018-01-19T01:09:00.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先上图片"><a href="#先上图片" class="headerlink" title="先上图片"></a>先上图片</h2><p><img src="/img/Eshop成功运行.png" alt="终端及代码图"></p><p><img src="/img/eshop-nexus5X截图.png" alt="Nexus 5X真机图"></p><h2 id="问题总结-持续更新ing"><a href="#问题总结-持续更新ing" class="headerlink" title="问题总结(持续更新ing)"></a>问题总结(持续更新ing)</h2><a id="more"></a><ul><li><code>npm install</code> 要保证网络畅通</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener"><code>node</code></a>版本尽量用官方<a href="https://nodejs.org/en/" target="_blank" rel="noopener">推荐版本</a>, 或者低版本(之前由于我用了v7.4.0版本,导致运行报错等各种奇葩问题。 降级到v6.9.5之后就解决了)</li><li>Git拉去新工程之后最好先删除<code>node_modules</code>,再运行<code>npm install</code></li><li>more</li></ul><h2 id="附上RN学习思维导图"><a href="#附上RN学习思维导图" class="headerlink" title="附上RN学习思维导图"></a>附上RN学习思维导图</h2><p><img src="/img/RN学习指南.png" alt="RN学习指南"></p><h2 id="RN组件可用属性整理"><a href="#RN组件可用属性整理" class="headerlink" title="RN组件可用属性整理"></a>RN组件可用属性整理</h2><p>图片来源 <a href="http://www.jianshu.com/p/fa0874be0827" target="_blank" rel="noopener">给所有开发者的React Native详细入门指南（第一阶段）</a>文中Demo地址 <a href="https://github.com/MarnoDev/HelloRN/blob/master/RN%E7%BB%84%E4%BB%B6%E5%8F%AF%E7%94%A8%E5%B1%9E%E6%80%A7%E6%95%B4%E7%90%86.xlsx" target="_blank" rel="noopener">RN组件可用属性整理.xlsx</a><br><img src="/img/RN组件可用属性整理.png" alt="Nexus 5X真机图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先上图片&quot;&gt;&lt;a href=&quot;#先上图片&quot; class=&quot;headerlink&quot; title=&quot;先上图片&quot;&gt;&lt;/a&gt;先上图片&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/Eshop成功运行.png&quot; alt=&quot;终端及代码图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/eshop-nexus5X截图.png&quot; alt=&quot;Nexus 5X真机图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题总结-持续更新ing&quot;&gt;&lt;a href=&quot;#问题总结-持续更新ing&quot; class=&quot;headerlink&quot; title=&quot;问题总结(持续更新ing)&quot;&gt;&lt;/a&gt;问题总结(持续更新ing)&lt;/h2&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://yangxiaoge.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://yangxiaoge.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结</title>
    <link href="https://yangxiaoge.github.io/2016/12/30/2016-12-30-2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://yangxiaoge.github.io/2016/12/30/2016-12-30-2016年终总结/</id>
    <published>2016-12-30T11:12:34.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~</p><p>掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活<a id="more"></a>，但是相比之下我还是喜欢踏实的工作，花着自己辛苦挣来的工资（当然是给老婆啦^_^），很开心！</p><p>下面说说毕业后在<code>软创</code>学到的东西吧, 软创是我毕业来的第一家公司,主要学习的知识点方向有两个: Android, Birt(报表,涉及数据库的CRUD知识点)。</p><p>概括一下Android的学习，毕竟这是我个人爱好的！（当然，今年IT也面临了<code>寒冬</code>，不过也不用恐慌，做好自己！！！）</p><p>在2016年里完成的项目：</p><ul><li>1、<a href="https://play.google.com/store/apps/details?id=com.ztesoft.zsmart.datamall.app.ghana" target="_blank" rel="noopener">My Busy 4G</a>  </li><li>2、<a href="https://play.google.com/store/apps/details?id=mm.com.mptvas" target="_blank" rel="noopener">MPT 4U</a></li></ul><p>经历过第一个公司级别的项目<code>My Busy 4G</code>之后，最大收获就是：个人水平能力得到了很大的提升，尤其是同事们都很热心！还有一个收获就是：学习方法！<br><code>举个栗子</code>：新下来一个需求，首先要考虑的是项目中是否有可以复用的业务模块，组件等等（模块化开发的重要性！），其次就是要利用好搜索引擎（Google），Github，Stack Overflow，CSDN等。<br>当然有时候我还需要自己造轮子（心平气和，不浮躁，孰能生巧）。在软创这一年里我的技术可以说是飞速提升，受益良多！</p><p>在这一年里，我很庆幸，我养成了一个习惯：每天早上在公司班车上都要阅读几篇公众号的文章，然后看看新闻。</p><p>感谢有几位交心好友，祝前程似锦，愿友谊长存！</p><p>最后，祝我的家人，亲朋在新的一年身体健康，工作顺利，鸡年大吉~</p><p>2017 Fighting！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~&lt;/p&gt;
&lt;p&gt;掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活
    
    </summary>
    
      <category term="个人总结" scheme="https://yangxiaoge.github.io/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="个人总结" scheme="https://yangxiaoge.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="https://yangxiaoge.github.io/2016/12/29/2016-12-29-JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://yangxiaoge.github.io/2016/12/29/2016-12-29-JavaScript学习笔记/</id>
    <published>2016-12-29T09:34:01.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="廖雪峰-js教程"><a href="#廖雪峰-js教程" class="headerlink" title="廖雪峰 js教程"></a>廖雪峰 js教程</h1><blockquote><p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000" target="_blank" rel="noopener">JavaScript教程</a></p></blockquote><p>我的练习基本是按着教程敲了一遍.  用的Chrome调试窗口,很方便!</p><p><strong>以下是笔记</strong></p><h2 id="javascript的五种基本数据类型"><a href="#javascript的五种基本数据类型" class="headerlink" title="javascript的五种基本数据类型"></a>javascript的五种基本数据类型</h2><p>基本数据类型:<a id="more"></a> Undefined，Null，Boolean，Number和String; 此外还含有一种复杂数据类型—Object</p><h2 id="if判断-传参传的非boolean类型"><a href="#if判断-传参传的非boolean类型" class="headerlink" title="if判断,传参传的非boolean类型"></a>if判断,传参传的非boolean类型</h2><pre><code>var s = &#39;123&#39;;if (s.length) { // 条件计算结果为3    console.log(&quot;你好啊&quot;); //打印结果为你好啊}原因: JavaScript把null、undefined、0、NaN和空字符串&#39;&#39;视为false，其他值一概视为true，因此上述代码条件判断的结果是true。</code></pre><h2 id="Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。"><a href="#Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。" class="headerlink" title="Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。"></a>Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</h2><pre><code>var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Adam&#39;, 85]]);m.get(&#39;Michael&#39;); // 95m.delete(&#39;Adam&#39;); // 删除key &#39;Adam&#39;var s = new Set();s.add(1); // Set {1}s.add(2); // Set {1, 2}s.add(3); // Set {1, 2,3}s.delete(3); // Set {1, 2}</code></pre><h2 id="ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。"><a href="#ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。" class="headerlink" title="ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。"></a>ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。</h2><pre><code>// 更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：//forEach()方法是ES5.1标准引入的var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];a.forEach(function (element, index, array) {    // element: 指向当前元素的值    // index: 指向当前索引    // array: 指向Array对象本身    alert(element);});或者://由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];a.forEach(function (element) {    alert(element);});</code></pre><h2 id="JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array："><a href="#JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：" class="headerlink" title="JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array："></a>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</h2><pre><code>arguments，你可以获得调用者传入的所有参数实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) {    if (arguments.length === 2) {        // 实际拿到的参数是a和b，c为undefined        c = b; // 把b赋给c        b = null; // b变为默认值    }    // ...}要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。</code></pre><h2 id="高阶函数-高阶函数英文叫Higher-order-function"><a href="#高阶函数-高阶函数英文叫Higher-order-function" class="headerlink" title="高阶函数, 高阶函数英文叫Higher-order function"></a>高阶函数, 高阶函数英文叫Higher-order function</h2><pre><code class="//练习：不要使用JavaScript内置的parseInt()函数，利用map和reduce操作实现一个string2int()函数：">        function string2int(s) {            return s.split(&#39;&#39;).map(strNum =&gt; strNum * 1).reduce((x, y) =&gt; x * 10 + y)        }        string2int(&#39;12345&#39;)</code></pre><h2 id="细细理解-map-reduce-filter-的区别"><a href="#细细理解-map-reduce-filter-的区别" class="headerlink" title="细细理解 map(), reduce(), filter()的区别"></a>细细理解 map(), reduce(), filter()的区别</h2><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><pre><code>如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。var arr = [10, 20, 1, 2];arr.sort(function (x, y) {    if (x &lt; y) {        return -1;    }    if (x &gt; y) {        return 1;    }    return 0;}); // [1, 2, 10, 20]var arr = [&#39;Google&#39;, &#39;apple&#39;, &#39;Microsoft&#39;];arr.sort(function (s1, s2) {    x1 = s1.toUpperCase();    x2 = s2.toUpperCase();    if (x1 &lt; x2) {        return -1;    }    if (x1 &gt; x2) {        return 1;    }    return 0;}); // [&#39;apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;]最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：</code></pre><h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><pre><code>我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：function sum(arr) {    return arr.reduce(function (x, y) {        return x + y;    });}sum([1, 2, 3, 4, 5]); // 15如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！function lazy_sum(arr) {    var sum = function () {        return arr.reduce(function (x, y) {            return x + y;        });    }    return sum;}当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()调用函数f时，才真正计算求和的结果：f(); // 15在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。</p><pre><code>x =&gt; x * x上面的箭头函数相当于：function (x) {    return x * x;}箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return：x =&gt; {    if (x &gt; 0) {        return x * x;    }    else {        return - x * x;    }}</code></pre><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><pre><code>用generator改写如下：function* fib(max) {    var        t,        a = 0,        b = 1,        n = 1;    while (n &lt; max) {        yield a;        t = a + b;        a = b;        b = t;        n ++;    }    return a;}直接调用试试：fib(5); // fib {[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window}直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。调用generator对象有两个方法，一是不断地调用generator对象的next()方法：var f = fib(5);f.next(); // {value: 0, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 2, done: false}f.next(); // {value: 3, done: true}next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。</code></pre><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><pre><code>总结一下，有这么几条规则需要遵守：不要使用new Number()、new Boolean()、new String()创建包装对象；用parseInt()或parseFloat()来转换任意类型到number；用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；typeof操作符可以判断出number、boolean、string、function和undefined；判断Array要使用Array.isArray(arr)；判断null请使用myVar === null；判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;；函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。</code></pre><h2 id="RegExp-正则表达式"><a href="#RegExp-正则表达式" class="headerlink" title="RegExp (正则表达式)"></a>RegExp (正则表达式)</h2><pre><code>在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：&#39;00\d&#39;可以匹配&#39;007&#39;，但无法匹配&#39;00A&#39;；&#39;\d\d\d&#39;可以匹配&#39;010&#39;；&#39;\w\w&#39;可以匹配&#39;js&#39;；.可以匹配任意字符，所以：&#39;js.&#39;可以匹配&#39;jsp&#39;、&#39;jss&#39;、&#39;js!&#39;等等。JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：var s=&#39;zhuzhuyang, xiaoyang, feiyang&#39;;var reg = /[a-zA-Z]+yang/g;reg.exec(s); //[&#39;zhuzhuyang&#39;]reg.lastIndex; //10reg.exec(s); //[&#39;xiaoyang&#39;]reg.lastIndex; //20reg.exec(s); //[&#39;feiyang&#39;]reg.lastIndex; //29reg.exec(s); // null，直到结束仍没有匹配到</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code>在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：number：和JavaScript的number完全一致；boolean：就是JavaScript的true或false；string：就是JavaScript的string；null：就是JavaScript的null；array：就是JavaScript的Array表示方式——[]；object：就是JavaScript的{ ... }表示方式。</code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><pre><code>var xiaoming = {    name: &#39;小明&#39;,    age: 14,    gender: true,    height: 1.65,    grade: null,    &#39;middle-school&#39;: &#39;\&quot;W3C\&quot; Middle School&#39;,    skills: [&#39;JavaScript&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Lisp&#39;]};JSON.stringify(xiaoming); // &#39;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\&quot;W3C\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]}&#39;要输出得好看一些，可以加上参数，按缩进输出：JSON.stringify(xiaoming, null, &#39;  &#39;);{  &quot;name&quot;: &quot;小明&quot;,  &quot;age&quot;: 14,  &quot;gender&quot;: true,  &quot;height&quot;: 1.65,  &quot;grade&quot;: null,  &quot;middle-school&quot;: &quot;\&quot;W3C\&quot; Middle School&quot;,  &quot;skills&quot;: [    &quot;JavaScript&quot;,    &quot;Java&quot;,    &quot;Python&quot;,    &quot;Lisp&quot;  ]}更多JSON用法可以看廖雪峰教程</code></pre><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><pre><code>var Student = {    name: &#39;Robot&#39;,    height: 1.2,    run: function () {        console.log(this.name + &#39; is running...&#39;);    }};var xiaoming = {    name: &#39;小明&#39;};xiaoming.__proto__ = Student;注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：xiaoming.name; // &#39;小明&#39;xiaoming.run(); // 小明 is running...xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用：</code></pre><p><img src="http://www.liaoxuefeng.com/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l" alt=""><br><code>请注意</code>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.<strong>proto</strong>去改变一个对象的原型，并且，低版本的IE也无法使用<strong>proto</strong>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</p><pre><code>// 原型对象:var Student = {    name: &#39;Robot&#39;,    height: 1.2,    run: function () {        console.log(this.name + &#39; is running...&#39;);    }};function createStudent(name) {    // 基于Student原型创建一个新对象:    var s = Object.create(Student);    // 初始化新对象:    s.name = name;    return s;}var xiaoming = createStudent(&#39;小明&#39;);xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;廖雪峰-js教程&quot;&gt;&lt;a href=&quot;#廖雪峰-js教程&quot; class=&quot;headerlink&quot; title=&quot;廖雪峰 js教程&quot;&gt;&lt;/a&gt;廖雪峰 js教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的练习基本是按着教程敲了一遍.  用的Chrome调试窗口,很方便!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是笔记&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;javascript的五种基本数据类型&quot;&gt;&lt;a href=&quot;#javascript的五种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;javascript的五种基本数据类型&quot;&gt;&lt;/a&gt;javascript的五种基本数据类型&lt;/h2&gt;&lt;p&gt;基本数据类型:
    
    </summary>
    
      <category term="JavaScript" scheme="https://yangxiaoge.github.io/categories/JavaScript/"/>
    
    
      <category term="前端开发" scheme="https://yangxiaoge.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://yangxiaoge.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flow.ci持续集成</title>
    <link href="https://yangxiaoge.github.io/2016/12/07/2016-12-07-flow.ci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://yangxiaoge.github.io/2016/12/07/2016-12-07-flow.ci持续集成/</id>
    <published>2016-12-07T14:19:05.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来<code>给自己定个长期目标</code>， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。<br><a id="more"></a><br><strong>言归正传</strong><br>其实获得<a href="http://dashboard.flow.ci/" target="_blank" rel="noopener">FlowCi</a>测试资格已经好几个月了， 一直没有去使用它， <a href="http://dashboard.flow.ci/" target="_blank" rel="noopener">FlowCi</a>功能非常强大。 之前我用的是<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="noopener">daocloud</a>持续集成博客, 不过今天发现持续集成失败了， 发现是<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="noopener">daocloud</a>升级了， 集成的配置文件需要修改， 我就乘此机会转投<a href="http://dashboard.flow.ci/" target="_blank" rel="noopener">FlowCi</a>的怀抱中了 O(∩_∩)O哈哈~<br>那么 怎么使用 FlowCi 为 Hexo博客持续集成呢？</p><blockquote><p>PS: (2016-12-8 09:31:50 add) 强迫症的我还是把<a href="https://dashboard.daocloud.io/build-flows/c8e37fcc-8c38-4a7c-b0e8-c464f2ea3c92" target="_blank" rel="noopener">daocloud</a>持续集成搞好了(^o^)/~, 不过我还是用FlowCi吧, 尝试新工具哈哈~~<br><em>啪啪打脸~~</em> flowci hook push不及时, 有时候coding源码修改了,但是都不push消息给flowci,所以博客有时候并没有自动集成o(╯□╰)o</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fai7qzz2unj216v0edgmw.jpg" alt="create project"></p><h2 id="选择代码仓库"><a href="#选择代码仓库" class="headerlink" title="选择代码仓库"></a>选择代码仓库</h2><p> 这里取决于hexo博客源文件存放在哪里了 github, coding等…<br><img src="http://ww2.sinaimg.cn/mw1024/c05ae6b6gw1fai7ue4f1vj217c0ei0tv.jpg" alt="select the code repository"></p><h2 id="创建新的工作流"><a href="#创建新的工作流" class="headerlink" title="创建新的工作流"></a>创建新的工作流</h2><p> 之前有简单的步骤就省略了…</p><p> <img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fai89o501cj216z0kj76h.jpg" alt="Workflow select"></p><p> 工作流选择, <code>Nodejs</code>(Hexo编译所需环境)，版本选择了最新的<code>v6.6.0</code>, 当然还有其他的, <code>Python</code>, <code>Android</code>, <code>Php</code>等。<br> 后面我会尝试使用<code>Android持续集成</code>，也会写相应文章。</p><h2 id="触发器-什么时候自动集成"><a href="#触发器-什么时候自动集成" class="headerlink" title="触发器(什么时候自动集成)"></a>触发器(什么时候自动集成)</h2><p> 设置 触发器-push-正则匹配-master, 意思就是当 hexo博客git的master源文件改变时, 就会触发FlowCi的持续集成!</p><h2 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a>自定义脚本</h2><p>这里的 <code>.daocloud文件夹</code>(文件夹随便怎么命名)是用来存放<code>id_rsa</code>的</p><pre><code># 安装Hexo命令行工具flow_cmd &quot;npm install hexo-cli -g&quot; --echo# 准备并安装私钥flow_cmd &quot;cp .daocloud/id_rsa .&quot; --echo  flow_cmd &quot;chmod 600 ./id_rsa&quot; --echo  flow_cmd &quot;eval $(ssh-agent)&quot; --echo  flow_cmd &quot;ssh-add ./id_rsa&quot; --echo# 执行Hexo生成和发布flow_cmd &quot;hexo clean&quot; --echo  flow_cmd &quot;hexo g&quot; --echo  flow_cmd &quot;hexo d&quot; --echo</code></pre><p><img src="http://ww1.sinaimg.cn/mw1024/c05ae6b6gw1fai8ir2iphj217j0kv77e.jpg" alt="custom script"></p><h1 id="添加FlowCi的-RSA公匙到github以及coding-授予读写权限"><a href="#添加FlowCi的-RSA公匙到github以及coding-授予读写权限" class="headerlink" title="添加FlowCi的 RSA公匙到github以及coding(授予读写权限)"></a>添加FlowCi的 RSA公匙到github以及coding(授予读写权限)</h1><p><img src="http://ww3.sinaimg.cn/mw1024/c05ae6b6gw1fajdovw24yj21640e4wh4.jpg" alt="RSA公匙配置"></p><h1 id="快去提交代码吧"><a href="#快去提交代码吧" class="headerlink" title="快去提交代码吧"></a>快去提交代码吧</h1><p>我是单独在coding建了一个新的仓库存放博客源文件,<a href="https://coding.net/u/yangxiaoge/p/yangxiaoge-CI" target="_blank" rel="noopener">yangxiaoge-CI</a><br>之后只要往<code>yangxiaoge-CI</code>仓库中提交或者增删改查时, <code>FlowCi</code>会自动集成并发布到<a href="https://coding.net/u/yangxiaoge/p/yangxiaoge" target="_blank" rel="noopener">yangxiaoge</a>编译后的博客地址中!<br><strong>binggo!!!</strong>坐等集成好,登录网站查看变动吧！是不是很爽😏 , 跨PC更新博客也更方便啦~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来&lt;code&gt;给自己定个长期目标&lt;/code&gt;， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。&lt;br&gt;
    
    </summary>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    
      <category term="Hexo" scheme="https://yangxiaoge.github.io/tags/Hexo/"/>
    
      <category term="持续集成" scheme="https://yangxiaoge.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>mock数据</title>
    <link href="https://yangxiaoge.github.io/2016/11/08/2016-11-08-Fiddler%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82mock%E5%81%87%E6%95%B0%E6%8D%AE/"/>
    <id>https://yangxiaoge.github.io/2016/11/08/2016-11-08-Fiddler拦截请求mock假数据/</id>
    <published>2016-11-08T10:44:59.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 mock 数据的集中方法。</p><h2 id="Fiddler抓包拦截"><a href="#Fiddler抓包拦截" class="headerlink" title="Fiddler抓包拦截"></a>Fiddler抓包拦截</h2><p><img src="/img/fiddler mock.png" alt="看图一目了然"></p><h2 id="Easy-Mock"><a href="#Easy-Mock" class="headerlink" title="Easy Mock"></a><a href="https://easy-mock.com/" target="_blank" rel="noopener">Easy Mock</a></h2><p><img src="/img/easy-mock.png" alt="easy-mock"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;介绍 mock 数据的集中方法。&lt;/p&gt;
&lt;h2 id=&quot;Fiddler抓包拦截&quot;&gt;&lt;a href=&quot;#Fiddler抓包拦截&quot; class=&quot;headerlink&quot; title=&quot;Fiddler抓包拦截&quot;&gt;&lt;/a&gt;Fiddler抓包拦截&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="mock" scheme="https://yangxiaoge.github.io/categories/mock/"/>
    
    
      <category term="Fiddler" scheme="https://yangxiaoge.github.io/tags/Fiddler/"/>
    
      <category term="mock" scheme="https://yangxiaoge.github.io/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄漏总结</title>
    <link href="https://yangxiaoge.github.io/2016/10/10/2016-10-10-Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://yangxiaoge.github.io/2016/10/10/2016-10-10-Android内存泄漏总结/</id>
    <published>2016-10-10T13:29:20.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放<a id="more"></a>，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个总结沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。</p><p>我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。</p><h2 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h2><p>Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。</p><ul><li><p>静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</p></li><li><p>栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p></li><li><p>堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</p></li></ul><h2 id="栈与堆的区别："><a href="#栈与堆的区别：" class="headerlink" title="栈与堆的区别："></a>栈与堆的区别：</h2><p>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。</p><p>堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。</p><p>举个例子:</p><pre><code>public class Sample {    int s1 = 0;    Sample mSample1 = new Sample();    public void method() {        int s2 = 1;        Sample mSample2 = new Sample();    }}Sample mSample3 = new Sample();</code></pre><p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。<br>mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</p><p>结论：</p><p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。</p><p>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p><p>了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。</p><h2 id="Java是如何管理内存"><a href="#Java是如何管理内存" class="headerlink" title="Java是如何管理内存"></a>Java是如何管理内存</h2><p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。</p><p>监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p><p>为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。<br>以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。</p><p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/1.gif" alt=""></p><p>Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p><h2 id="什么是Java中的内存泄露"><a href="#什么是Java中的内存泄露" class="headerlink" title="什么是Java中的内存泄露"></a>什么是Java中的内存泄露</h2><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。</p><p>通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。</p><p><img src="http://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/2.gif" alt=""></p><p>因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。</p><p>对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。</p><p>同样给出一个 Java 内存泄漏的典型例子，</p><pre><code>Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) {    Object o = new Object();    v.add(o);    o = null;   }</code></pre><p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p><p><strong>详细Java中的内存泄漏</strong></p><p>1.Java内存回收机制</p><p>不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 </p><p>2.Java内存泄漏引起的原因</p><p>内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j</p><p>Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：</p><p>1、静态集合类引起内存泄漏：</p><p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 </p><p>例如</p><pre><code>Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++){Object o = new Object();v.add(o);o = null;}</code></pre><p>在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</p><p>2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p><p>例如：</p><pre><code>public static void main(String[] args){Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();Person p1 = new Person(&quot;唐僧&quot;,&quot;pwd1&quot;,25);Person p2 = new Person(&quot;孙悟空&quot;,&quot;pwd2&quot;,26);Person p3 = new Person(&quot;猪八戒&quot;,&quot;pwd3&quot;,27);set.add(p1);set.add(p2);set.add(p3);System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素!p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变set.remove(p3); //此时remove不掉，造成内存泄漏set.add(p3); //重新添加，居然添加成功System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素!for (Person person : set){System.out.println(person);}}</code></pre><p>3、监听器</p><p>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p><p>4、各种连接 </p><p>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。</p><p>5、内部类和外部模块的引用</p><p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：<br>public void registerMsg(Object b);<br>这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。</p><p>6、单例模式 </p><p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：</p><pre><code>class A{public A(){B.getInstance().setA(this);}....}//B类采用单例模式class B{private A a;private static B instance=new B();public B(){}public static B getInstance(){return instance;}public void setA(A a){this.a=a;}//getter...}</code></pre><p>显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</p><h2 id="Android中常见的内存泄漏汇总"><a href="#Android中常见的内存泄漏汇总" class="headerlink" title="Android中常见的内存泄漏汇总"></a>Android中常见的内存泄漏汇总</h2><hr><h3 id="集合类泄漏"><a href="#集合类泄漏" class="headerlink" title="集合类泄漏"></a>集合类泄漏</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。</p><h3 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h3><p>由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子，</p><pre><code>public class AppManager {private static AppManager instance;private Context context;private AppManager(Context context) {this.context = context;}public static AppManager getInstance(Context context) {if (instance == null) {instance = new AppManager(context);}return instance;}}</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p><p>1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</p><p>2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</p><p>正确的方式应该改为下面这种方式：</p><pre><code>public class AppManager {private static AppManager instance;private Context context;private AppManager(Context context) {this.context = context.getApplicationContext();// 使用Application 的context}public static AppManager getInstance(Context context) {if (instance == null) {instance = new AppManager(context);}return instance;}}</code></pre><p>或者这样写，连 Context 都不用传进来了：</p><pre><code>在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，...context = getApplicationContext();...   /**     * 获取全局的context     * @return 返回全局context对象     */    public static Context getContext(){        return context;    }public class AppManager {private static AppManager instance;private Context context;private AppManager() {this.context = MyApplication.getContext();// 使用Application 的context}public static AppManager getInstance() {if (instance == null) {instance = new AppManager();}return instance;}}</code></pre><h3 id="匿名内部类-非静态内部类和异步线程"><a href="#匿名内部类-非静态内部类和异步线程" class="headerlink" title="匿名内部类/非静态内部类和异步线程"></a>匿名内部类/非静态内部类和异步线程</h3><p>非静态内部类创建静态实例造成的内存泄漏</p><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p><pre><code>        public class MainActivity extends AppCompatActivity {        private static TestResource mResource = null;        @Override        protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        if(mManager == null){        mManager = new TestResource();        }        //...        }        class TestResource {        //...        }        }</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：</p><p>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p><p><img src="http://img.blog.csdn.net/20151123144226349?spm=5176.100239.blogcont.9.CtU1c4" alt="Context的应用场景"></p><p>其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露</p><pre><code>    public class MainActivity extends Activity {    ...    Runnable ref1 = new MyRunable();    Runnable ref2 = new Runnable() {        @Override        public void run() {        }    };       ...    }</code></pre><p>ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存：</p><p><img src="http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e?spm=5176.100239.blogcont.10.CtU1c4" alt=""></p><p>可以看到，ref1没什么特别的。</p><p>但ref2这个匿名类的实现对象里面多了一个引用：</p><p>this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。</p><h3 id="Handler-造成的内存泄漏"><a href="#Handler-造成的内存泄漏" class="headerlink" title="Handler 造成的内存泄漏"></a>Handler 造成的内存泄漏</h3><p>Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。</p><p>由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。</p><p>举个例子：</p><pre><code>    public class SampleActivity extends Activity {    private final Handler mLeakyHandler = new Handler() {    @Override    public void handleMessage(Message msg) {      // ...    }    }    @Override    protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    // Post a message and delay its execution for 10 minutes.    mLeakyHandler.postDelayed(new Runnable() {      @Override      public void run() { /* ... */ }    }, 1000 * 60 * 10);    // Go back to the previous Activity.    finish();    }    }</code></pre><p>在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。</p><p>修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码：</p><pre><code>public class SampleActivity extends Activity {  /**   * Instances of static inner classes do not hold an implicit   * reference to their outer class.   */  private static class MyHandler extends Handler {    private final WeakReference&lt;SampleActivity&gt; mActivity;    public MyHandler(SampleActivity activity) {      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);    }    @Override    public void handleMessage(Message msg) {      SampleActivity activity = mActivity.get();      if (activity != null) {        // ...      }    }  }  private final MyHandler mHandler = new MyHandler(this);  /**   * Instances of anonymous classes do not hold an implicit   * reference to their outer class when they are &quot;static&quot;.   */  private static final Runnable sRunnable = new Runnable() {      @Override      public void run() { /* ... */ }  };  @Override  protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    // Post a message and delay its execution for 10 minutes.    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);    // Go back to the previous Activity.    finish();  }}</code></pre><p>综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。</p><p>前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。</p><p>Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。</p><p><img src="https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg" alt=""></p><p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p><p>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</p><p>假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形：</p><p>首先定义一个HashMap，保存软引用对象。</p><pre><code>private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; ();</code></pre><p>再来定义一个方法，保存Bitmap的软引用到HashMap。</p><p><img src="https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg" alt=""></p><p>使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。</p><p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p><p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p><p>ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。</p><p>下面几个方法都可以移除 Message：</p><pre><code>public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Object token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object);</code></pre><h3 id="尽量避免使用-static-成员变量"><a href="#尽量避免使用-static-成员变量" class="headerlink" title="尽量避免使用 static 成员变量"></a>尽量避免使用 static 成员变量</h3><p>如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。</p><p>这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。</p><p>这里修复的方法是：</p><p>不要在类初始时初始化静态成员。可以考虑lazy初始化。<br>架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p><h3 id="避免-override-finalize"><a href="#避免-override-finalize" class="headerlink" title="避免 override finalize()"></a>避免 override finalize()</h3><p>1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是：<br>        虚拟机调用GC的时间不确定<br>        Finalize daemon线程被调度到的时间不确定</p><p>2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是：</p><p>含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。</p><p>3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。</p><h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h3><p>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p><h3 id="一些不良代码造成的内存压力"><a href="#一些不良代码造成的内存压力" class="headerlink" title="一些不良代码造成的内存压力"></a>一些不良代码造成的内存压力</h3><p>有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。</p><p>比如：<br>        Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。<br>        构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</p><p>尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。</p><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p><pre><code>    将内部类改为静态内部类    静态内部类中使用弱引用来引用外部类的成员变量</code></pre><p>Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable.</p><p>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</p><p>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</p><p>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。</p><blockquote><p><a href="https://github.com/GeniusVJR/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">原文链接</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放
    
    </summary>
    
      <category term="Android" scheme="https://yangxiaoge.github.io/categories/Android/"/>
    
    
      <category term="内存泄漏" scheme="https://yangxiaoge.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>有人向我反馈了一个bug</title>
    <link href="https://yangxiaoge.github.io/2016/09/23/2016-9-23-%E6%9C%89%E4%BA%BA%E5%90%91%E6%88%91%E5%8F%8D%E9%A6%88%E4%BA%86%E4%B8%80%E4%B8%AAbug/"/>
    <id>https://yangxiaoge.github.io/2016/09/23/2016-9-23-有人向我反馈了一个bug/</id>
    <published>2016-09-23T12:55:26.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<p>本文原文地址 : <a href="http://www.midaoi.com/2015/08/28/bug/" target="_blank" rel="noopener">Midaoi小站</a></p><blockquote><p>前言</p></blockquote><p>这篇文章非常有意思！ </p><blockquote><p><a href="http://www.reddit.com/r/ProgrammerHumor/comments/2spd2s/when_someone_gives_you_a_bug_long/" target="_blank" rel="noopener">英文原文 →</a></p></blockquote><p>//我是一个Android开发者，但我想这个故事对任何开发者都会引起共鸣的<br><a id="more"></a><br>有人向你反馈了一个 bug。 “26 楼会议室的灯亮着。它需要被熄灭。”bug 的备注里写道“你应该能在 5 分钟内搞定，只要按一下开关就好了。“ 你去了 26 楼的会议室。灯的确亮着，但房间里没有灯的开关。</p><p>所以，你准备安装一个。但设计师说，它会破坏房间的美感。另外，墙壁是混凝土。你需要合适的工具才能安装开关。但是，没有人会批准购买这些工具。如果没有合适的工具，安装开关将需要两天。他们希望你现在就能把灯关上，因为他们害怕 CEO 可能心血来潮决定去 26 楼逛逛，并恰好路过了会议室，问为什么灯是亮着的。</p><p>现在你不断地收到邮件，询问为什么会议室的灯还是亮着的。现在你不得不群发一封邮件说明情况，几人开始了一个恐慌的电子邮件链。</p><p>你知道，如果你期待着问题能够被邮件讨论解决（而不实际做点什么），这个问题永远也不会得到修复。bug 系统里，这个 bug 归你处理，而且它的最后期限就是今天。如果问题没有解决，会有麻烦的是你。所以，你设法进到了 26 楼走廊的天花板里，找到了会议室灯的电线，一刀切断。问题解决了。</p><p>为了平息在电子邮件链里的恐慌，你(再次群发邮件)说明了你是如何解决问题的。</p><p>邮箱安静了一阵。当它再次响个不停的时候，每个人都在担心，现在会议室的灯无法开启和关闭。如果 CEO 想在那里开会怎么办？因此，他们要求你“把灯的电线牵引到地下室去”。当有人需要开关灯时，他们会通知你到地下室去，连接或断开电线。</p><p>你抗议这个荒谬的解决方案。你的上司说，“是的，我知道这不理想。但它是现在唯一的解决方案。“</p><p>这时，你面临着选择。你可以照着他们说的做，或者辞职以示抗议，另谋高就。但你知道，一旦你开始了新的工作，新的他们很可能也会要求你做这么白痴的事，如果不是更白痴的话。</p><p>你把 26 楼的电线牵引到了地下室。当你进入地下室后，发现已经有几十条电线挂在墙上，你知道你不是一个人，也知道了这个白痴想法是从哪来的。你调整好了电线，尽人事地贴上标记，默默地向下一个可能处理它的哥们道歉。</p><p>终于，你回到了你的办公桌，你收到了一个新的 report。 QA 重新开启了 bug。bug 描述里说“房间还是亮着。”</p><p>你回到 26 楼的会议室。灯是灭着的。你返回办公桌前，关闭了 bug，注明你已经亲自检查过了。</p><p>QA 再次重新开启了 bug。“房间还亮着”bug 描述里坚持。再次亲眼确认灯泡灭着后，你将情况汇报给了上司。他建议你去地下室检查电线。你抗议说你正直盯盯地看着灯，它就是灭着的。 “我知道，但去检查一下。这样一来你就可以告诉 QA 你确认了所有流程。”</p><p>你叹了口气，前往地下室。果然，电线没有连接，切口两端都好好地被包裹着。它们不可能以任何你能理解的方式导电。</p><p>你向 QA 反馈，你检查了电线，它们没有连接着，你正看着灯泡，它是熄灭的。</p><p>“我不是指灯泡，”QA 说。 “bug 里描述的是房间里的光。房间现在仍然不够暗。你应该拉下百叶窗。“<br>你回应说百叶窗不归你管，bug 描述的是灯光。</p><p>QA 不相信你，发出一组电子邮件，询问 bug 是否包含百叶窗拉下的问题。</p><p>你很是等待了一会，邮箱又一次响起了。 </p><p>“从理论上说，”他们问，“如果光太亮或太暗的话，在 26 楼会议室开会的人能自由拉上或拉下百叶窗吗？”</p><p>是的，他们可以，你回复。 “任何一个普通人都能做到吗？他们就不需要你做了吗？“是的，任何普通人。不，他们不会需要你。任何人都可以做到这一点。 “太好了。那么，灯光问题暂时到此为止。我会安排如何处理百叶窗的会议。“</p><p>bug 被关闭了。现在，CEO，可能从所有关于 26 楼会议室的讨论中感觉到了什么，希望在那里开会。你收到了几封希望开灯的惊慌失措的邮件。</p><p>你去了地下室，连上电线，并返回办公桌。你的收件箱多了 32 个新的消息。 “出问题了-灯还是熄灭的!”“有个问题-没有灯光!” “你收到我们发的邮件了吗？等等等等。</p><p>第 32 封邮件说道:“没事-灯亮了。”</p><p>这个(指 32 封邮件)过程，或多或少地，在开关灯时反复发生。</p><p>如果要说有什么好消息的话，那就是在会议结束后，大家甚至都忘记了 26 楼有个会议室，你也不需要对它做任何处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文原文地址 : &lt;a href=&quot;http://www.midaoi.com/2015/08/28/bug/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Midaoi小站&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章非常有意思！ &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.reddit.com/r/ProgrammerHumor/comments/2spd2s/when_someone_gives_you_a_bug_long/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英文原文 →&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;//我是一个Android开发者，但我想这个故事对任何开发者都会引起共鸣的&lt;br&gt;
    
    </summary>
    
      <category term="bug小场景" scheme="https://yangxiaoge.github.io/categories/bug%E5%B0%8F%E5%9C%BA%E6%99%AF/"/>
    
    
      <category term="article" scheme="https://yangxiaoge.github.io/tags/article/"/>
    
  </entry>
  
  <entry>
    <title>Windows常用工具</title>
    <link href="https://yangxiaoge.github.io/2016/09/21/2016-09-21-Windows%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>https://yangxiaoge.github.io/2016/09/21/2016-09-21-Windows常用工具/</id>
    <published>2016-09-21T15:24:00.000Z</published>
    <updated>2018-01-19T01:09:00.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先申明本文转载， 本文由 <a href="http://michaelxiang.me/" target="_blank" rel="noopener">Michael翔</a> 创作， 基于原文有所改动 !</p></blockquote><p>总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯：</p><hr><a id="more"></a><h2 id="Windowns常用软件"><a href="#Windowns常用软件" class="headerlink" title="Windowns常用软件"></a>Windowns常用软件</h2><h2 id="录制Gif工具"><a href="#录制Gif工具" class="headerlink" title="录制Gif工具"></a>录制Gif工具</h2><p><a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap录制Gif工具</a><br><a href="https://screentogif.codeplex.com/" target="_blank" rel="noopener">ScreenToGif</a> 工具相当不错，而且是绿色软件，真良心~~</p><h2 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h2><p><a href="http://www.faststone.org/" target="_blank" rel="noopener">FastStoneImageViewer</a> 免费软件，好用到爆！没广告！功能齐全！不光能看图，还能修图！<br><del>Picasa3 Google的图片管理软件(已经停止服务了)</del><br><a href="https://photos.google.com/" target="_blank" rel="noopener">Photos</a> Google 相册照片服务 (本人iPhone6内存16G伤不起(；′⌒`), 果断备份到Google Photos了!!!)</p><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p><a href="http://www.appinn.com/listary/" target="_blank" rel="noopener">Listary</a> 小众软件介绍，超级好用的文件搜索工具，按下快捷键，随时搜索<br><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> 也是传说中的文档搜索神器！其他功能有待开发……<br><!-- more --></p><h2 id="文件整理"><a href="#文件整理" class="headerlink" title="文件整理"></a>文件整理</h2><p><a href="http://www.softpedia.com/get/PORTABLE-SOFTWARE/System/File-management/Portable-Q-Dir.shtml" target="_blank" rel="noopener">Q-Dir</a> 有时候需要在文件夹之间移动文件，这时候，这个整理神器就能派上用场了！<br><a href="http://cn.ejie.me/" target="_blank" rel="noopener">Clover 3</a> 这款文件夹体验跟浏览器一样，不会有多窗口，不会杂乱无章 ! — <em>个人目前在用</em></p><h2 id="pdf查看"><a href="#pdf查看" class="headerlink" title="pdf查看"></a>pdf查看</h2><p><a href="http://www.foxitsoftware.cn/downloads/" target="_blank" rel="noopener">福昕pdf阅读正版</a><br><a href="http://pic.2345.com/" target="_blank" rel="noopener">2345看图王</a> 你没看错，2345就是这么强大~</p><h2 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h2><p><a href="http://www.potplayer.org/" target="_blank" rel="noopener">PotPlayer</a> 厌烦了暴风一打开就是广告，发现了这款播放器，没广告！能力出色！</p><h2 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h2><p><a href="http://www.flvcd.com/" target="_blank" rel="noopener">硕鼠</a> <em>有的也不能下载了，比如优酷</em>    视频下载神器！为了下载PC上的网易公开课发现的工具，很多视频网站都能下载！</p><h2 id="同步盘"><a href="#同步盘" class="headerlink" title="同步盘"></a>同步盘</h2><p><a href="https://c-t.yunpan.360.cn/" target="_blank" rel="noopener">360云盘</a><br><a href="https://pan.baidu.com/" target="_blank" rel="noopener">百度云</a><br>这两款同步盘真是给我带来了很大的便利，安全性啥的也不用去较真，非得整啥Dropbox(需要梯子)，毕竟自己也没啥重要隐私文件……</p><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p><a href="http://www.softpedia.com/dyn-search.php?search_term=unlocker+" target="_blank" rel="noopener">Unlocker下载</a> 当你重命名或删除一个文件/文件夹时，Windows 弹出对话框提示你“无法删除 xxx:它正在被其它用户/程序使用!”，怎么办?<br>其实<code>腾讯电脑管家</code>的 <strong>文件粉碎</strong> 功能也可以 — <em>个人在用</em></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 很占内存，但启动速度、标签、扩展同步等真是做的棒！一个账号，走遍天下~安利下知乎上的总结的<a href="http://zhuanlan.zhihu.com/michael-xox/20356820" target="_blank" rel="noopener">Chrome扩展</a> ~~需要更多的插件可以去知乎搜索下</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p><a href="https://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a> 很棒！裁剪、搜索、标签等细节功能做的很到位！简洁大气的风格，很喜欢。— 目前在用<br><a href="http://www.wiz.cn/" target="_blank" rel="noopener">为知笔记</a> 国内良心笔记公司，做的也很棒！代码高亮、Markdown等等都一应俱全，还有丰富的插件~</p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p>搜狗输入法 哈哈，没看错！就是它！安装截图扩展之后，快捷键就能截图，哪个电脑都ok，多方便！<a href="http://michaelxiang.me/2015/12/28/tools-sougoupinyin/" target="_blank" rel="noopener">搜狗输入法技巧总结</a></p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>这个就比较多了， 目前在用 Gmail，126，QQ等</p><h2 id="小众软件"><a href="#小众软件" class="headerlink" title="小众软件"></a>小众软件</h2><p><a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="noopener">Wgesture</a> 用惯浏览器鼠标手势的同志，这个绝对是你们的福利！全局鼠标手势！！！</p><h2 id="加密工具"><a href="#加密工具" class="headerlink" title="加密工具"></a>加密工具</h2><p><a href="http://www.wisecleaner.com/wise-folder-hider-free.html" target="_blank" rel="noopener">Wise Folder Hider Free</a> 隐私文件怎么保存？这个获奖无数的工具，免费版足够用啦！</p><hr><h2 id="Windows下的开发工具"><a href="#Windows下的开发工具" class="headerlink" title="Windows下的开发工具"></a>Windows下的开发工具</h2><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><a href="http://cmder.net/" target="_blank" rel="noopener">cmder</a> 如果厌倦了Windows下控制台丑陋不方便的样子，可以试试这个。</p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>Sublime Text<br>Notepad++<br>Atom</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>说到IDE当然离不开 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">jetbrains全家桶</a> 良心公司，学生党免费！前提是要有<strong>教育邮箱</strong>~<br>jetbrains全家桶: IntelliJ IDEA，PhpStorm，WebStorm，Pycharm -python开发，Android Studio也是它家提供支持的，等等<br>Redo python调试很方便，界面有点类似R-studio、<br>PyScripter python开发</p><h2 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h2><p>做完一个Coder，<a href="https://6d1b.cc" target="_blank" rel="noopener">ss</a>都懂的吧，学习工作专用，再配合Google搜索 (某度要慎重使用！)，效率大大提升~~</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续~~"></a>未完待续~~</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首先申明本文转载， 本文由 &lt;a href=&quot;http://michaelxiang.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Michael翔&lt;/a&gt; 创作， 基于原文有所改动 !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯：&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="工具" scheme="https://yangxiaoge.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://yangxiaoge.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
