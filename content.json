{"meta":{"title":"珠珠のBlog","subtitle":"Just do it!","description":"背着键盘的编程侠客!","author":"Bruce Yang","url":"https://yangxiaoge.github.io"},"pages":[{"title":"","date":"2017-09-20T01:41:45.592Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"404.html","permalink":"https://yangxiaoge.github.io/404.html","excerpt":"","text":""},{"title":"About","date":"2017-09-20T01:41:45.604Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"about/index.html","permalink":"https://yangxiaoge.github.io/about/index.html","excerpt":"","text":"爱技术、爱生活。 Hey，我是 Bruce Yang，Android 开发者 &amp; 独立开发者，南京信息工程大学 · 计算机科学与技术 2015 年毕业。 个人履历 江苏北弓智能 2017.04 - 至今ZTEsoft 中兴软创 2015.04 - 2017.04 技术方面 擅长 Android 开发，但是 Android 之外，对前后端技术均有爱好。一些作品和开源项目，👉 戳 Mumuxi 与 Github。 兴趣爱好 喜欢听歌，喜欢的歌手有 陈奕迅 林宥嘉 周杰伦，我的网易云音乐。喜欢运动，也喜欢户外，登山等等。 外包勿扰，猎头勿扰。我的简历"},{"title":"Archives","date":"2017-09-20T01:41:45.604Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"archives/index.html","permalink":"https://yangxiaoge.github.io/archives/index.html","excerpt":"","text":""},{"title":"Friends","date":"2017-09-20T01:41:45.608Z","updated":"2017-09-20T01:41:45.608Z","comments":true,"path":"friends/index.html","permalink":"https://yangxiaoge.github.io/friends/index.html","excerpt":"","text":""},{"title":"gallery","date":"2017-09-20T01:41:45.608Z","updated":"2017-09-20T01:41:45.608Z","comments":true,"path":"gallery/index.html","permalink":"https://yangxiaoge.github.io/gallery/index.html","excerpt":"","text":""},{"title":"","date":"2017-09-20T01:41:46.196Z","updated":"2017-09-20T01:41:46.196Z","comments":true,"path":"img/我的演说.html","permalink":"https://yangxiaoge.github.io/img/我的演说.html","excerpt":"","text":"我的演说 - @演说.io var link = document.createElement( 'link' ); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = window.location.search.match( /print-pdf/gi ) ? 'https://yanshuo.io/assets/player//css/print/pdf.css' : ''; document.getElementsByTagName( 'head' )[0].appendChild( link ); Hello，CPU@yangjiananGithub中国药科大学校园&nbsp;&nbsp;测试markdown here! private boolean isMM900() { // 41401, \"MM 900\", \"MM\", \"缅甸\" // 当前网络提供商必须是MPT并且手机卡也是MPT的! //if (DeviceInfo.getMCCMNC().equals(Constants.MPT_MCC_MNC) &amp;&amp; DeviceInfo.getIMSI().startsWith(Constants.MPT_MCC_MNC)) { if (true) { // 新的自动登录 4.1.9 Auto Login 接口； 注意：使用的协议为 HTTP， // Http Header 中放入登陆的上下文信息: MEID, terminal-type, } Making the world a better place.END.自豪的采用 @演说.io.at-block{ position:absolute } Reveal.initialize({ controls: true, history: true, center: false, transition: 'fade', backgroundTransition: 'default', transitionSpeed: 'default', // no marked.js // no markdown.js // no highlight.js dependencies: [ { src: 'https://yanshuo.io/assets/player/lib/js/classList.js', condition: function() { return !document.body.classList; } }, { src: 'https://yanshuo.io/assets/player/plugin/zoom-js/zoom.js', async: true }, { src: 'https://yanshuo.io/assets/player/plugin/notes/notes.js', async: true } ] });"},{"title":"Links","date":"2017-03-09T07:03:51.000Z","updated":"2017-09-20T01:41:46.260Z","comments":true,"path":"links/index.html","permalink":"https://yangxiaoge.github.io/links/index.html","excerpt":"","text":"开源项目收集 👆👆👆 每日必看 链接 简介 鸿洋 国内 Android 开发大牛 郭霖 国内 Android 开发大牛，鸿洋搅基 Gank 干货集中营 温故而知新 链接 简介 AndroidInterview-Q-A 顶尖的互联网公司 Android面试问题和答案 AndroidNote Android 基础,进阶,View,面试 java-design-patterns Java 设计模式详细 Demo Java 基础回顾 Java 基础回顾 自定义 View 自定义 View 教程目录 HenCoder View 抛物线的自定义 View 开发进阶 Hensen_ 的全栈式导航 从基础到进阶复习 那些年 Android 黑科技，DevNote - 香脆的大鸡排 Android 黑科技①②③ ，值得一看！ 紧跟时代 链接 简介 AndroidChromium 谷歌浏览器安卓版源码项目，世界级的安卓架构 Android Google ARCore 尝鲜记录 AR 尝鲜 - D_clock 爱吃葱花 360° 全景图片、全景视频工程 VR Android 三种姿势带你玩转 360 度全景图功能 VR，鸿洋公众号推荐 轻松入门 Android 直播相关技术 从 0 搭建直播系统 鸿洋大牛的直播入门教程，我已经试过，并记录了截图 深度学习工程师-网易云 吴恩达给你的人工智能第一课 教学类 链接 简介 学习正则的开源项目 帅比张「stormzhang」推荐 Kotlin Gitbook Kotlin gitbook Kotlin 系统入门与进阶 ¥ 99.00 慕课网教学 MIUI 系统工程师 Gityuan 基于Android 6.0的源码，专注于分享Android系统原理、架构分析的原创文章 廖雪峰Python教程 Python教程讲解的浅显易懂适合初学者 工具集 链接 简介 VIP 视频 你懂得 极客导航 程序员自己的导航 在线工具 常用的在线工具 菜鸟工具 编译以及前端工具 演说 随时随地的在线展示文稿 使用 Jenkins 实现持续集成 (Android) 持续集成 easy_mock_api NodeJS 编写的，给客户端（Android iOS）同学本地模拟 json 接口的小工具 easy-mock 在线 mock RxTools 支付，购物车控件，分享，圆图，二维码，压缩，webview，滑动验证，location，电影票选座，联系人，跑马灯，Toast，登录 等等 Android 工具集 囊括所有你能想到的utils，不用自己去写工具了。 快速开发工具类收集 银行卡管理，sp，appinfo，cache，phoneinfo，viewutils等 轻松一刻 小彤花园"},{"title":"开源项目收集","date":"2016-09-14T03:39:56.000Z","updated":"2017-09-20T01:41:46.260Z","comments":true,"path":"project_collection/index.html","permalink":"https://yangxiaoge.github.io/project_collection/index.html","excerpt":"如何掌握 Android - 21 个应用程序 AndroidTVLauncher 猫桌面 - 中国首位 00 后 CEO 公然抄袭、复制我的开源作品, 原作者的项目都很棒！坚决抵制这种炒作抄袭行为！ Android最新源码汇总 Arsenal Trinea wanandroid_鸿洋维护 极客导航 osplus QQ上拉弹出键盘 AndroidKeyboardListener 各种下拉效果SpringView(美图,QQ网页下拉等等) 等等…","text":"如何掌握 Android - 21 个应用程序 AndroidTVLauncher 猫桌面 - 中国首位 00 后 CEO 公然抄袭、复制我的开源作品, 原作者的项目都很棒！坚决抵制这种炒作抄袭行为！ Android最新源码汇总 Arsenal Trinea wanandroid_鸿洋维护 极客导航 osplus QQ上拉弹出键盘 AndroidKeyboardListener 各种下拉效果SpringView(美图,QQ网页下拉等等) 等等… 印象笔记(目前不对外公布) 收集中(鸿洋,郭霖微信博客都可以关注下)… 滴滴滴~~~来不及解释了! 快上车! 不错的博客和工具网站 仿QQ6.0侧滑效果 Android动态生成验证码VerificationCode View Android开发人员不得不收集的代码(持续更新中) 清晰灵活简单易用的应用更新库 多语言切换库 mpt项目使用中 calligraphy(高效加载字体库) mpt项目使用中 material-dialogs QuickDevLib TakePhoto StatusBarUtil状态栏工具类 微笑下拉刷新 各种布局下拉刷新效果 多Fragment嵌套库, 仿知乎等 仿照网易云音乐(2.9.0)界面的练习项目 手势引导 高仿QQ附近的人雷达扫描图 SwipeMenuListView 高仿WeChat 《Android开发艺术探索》书中源代码 鸿洋okhttp的封装类 app指向性功能高亮的库_鸿洋写的 Material Design Bottom 知乎 Android 客户端启动页动画效果实现 仿flyme悬浮球 wuchangfeng/one 后台用python抓数据存储在LeanCloud - 对应的后端 合理的进程保活 打不死的小强,永不crash的Android Fragmentation一个强大的Android Fragment管理库,apk下载 - 2017年2月20日09:54:56 Android 直播播放器+弹幕使用总结 - 2017年2月16日16:02:06 《云阅》一个仿网易云音乐UI，使用Gank.Io及豆瓣Api开发的开源项目 高仿微信6.3.31 android各种流程源码解析 AndroidStudio——Freeline的使用—郭霖公众号 Android路由框架 毕业设计——okHttp封装+php+xampp+retrofit封装+rx+mvc+文档的成品app RapidFloatingActionButton sealtalk-android：基于融云开发的 Android 版即时通讯（IM）应用程序 - 嗨豹 - 鸿洋微信推荐 DropDownMenu开源库 SmartRefreshLayout - Android 智能下拉刷新框架-SmartRefreshLayout easy_mock_api - 给客户端（Android iOS）同学的模拟json接口的小工具 用nodejs（express+react）搭建的极简的服务器，给定一个url就返回一个特定的Json数据，提供给客户端开发同学用的模拟Json服务器接口的项目，项目尽可能的简单，核心代码只有100多行，简单而实用，方便扩展。 Spotlight-支持引导路径高亮的方案。 Matisse - 知乎图片选择47.TelegramGallery - 抽取 Telegram 相册功能 仿全民TV 高仿全民直播（全民TV） 高仿iOS 滚轮实现 省市区 城市选择三级联动 史上最简单侧滑菜单52.GankMM – 干货营 - 包含 泡网，天气，常用工具，换肤等52.Android 录音功能直接拿去用 - code小生53.Android 实现 dialog 的 3D 翻转54.360° 全景图片、全景视频工程55.Android-SVProgressHUD 精仿 iOS 的提示库56.AndroidCustomView - 各种自定义 View 效果 2017-9-18 10:16:4557.SuperTextView - 2017-9-18 10:16:3958.AndroidAllDemos - 继承当下主流框架，实现快速开发 2017-9-18 10:23:0359.Amaze 文件管理器 - 文件管理器"},{"title":"Tags","date":"2017-09-20T01:41:46.260Z","updated":"2017-09-20T01:41:46.260Z","comments":true,"path":"tags/index.html","permalink":"https://yangxiaoge.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从 0 搭建直播系统","slug":"2017-09-12-从-0-搭建直播系统","date":"2017-09-12T07:45:18.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2017/09/12/2017-09-12-从-0-搭建直播系统/","link":"","permalink":"https://yangxiaoge.github.io/2017/09/12/2017-09-12-从-0-搭建直播系统/","excerpt":"","text":"一直想搞个直播的 Demo，今天正好看到鸿洋公众号：轻松入门 Android 直播相关技术 从 0 搭建直播系统，索性就把我自己的搭(折)建(腾)过程做一个记录。 搭建流程： 服务器系统：Ubuntu 16.10 系统推流，拉流系统：Win 7, Android 一个简易的直播系统，大致可以由三部分组成（详情见鸿洋博客）： 搭建一个 rtmp 媒体服务器：这里使用 srs 推流端：这里使用 obs 拉流端：这里使用播放器 vlc 使用第三方 SDK 推流这里以百度云的直播 SDK 为例，下载地址：https://cloud.baidu.com/doc/Downloadcenter/Push.html#.E7.89.88.E6.9C.AC.E6.9B.B4.E6.96.B0.E8.AF.B4.E6.98.8E 修改推流地址之后上传到了我的 PushFlowLive apk 下载 使用开源项目推流使用一个开源项目： https://github.com/begeekmyfriend/yasea apk 下载 利用 ffmpeg 推流 详情见鸿洋博客 大家可以自己下载 ffmepg 的源码，然后按照网上的方式去编成 so，简单的一点而且比较实用的，就是编出可以执行 ffmpeg 命令的 so，这样就能干很多事情了。 这里，由于篇幅，我们就直接使用别人编好的项目了。 https://github.com/WritingMinds/ffmpeg-android-java 搭建过程截图： 封面小黄人动图来自 giphy","categories":[],"tags":[{"name":"直播","slug":"直播","permalink":"https://yangxiaoge.github.io/tags/直播/"}]},{"title":"我眼中的 Android Framework","slug":"2017-09-05-我眼中的-Android-Framework","date":"2017-09-05T06:16:37.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2017/09/05/2017-09-05-我眼中的-Android-Framework/","link":"","permalink":"https://yangxiaoge.github.io/2017/09/05/2017-09-05-我眼中的-Android-Framework/","excerpt":"","text":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。— 前言 本文转自 墨镜猫，通俗有趣的文笔 任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。Android framework 包含三个小伙伴：服务端、客户端、linux 驱动。 服务端服务端主要包含两个狠重要的类：WindowManagerService（WMS）和 ActivityManagerService（AMS） 客户端客户端包含以下类： ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是 UI 线程或者称为主线程。 Activity：ActivityThread 会根据用户的操作选择让哪个 Activity 对象上它的船。 PhoneWindow：富二代，继承于牛气的 Window 类，自己屋里住着一个 DecorView 对象，像它老爸喜欢制定规则提供了一些通用窗口操作 API。 Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作 API。它不喜欢被人管所以呢，注意：WindowManagerService 管理的窗口不是 Window 类，其实是 View 和 ViewGroup。 DecorView：很能干的家伙，家产来自 FrameLayout，比较注重外在喜欢打扮，DecorView 是对 FrameLayout 进行了一些修饰，从名字就可以看出来。 ViewRoot：小管家继承于 Handler，主要作用是把 WMS 的 IPC 调用转换为本地的一个异步调用。 W 类：ViewRoot 小助手，继承于 binder，是 ViewRoot 内部类。主要帮助 ViewRoot 实现把 WMS 的 IPC 调用转换为本地的一个异步调用。 WindowManager：客户端如果想创建一个窗口得先告诉 WindowManager 一声，然后它再和 WindowManagerService 交流一下看看能不能创建，客户端不能直接和 WMS 交互。 Linux 驱动Linux 驱动和 Framework 相关的主要是两个部分：画家 SurfaceFlingger 和快递员 Binder。 每一个窗口都对应一个画 Surface，SF 主要是把各个 Surface 显示到同一屏幕上。Binder 是提供跨进程的消息传递。 从 apk 程序的运行过程去看看上面各个组件在啥时候干啥活的ActivityThread 从 main() 函数中就开始动起来，然后调用 prepareMainLooper() 为 UI 线程创建一个消息快递通道即 MessageQueue。 接着创建 ActivityThread 对象，创建过程会创建一个消息装卸工 Handler 对象和一个快递员 Binder 对象，其中 Binder 负责接收远程 Ams 的 IPC 调用，接收到调用后让 Handler 把消息装到消息快递队列，UI 线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。 然后 UI 线程让队列调用 Looper.loop() 方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。 当 ActivityThread 接收到 Ams 发送 start 某个 Activity 的快递后就会创建指定的 Activity 对象。Activity 会先按窗户再去按玻璃和贴窗花，所以先创建 PhoneWindow-&gt;DecorView-&gt; 创建相应的 View 或 ViewGroup。创建完成后就可以让大家欣赏了，调用 WindowManager 把界面显示到屏幕上，然后创建 ViewRoot，然后调用 Wms 提供的远程接口添加一个窗口并显示到屏幕上。 接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用 Wms 中的相应函数处理该消息。 很多线程是不是很晕？ 安卓程序中都有哪些线程？ 客户端小伙伴至少包含三个线程小弟，Activity 启动后会创建一个 ViewRoot.W 对象，同时 ActivityThread 会创建一个 ApplicationThread 对象，这两个对象继承消息总管 Binder，每个 Binder 对应一个线程，负责接收 Linux Binder 驱动发送的 IPC 调用。还有一个是 UI 线程呗。 UI 线程是什么？ 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。 自定义的线程和 UI 线程有什么区别？ UI 线程是从 ActivityThread 运行的，在该类的 main() 方法中已经使用了 Looper.prepareMainLooper() 为该线程添加了 Looper 对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在 Activity 中去定义 Handler 对象，因为创建 Handler 对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的 Thread 则没有默认创建消息队列，所以不能直接在 Thread 中直接定义 Handler，这个就是我们不懂程序运行原理导致的困惑。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Framework","slug":"Framework","permalink":"https://yangxiaoge.github.io/tags/Framework/"}]},{"title":"如何选择开源许可证？","slug":"2017-08-29-如何选择开源许可证？","date":"2017-08-29T06:36:51.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2017/08/29/2017-08-29-如何选择开源许可证？/","link":"","permalink":"https://yangxiaoge.github.io/2017/08/29/2017-08-29-如何选择开源许可证？/","excerpt":"","text":"作为一名开发人员，应当秉承开源精神，遵守开源协议，这是必备的道德修养和素质。 本文转自 阮一峰 大大 如何为代码选择开源许可证，这是一个问题。世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—– GPL、BSD、MIT、Mozilla、Apache 和 LGPL—-之中做选择，也很复杂。乌克兰程序员 Paul Bagwell ，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。下面是我制作的中文版，请看大图。 有兴趣详细了解开源协议的可以看这篇文章：程序员不可不知的版权协议","categories":[],"tags":[{"name":"闲谈","slug":"闲谈","permalink":"https://yangxiaoge.github.io/tags/闲谈/"}]},{"title":"Binder源码分析","slug":"Binder源码分析","date":"2017-07-06T02:00:05.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2017/07/06/Binder源码分析/","link":"","permalink":"https://yangxiaoge.github.io/2017/07/06/Binder源码分析/","excerpt":"","text":"forked from xdtianyu/SourceAnalysis 本文是基于 Android 6.0.0 和 kernel 3.4 源码 及 Android SDK 23 展开的。 目录 1. 简介 2. Binder 与 AIDL 2.1 AIDL 客户端 2.2 AIDL 服务端 2.3 远程服务的获取与使用 3. Binder 框架及 Native 层 3.1 Binder Native 的入口 3.2 Binder 本地层的整个函数/方法调用过程 3.3 Binder 设备文件的打开和读写 4. Binder 驱动 4.1 binder 设备的创建 4.2 binder 协议和数据结构 4.3 binder 驱动文件操作 5. Binder 与系统服务 5.1 Context.getSystemService() 5.2 Context.getSystemService() 源码分析 6. 结论 7. 参考 1. 简介Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 Context.getSystemService() 来获取系统服务，或直接使用 AIDL 来实现多个程序(APP)间数据交互。 Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。 不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。 我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。 2. Binder 与 AIDLAIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图 Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。 Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。 接下来再看具体实现， 完整源代码见 AidlExample。在这个工程中，我们新建了两个应用， app 是客户端代码， remoteservice 则是服务端代码。 2.1 AIDL 客户端在 Android Studio 项目上右键， New -&gt; AIDL -&gt; AIDL File 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 IRemoteService.aidl 文件 12345678// IRemoteService.aidlpackage com.android.aidltest;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 从生成的示例代码可以看出，AIDL 的语法类似 Java， basicTypes() 方法传递的参数只是基本类型。 如果要传递自定义类型如 User，则需要实现 Parcelable 接口。Parcelable 是一个与 Java Serializable 类似的序列化接口。 这样类 User 的实例就可以储存到 Parcel 中，而 Parcel 则是一个可以通过 IBinder 发送数据或对象引用的容器。 1234567891011121314151617181920212223242526272829303132// User.javapublic class User implements Parcelable &#123; private int uid; private String name; // 从 Parcel 中读取数据，顺序需要和写入保持一致 protected User(Parcel in) &#123; uid = in.readInt(); name = in.readString(); &#125; // 必须实现，用于从 Parcel 对象中生成类实例 public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; // 将数据写入到 Parcel 中， 顺序需要与读取保持一致 @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(uid); dest.writeString(name); &#125;&#125; 再向 IRemoteService.aidl 中添加一个 addUser() 方法，同时新建一个 User.aidl 文件。 1234567891011121314151617// IRemoteService.aidlpackage com.android.aidltest;import com.android.aidltest.User;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); // in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法 void addUser(in User user);&#125;// User.aidlpackage com.android.aidltest;parcelable User; 运行编译后，会在 generated 文件夹中生成一个 IRemoteService.java 接口文件。这个接口中有两个内部类 Stub 和 Stub.Proxy。注意客户端生成的IRemoteService.java 文件和在后文服务端生成的文件内容是相同的。 客户端会从 Stub.asInterface() 得到 IRemoteService (Stub.Proxy) 的实例，这个实例就是一个通过 Binder 传递回来的 远程对象 的包装。而服务端则需要实现 IRemoteService.addUser() 方法。 1234567891011// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof org.xdty.remoteservice.IRemoteService))) &#123; return ((org.xdty.remoteservice.IRemoteService) iin); &#125; return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125; 2.2 AIDL 服务端为了演示进程间通信，我们新建一个模块（应用） RemoteService 来实现功能，并在客户端绑定服务。 按客户端的结构新建 IRemoteService.aidl User.aidl User.java 文件，并拷贝内容，注意如果需要请修改包名。 新建服务 RemoteService ，覆盖(Override) onBind() 方法并返回 IRemoteService.Stub 实例 mBinder： 123456789101112131415161718192021// RemoteService.javapublic class RemoteService extends Service &#123; private static final String TAG = RemoteService.class.getSimpleName(); private IBinder mBinder = new IRemoteService.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; Log.d(TAG, \"basicTypes: \"); &#125; @Override public void addUser(User user) throws RemoteException &#123; Log.d(TAG, \"addUser: \" + user.name); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 这样服务端就实现了 addUser() 方法，当客户端通过远程对象调用 IRemoteService.Stub.Proxy.addUser() 时，远程对象 mRemote 就会通过 transact() 发送命令给服务端，服务端收到命令后在 Stub.onTransact() 中读取数据并执行 addUser() 方法。更多细节我们将在 3. Binder 框架及 Native 层 小节讲述。 123456789101112131415161718192021// IRemoteService.java@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 2.3 远程服务的获取与使用客户端要使用远程服务，需要绑定服务 (bindService) 并建立服务连接 (ServiceConnection)。 123456789101112131415161718192021222324// MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IRemoteService remoteService = IRemoteService.Stub.asInterface(service); try &#123; remoteService.addUser(new User(1, \"neo\")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; ... &#125;; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; ... Intent intent = new Intent().setComponent(new ComponentName( \"org.xdty.remoteservice\", \"org.xdty.remoteservice.RemoteService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125;&#125; 我们可以看出，客户端通过 binderService() 方法，获取远程服务并在服务连接 ServiceConnection 中 onServiceConnected() 回调中得到了 IBinder service 实例， 最后通过上文提到的 IRemoteService.Stub.asInterface(service) 方法得到远程服务 IRemoteService 的实例。通过 IRemoteService.addUser() 方法我们可以像调用本地方法一样调用远程方法。在来看 IRemoteService.addUser() 的实现： 123456789101112131415161718192021222324252627282930313233343536373839// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; ... return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125;private static class Proxy implements org.xdty.remoteservice.IRemoteService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; ... @Override public void addUser(org.xdty.remoteservice.User user) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((user != null)) &#123; _data.writeInt(1); user.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; 可以看到客户端调用 remoteService.addUser(new User(1, “neo”)) 方法实际上是通过 IBinder service 实例的 transact() 方法，发送了与服务端约定好的命令 Stub.TRANSACTION_addUser，并将参数按格式打包进 Parcel 对象。 服务端则在 onTransact() 方法中收到命令后会对命令和参数重新解析： 1234567891011121314151617181920// IRemoteService.javapublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 可以看到在 onTransact() 中，最终 this.addUser(_arg0) 调用了上文提到的服务端的实现 IRemoteService.Stub.addUser() 。 远程 Binder 对象 mRemote 是由客户端绑定服务时 onServiceConnected() 返回的。继续追踪 bindService() 1234567// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125; 可以看到最后是通过 ActivityManagerNative.getDefault().bindService() 来绑定服务 12345678910111213141516// bindServiceCommon()int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier());// ActivityManagerNative.getDefault().bindService()public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; ... data.writeStrongBinder(connection.asBinder()); ... mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); ...&#125; 追踪到 ActivityManagerNative.getDefault().bindService() ，可以发现 ActivityManager 和 IServiceConnection也是一个 AIDL 实现。通过它的 ActivityManagerProxy.bindService() 将绑定请求发送给本地层。 再从 onServiceConnected() 回调追踪， onServiceConnected() 是由 LoadedApk.ServiceDispatcher.doConnected() 回调的。 关于更多的 bindService() 远程服务创建及 ServiceConnection 回调， 请参考 Android应用程序绑定服务（bindService）的过程源代码分析 利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 CallerInfo Plugin 的实现 从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。 3. Binder 框架及 Native 层Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。 Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 4. Binder 驱动 小节详细讲述。 JNI 的代码位于 frameworks/base/core/jni 目录下，主要是 android_util_Binder.cpp 文件和头文件 android_util_Binder.h Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 libandroid_runtime.so 系统库。 Binder 本地层的代码在 frameworks/native/libs/binder 目录下， 此目录在 Android 系统编译后会生成 libbinder.so 文件，供 JNI 调用。libbinder 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 frameworks/native/include/binder 目录下。 3.1 Binder Native 的入口IInterface.cpp 是 Binder 本地层入口，与 java 层的 android.os.IInterface 对应，提供 asBinder() 的实现，返回 IBinder 对象。 在头文件中有两个类 BnInterface (Binder Native Interface) 和 BpInterface (Binder Proxy Interface), 对应于 java 层的 Stub 和 Proxy 12345sp&lt;IBinder&gt; IInterface::asBinder(const IInterface* iface)&#123; if (iface == NULL) return NULL; return const_cast&lt;IInterface*&gt;(iface)-&gt;onAsBinder();&#125; 12345678910111213141516171819202122template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;;// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; 其中 BnInterface 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。BpInterface 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。 3.2 Binder 本地层的整个函数/方法调用过程 1. Java 层 IRemoteService.Stub.Proxy 调用 android.os.IBinder (实现在 android.os.Binder.BinderProxy) 的 transact() 发送 Stub.TRANSACTION_addUser 命令。 2. 由 BinderProxy.transact() 进入 native 层。 3. 由 jni 转到 android_os_BinderProxy_transact() 函数。 4. 调用 IBinder-&gt;transact 函数。 1234567static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); status_t err = target-&gt;transact(code, *data, reply, flags);&#125; 而 gBinderProxyOffsets.mObject 则是在 java 层调用 IBinder.getContextObject() 时在 javaObjectForIBinder 函数中设置的 123456789101112131415static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125;jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... LOGDEATH(\"objectForBinder %p: created new proxy %p !\\n\", val.get(), object); // The proxy holds a reference to the native object. env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get()); val-&gt;incStrong((void*)javaObjectForIBinder); ...&#125; 经过 ProcessState::getContextObject() 和 ProcessState::getStrongProxyForHandle() 1234567891011121314sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; ... b = new BpBinder(handle); result = b; ... return result;&#125; 可见 android_os_BinderProxy_transact() 函数实际上调用的是 BpBinder::transact() 函数。 5. BpBinder::transact() 则又调用了 IPCThreadState::self()-&gt;transact() 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; if (err == NO_ERROR) &#123; LOG_ONEWAY(\"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s\", getpid(), getuid(), (flags &amp; TF_ONE_WAY) == 0 ? \"READ REPLY\" : \"ONE WAY\"); err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125;status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; ... mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 由函数内容可以看出， 数据再一次通过 writeTransactionData() 传递给 mOut 进行写入操作。 mOut 是一个 Parcel 对象， 声明在 IPCThreadState.h 文件中。之后则调用 waitForResponse() 函数。 6. IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; &#125; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125; ...&#125; 7. IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现。ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 就是使用系统调用函数 ioctl 向 binder 设备文件 /dev/binder 发送 BINDER_WRITE_READ 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don't want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // Return immediately if there is nothing to do. if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; #if defined(HAVE_ANDROID_OS) // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno;#else err = INVALID_OPERATION;#endif do &#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; err = -EBADF; &#125; &#125; while (err == -EINTR); if (err &gt;= NO_ERROR) &#123; if (bwr.write_consumed &gt; 0) &#123; if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; return NO_ERROR; &#125; return err;&#125; 经过 IPCThreadState::talkWithDriver() ,就将数据发送给了 Binder 驱动。 继续追踪 IPCThreadState::waitForResponse() ，可以从 第6步 发现 IPCThreadState 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 executeCommand(cmd) 函数。 8. IPCThreadState::executeCommand() 处理 Binder 驱动返回命令 123456789101112131415161718192021222324252627282930313233343536status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION: &#123; binder_transaction_data tr; result = mIn.read(&amp;tr, sizeof(tr)); ... Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); ... Parcel reply; status_t error; if (tr.target.ptr) &#123; sp&lt;BBinder&gt; b((BBinder*)tr.cookie); error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; ... &#125; break; ...&#125; 9. 可以看出其调用了 BBinder::transact() 函数，将数据返回给上层。 123456789101112131415161718192021status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); status_t err = NO_ERROR; switch (code) &#123; case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: err = onTransact(code, data, reply, flags); break; &#125; if (reply != NULL) &#123; reply-&gt;setDataPosition(0); &#125; return err;&#125; 10. 而这里的 b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags) 中的 b (BBinder) 是 JavaBBinder 的实例，所以会调用 JavaBBinder::onTransact() 函数 12345678910111213141516// frameworks/base/core/jni/android_util_Binder.cppvirtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) &#123; JNIEnv* env = javavm_to_jnienv(mVM); ... jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); &#125; static int int_register_android_os_Binder(JNIEnv* env)&#123; ... gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, \"execTransact\", \"(IJJI)Z\"); ...&#125; 11. 可见 JNI 通过 gBinderOffsets.mExecTransact 最后执行了 android.os.Binder 的 execTransact() 方法。 execTransact() 方法是 jni 回调的入口。 1234567891011// Entry point from android_util_Binder.cpp's onTransact private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); ... try &#123; res = onTransact(code, data, reply, flags); &#125; ... &#125; 12. 而我们则在服务端 IRemoteService.Stub 重载了 onTransact() 方法，所以数据最后会回到我们的服务端并执行服务端实现的 addUser() 方法。 12345678910111213141516171819202122232425262728293031public static abstract class Stub extends android.os.Binder implements org.xdty.remoteservice.IRemoteService &#123; ... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_basicTypes: &#123; ... return true; &#125; case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125; 上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 BC_TRANSACTION 到 Binder 驱动，服务端进程监听返回的 BR_TRANSACTION 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 BC_REPLY 命令， 客户端监听 BR_REPLY 命令。 3.3 Binder 设备文件的打开和读写1. 设备的打开 在上一小节中我们看到 JNI 过程中调用了 ProcessState::getContextObject() 函数， 在 ProcessState 初始化时会打开 binder 设备 1234567// ProcessState.cppProcessState::ProcessState() : mDriverFD(open_driver()) ...&#123; ...&#125; open_driver() 函数内容如下 1234567891011121314151617181920212223242526272829303132// ProcessState.cppstatic int open_driver()&#123; // 打开设备文件 int fd = open(\"/dev/binder\", O_RDWR); if (fd &gt;= 0) &#123; fcntl(fd, F_SETFD, FD_CLOEXEC); int vers = 0; // 获取驱动版本 status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) &#123; ALOGE(\"Binder ioctl to obtain version failed: %s\", strerror(errno)); close(fd); fd = -1; &#125; // 检查驱动版本是否一致 if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ALOGE(\"Binder driver protocol does not match user space protocol!\"); close(fd); fd = -1; &#125; // 设置最多 15 个 binder 线程 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); &#125; &#125; else &#123; ALOGW(\"Opening '/dev/binder' failed: %s\\n\", strerror(errno)); &#125; return fd;&#125; 2. 设备的读写 打开设备文件后，文件描述符被保存在 mDriverFD， 通过系统调用 ioctl 函数操作 mDriverFD 就可以实现和 binder 驱动的交互。 对 Binder 设备文件的所有读写及关闭操作则都在 IPCThreadState 中，如上一小节提及到的 IPCThreadState::talkWithDriver 函数 talkWithDriver() 函数封装了 BINDER_WRITE_READ 命令，会从 binder 驱动读取或写入封装在 binder_write_read 结构体中的本地或远程对象。 12345678910111213141516171819202122232425// IPCThreadState.cppstatus_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; // 写入数据 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // 读取数据 if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; ... // 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; ...&#125; 可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。 4. Binder 驱动关于 binder 驱动建议参考另一篇文章 深入分析Android Binder 驱动 原文，本小节仍需要完善。 Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。 Binder 驱动的代码位于 kernel 代码的 drivers/staging/android 目录下。主文件是 binder.h 和 binder.c 进程间传输的数据被称为 Binder 对象，它是一个 flat_binder_object，结构如下 1234567891011121314struct flat_binder_object &#123; /* 8 bytes for large_flat_header. */ unsigned long type; unsigned long flags; /* 8 bytes of data. */ union &#123; void *binder; /* local object */ signed long handle; /* remote object */ &#125;; /* extra data associated with local object */ void *cookie;&#125;; 其中 类型 type 描述了 Binder 对象的类型，包含 BINDER(本地对象)、HANDLE(远程对象)、 FD 三大类(五种) 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; flags 则表述了传输方式，如异步、无返回等 123456enum transaction_flags &#123; TF_ONE_WAY = 0x01, /* this is a one-way call: async, no return */ TF_ROOT_OBJECT = 0x04, /* contents are the component's root object */ TF_STATUS_CODE = 0x08, /* contents are a 32-bit status code */ TF_ACCEPT_FDS = 0x10, /* allow replies with file descriptors */&#125;; 而 flat_binder_object 中的 union 联合体 就是要传输的数据，当类型为 BINDER 时， 数据就是一个本地对象 *binder，而类型为 HANDLE 时，数据则是一个远程对象 handle。 当 flat_binder_object 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 binder_transaction 的实现。 该如何理解本地 BINDER 对象和远程 HANDLE 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 RemoteService 有个对象 mBinder，对于 RemoteService 来说，mBinder 就是一个本地的 BINDER 对象；如果进程 app 通过 Binder 驱动访问 RemoteService 的 mBinder 对象，对于 app 来说， mBinder 就是一个 HANDLE。因此，从根本上来说 handle 和 binder 都指向 RemoteService 的 mBinder。本地对象还可以带有额外的数据，保存在 cookie 中。 Binder 驱动直接操作的最外层数据结构是 binder_transaction_data， Binder 对象 flat_binder_object 被封装在 binder_transaction_data 结构体中。 binder_transaction_data 数据结构才是真正传输的数据，其定义如下 1234567891011121314151617181920212223242526272829303132struct binder_transaction_data &#123; /* The first two are only used for bcTRANSACTION and brTRANSACTION, * identifying the target and contents of the transaction. */ union &#123; size_t handle; /* target descriptor of command transaction */ void *ptr; /* target descriptor of return transaction */ &#125; target; void *cookie; /* target object cookie */ unsigned int code; /* transaction command */ /* General information about the transaction. */ unsigned int flags; pid_t sender_pid; uid_t sender_euid; size_t data_size; /* number of bytes of data */ size_t offsets_size; /* number of bytes of offsets */ /* If this transaction is inline, the data immediately * follows here; otherwise, it ends with a pointer to * the data buffer. */ union &#123; struct &#123; /* transaction data */ const void *buffer; /* offsets from buffer to flat_binder_object structs */ const void *offsets; &#125; ptr; uint8_t buf[8]; &#125; data;&#125;; flat_binder_object 就被封装在 *buffer中，其中的 unsigned int code; 则是传输命令，描述了 Binder 对象执行的操作。 4.1 binder 设备的创建device_initcall() 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。 12345678910111213141516171819202122232425262728static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, // 设备文件 /dev/binder .name = \"binder\", // 设备文件操作 .fops = &amp;binder_fops&#125;;static int __init binder_init(void)&#123; int ret; ... // 注册字符设备 ret = misc_register(&amp;binder_miscdev); ... // 调试文件， 在 /sys/kernel/debug/binder 目录下 if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(\"state\", S_IRUGO, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); ... &#125; return ret;&#125;device_initcall(binder_init); 可以看出 binder_init() 使用 misc_register() 函数创建了 binder 设备。从 misc_register(&amp;binder_miscdev); 及 .name = “binder” 可以看出， binder 向 kernel 注册了一个 /dev/binder 的字符设备，而文件操作都在 binder_fops 结构体中定义。 123456789static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 从上面 binder_fops 结构体可以看出，主要的操作是 binder_ioctl() binder_mmap() binder_open() 等函数实现的。 4.2 binder 协议和数据结构binder.h 文件中定义了 binder 协议和重要的数据结构。 首先在 enum 中定义了 binder 处理的类型，引用或是句柄 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; 下面这段宏定义则是在 ioctl 函数调用时可用的具体命令。 1234567#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT _IOW('b', 3, int64_t)#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)#define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, int)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)#define BINDER_THREAD_EXIT _IOW('b', 8, int)#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 在 BinderDriverReturnProtocol 和 BinderDriverCommandProtocol 中 则分别定义了 客户端调用 和 服务端 返回的命令。 4.3 binder 驱动文件操作上文已经提到，所有的操作定义在 binder_fops 结构体中，下面讲述这些操作。 设备的打开 - binder_open() 函数 用户空间在打开 /dev/binder 设备时，驱动会出发 binder_open() 函数的响应。 123456789101112131415161718192021222324252627282930313233static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // 分配 binder_proc 数据结构内存 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; // 增加当前线程/进程的引用计数并赋值给tsk get_task_struct(current); proc-&gt;tsk = current; // 初始化队列 INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); binder_lock(__func__); // 增加BINDER_STAT_PROC的对象计数 binder_stats_created(BINDER_STAT_PROC); // 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); // 保存进程 id proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); // 驱动文件 private_data 指向 proc filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; 驱动文件释放 - binder_release() 函数 在用户空间关闭驱动设备文件时，会调用 binder_release() 函数，清理 binder_proc 对象，释放占用的内存。 123456789101112131415161718192021static int binder_release(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc = filp-&gt;private_data; binder_defer_work(proc, BINDER_DEFERRED_RELEASE); return 0;&#125;static voidbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)&#123; mutex_lock(&amp;binder_deferred_lock); proc-&gt;deferred_work |= defer; if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123; // 添加到释放队列中 hlist_add_head(&amp;proc-&gt;deferred_work_node, &amp;binder_deferred_list); queue_work(binder_deferred_workqueue, &amp;binder_deferred_work); &#125; mutex_unlock(&amp;binder_deferred_lock);&#125; 内存映射 - binder_mmap() 函数 binder_mmap() 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; // 获得 binder_proc 对象 struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; // 最多只分配 4M 的内存 if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; // 检查 flags if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE; mutex_lock(&amp;binder_mmap_lock); // 检查是否已经映射 if (proc-&gt;buffer) &#123; ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; &#125; // 申请内核虚拟内存空间 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; // 将申请到的内存地址保存到 binder_proc 对象中 proc-&gt;buffer = area-&gt;addr; proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); // 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针 proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (proc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; // 分配一个页的物理内存 if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123; ret = -ENOMEM; failure_string = \"alloc small buf\"; goto err_alloc_small_buf_failed; &#125; // 内存提供给 binder_buffer buffer = proc-&gt;buffer; // 初始化 proc-&gt;buffers 链表 INIT_LIST_HEAD(&amp;proc-&gt;buffers); // 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中 list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); buffer-&gt;free = 1; binder_insert_free_buffer(proc, buffer); proc-&gt;free_async_space = proc-&gt;buffer_size / 2; barrier(); proc-&gt;files = get_files_struct(proc-&gt;tsk); proc-&gt;vma = vma; proc-&gt;vma_vm_mm = vma-&gt;vm_mm; return 0;&#125; 驱动命令接口 - binder_ioctl() 函数 用户态程序调用 ioctl 系统函数向 /dev/binder 设备发送数据时，会触发 binder_ioctl() 函数响应。 上文数据结构中已经提到了 binder_ioctl 可以处理的 命令 12345678910// 核心命令，数据的读写#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)// 设置最大线程数#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)// 设置 context manager#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)// 线程退出命令#define BINDER_THREAD_EXIT _IOW('b', 8, int)// binder 驱动的版本#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 检查是否有错误 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; binder_lock(__func__); // 获取 binder_thread 对象 thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto err; &#125; // 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; if (bwr.write_size &gt; 0) &#123; // 执行写入操作 ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); if (ret &lt; 0) &#123; bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; if (bwr.read_size &gt; 0) &#123; // 执行读取操作 ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); if (!list_empty(&amp;proc-&gt;todo)) wake_up_interruptible(&amp;proc-&gt;wait); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; // 操作完成后将数据返回给用户空间 if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; break; &#125; case BINDER_SET_MAX_THREADS: // 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123; ret = -EINVAL; goto err; &#125; break; case BINDER_SET_CONTEXT_MGR: // 检查是否已经设置 if (binder_context_mgr_node != NULL) &#123; ret = -EBUSY; goto err; &#125; // 设置 context manager ret = security_binder_set_context_mgr(proc-&gt;tsk); if (ret &lt; 0) goto err; if (binder_context_mgr_uid != -1) &#123; if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123; ret = -EPERM; goto err; &#125; &#125; else binder_context_mgr_uid = current-&gt;cred-&gt;euid; // 创建 binder_context_mgr_node 节点 binder_context_mgr_node = binder_new_node(proc, NULL, NULL); if (binder_context_mgr_node == NULL) &#123; ret = -ENOMEM; goto err; &#125; // 初始化节点数据 binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; break; case BINDER_THREAD_EXIT: // 线程退出，释放资源 binder_free_thread(proc, thread); thread = NULL; break; case BINDER_VERSION: // 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中 if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) &#123; ret = -EINVAL; goto err; &#125; break; default: ret = -EINVAL; goto err; &#125; ret = 0;...&#125; 123456789101112131415161718192021222324252627282930313233343536373839static struct binder_node *binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie)&#123; struct rb_node **p = &amp;proc-&gt;nodes.rb_node; struct rb_node *parent = NULL; struct binder_node *node; // 查找要插入节点的父节点 while (*p) &#123; parent = *p; node = rb_entry(parent, struct binder_node, rb_node); if (ptr &lt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_left; else if (ptr &gt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_right; else return NULL; &#125; // 为要插入节点分配内存空间 node = kzalloc(sizeof(*node), GFP_KERNEL); if (node == NULL) return NULL; binder_stats_created(BINDER_STAT_NODE); // 插入节点 rb_link_node(&amp;node-&gt;rb_node, parent, p); rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); // 初始化 node-&gt;debug_id = ++binder_last_id; node-&gt;proc = proc; node-&gt;ptr = ptr; node-&gt;cookie = cookie; node-&gt;work.type = BINDER_WORK_NODE; INIT_LIST_HEAD(&amp;node-&gt;work.entry); INIT_LIST_HEAD(&amp;node-&gt;async_todo); return node;&#125; BINDER_WRITE_READ 处理过程 在 binder 本地层中，我们看到在 IPCThreadState::talkWithDriver() 函数中， binder 本地层通过 ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 命令的形式，与 binder 驱动交互。 可以看出 ioctl() 的第三个参数是一个 binder_write_read 结构体 binder.h 头文件中定义了两个数据类型, 一个是 binder_write_read 12345678struct binder_write_read &#123; signed long write_size; /* bytes to write */ signed long write_consumed; /* bytes consumed by driver */ unsigned long write_buffer; signed long read_size; /* bytes to read */ signed long read_consumed; /* bytes consumed by driver */ unsigned long read_buffer;&#125;; 其中 write_size 和 read_size 表示需要被读写的字节数， write_consumed 和 read_consumed 表示已经被 binder 驱动读写的字节数， write_buffer 和 read_buffer 则是指向被读写数据的指针。 具体的读写操作被 binder_thread_write 和 binder_thread_read 实现。 数据写入 - binder_thread_write() 函数 将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; // 用户空间数据，起始地址和结束地址 void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 循环读取 while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间获取操作命令 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123; // 增加命令计数器 binder_stats.bc[_IOC_NR(cmd)]++; proc-&gt;stats.bc[_IOC_NR(cmd)]++; thread-&gt;stats.bc[_IOC_NR(cmd)]++; &#125; switch (cmd) &#123; // 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref case BC_INCREFS: case BC_ACQUIRE: case BC_RELEASE: case BC_DECREFS: &#123; uint32_t target; struct binder_ref *ref; const char *debug_string; // 获取目标进程节点描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 索描述为 0 表示 context manager 进程 if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp; (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123; // 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用 ref = binder_get_ref_for_node(proc, binder_context_mgr_node); &#125; else // 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用 ref = binder_get_ref(proc, target); switch (cmd) &#123; case BC_INCREFS: debug_string = \"IncRefs\"; // 增加弱引用计数 binder_inc_ref(ref, 0, NULL); break; case BC_ACQUIRE: debug_string = \"Acquire\"; // 增加强引用计数 binder_inc_ref(ref, 1, NULL); break; case BC_RELEASE: debug_string = \"Release\"; // 减少强引用计数 binder_dec_ref(ref, 1); break; case BC_DECREFS: default: debug_string = \"DecRefs\"; // 减少弱引用计数 binder_dec_ref(ref, 0); break; &#125; break; &#125; case BC_INCREFS_DONE: case BC_ACQUIRE_DONE: &#123; void __user *node_ptr; void *cookie; struct binder_node *node; // 从用户空间读取 node_ptr if (get_user(node_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 从用户空间读取 cookie if (get_user(cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获得节点 node = binder_get_node(proc, node_ptr); // 没有找到则返回 if (node == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"%s u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr); break; &#125; // cookie 不匹配则返回 if (cookie != node-&gt;cookie) &#123; binder_user_error(\"binder: %d:%d %s u%p node %d\" \" cookie mismatch %p != %p\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr, node-&gt;debug_id, cookie, node-&gt;cookie); break; &#125; if (cmd == BC_ACQUIRE_DONE) &#123; node-&gt;pending_strong_ref = 0; &#125; else &#123; node-&gt;pending_weak_ref = 0; &#125; // 减少节点使用计数 binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0); break; &#125; // 释放 binder_bffer case BC_FREE_BUFFER: &#123; void __user *data_ptr; struct binder_buffer *buffer; // 从用户空间获取 data_ptr if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 查找 binder_buffer buffer = binder_buffer_lookup(proc, data_ptr); // 没有找到则返回 if (buffer == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 不允许用户释放则返回 if (!buffer-&gt;allow_user_free) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p matched \" \"unreturned buffer\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 将 buffer-&gt;transaction 置空 if (buffer-&gt;transaction) &#123; buffer-&gt;transaction-&gt;buffer = NULL; buffer-&gt;transaction = NULL; &#125; if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123; if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo)) buffer-&gt;target_node-&gt;has_async_transaction = 0; else list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo); &#125; // 释放 binder_buffer 对象 trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, buffer, NULL); binder_free_buf(proc, buffer); break; &#125; // binder 数据传递处理 case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; // 从用户空间拷贝 binder_transaction_data 对象 if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); // 实际的传输函数，在下文讲解 binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; // 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态 case BC_REGISTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"after BC_ENTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else if (proc-&gt;requested_threads == 0) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"without request\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else &#123; proc-&gt;requested_threads--; proc-&gt;requested_threads_started++; &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态 case BC_ENTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_ENTER_LOOPER called after \" \"BC_REGISTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态 case BC_EXIT_LOOPER: thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED; break; // 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知 case BC_REQUEST_DEATH_NOTIFICATION: case BC_CLEAR_DEATH_NOTIFICATION: &#123; uint32_t target; void __user *cookie; struct binder_ref *ref; struct binder_ref_death *death; // 从用户空间获取 binder_ref 描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获取 binder_ref 引用 ref = binder_get_ref(proc, target); if (ref == NULL) &#123; binder_user_error(\"binder: %d:%d %s \" \"invalid ref %d\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_REQUEST_DEATH_NOTIFICATION ? \"BC_REQUEST_DEATH_NOTIFICATION\" : \"BC_CLEAR_DEATH_NOTIFICATION\", target); break; &#125; if (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123; if (ref-&gt;death) &#123; binder_user_error(\"binder: %d:%\" \"d BC_REQUEST_DEATH_NOTI\" \"FICATION death notific\" \"ation already set\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; // 为 binder_ref_death 对象分配内存空间 death = kzalloc(sizeof(*death), GFP_KERNEL); if (death == NULL) &#123; thread-&gt;return_error = BR_ERROR; break; &#125; // 初始化 binder_ref_death 对象 binder_stats_created(BINDER_STAT_DEATH); INIT_LIST_HEAD(&amp;death-&gt;work.entry); death-&gt;cookie = cookie; ref-&gt;death = death; if (ref-&gt;node-&gt;proc == NULL) &#123; ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; else &#123; if (ref-&gt;death == NULL) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion not active\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; death = ref-&gt;death; if (death-&gt;cookie != cookie) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion cookie mismatch \" \"%p != %p\\n\", proc-&gt;pid, thread-&gt;pid, death-&gt;cookie, cookie); break; &#125; // 将 ref-&gt;death 置空 ref-&gt;death = NULL; if (list_empty(&amp;death-&gt;work.entry)) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; else &#123; BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER); death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR; &#125; &#125; &#125; break; case BC_DEAD_BINDER_DONE: &#123; struct binder_work *w; void __user *cookie; struct binder_ref_death *death = NULL; // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123; struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work); if (tmp_death-&gt;cookie == cookie) &#123; death = tmp_death; break; &#125; &#125; if (death == NULL) &#123; binder_user_error(\"binder: %d:%d BC_DEAD\" \"_BINDER_DONE %p not found\\n\", proc-&gt;pid, thread-&gt;pid, cookie); break; &#125; list_del_init(&amp;death-&gt;work.entry); // 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION if (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; break; default: return -EINVAL; &#125; *consumed = ptr - buffer; &#125; return 0;&#125; binder_transaction() 函数 在上文处理 BC_TRANSACTION 和 BC_REPLY 时，调用了 binder_transaction() 函数。我们继续追踪 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; if (reply) &#123; // BC_REPLY 处理流程 // 得到 binder_transaction 对象 in_reply_to = thread-&gt;transaction_stack; if (in_reply_to == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_empty_call_stack; &#125; binder_set_nice(in_reply_to-&gt;saved_priority); thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 获取目标线程 target_thread = in_reply_to-&gt;from; target_proc = target_thread-&gt;proc; &#125; else &#123; // BC_TRANSACTION 处理流程 // 查找目标节点 if (tr-&gt;target.handle) &#123; struct binder_ref *ref; // 获取 binder_ref 对象 ref = binder_get_ref(proc, tr-&gt;target.handle); target_node = ref-&gt;node; &#125; else &#123; // 索引为 0 则返回 context manager target_node = binder_context_mgr_node; &#125; // 得到目标进程 target_proc = target_node-&gt;proc; if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123; struct binder_transaction *tmp; tmp = thread-&gt;transaction_stack; while (tmp) &#123; if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc) // 获得目标线程 target_thread = tmp-&gt;from; tmp = tmp-&gt;from_parent; &#125; &#125; &#125; // 设置要处理的目标进程或目标线程任务 if (target_thread) &#123; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; // 为 binder_transaction 对象分配内存空间 t = kzalloc(sizeof(*t), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION); tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); // 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 设置 binder_transaction 对象 t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; t-&gt;to_proc = target_proc; t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; t-&gt;flags = tr-&gt;flags; t-&gt;priority = task_nice(current); // 为 binder_buffer 分配内存空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); // 设置 binder_buffer t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; t-&gt;buffer-&gt;transaction = t; t-&gt;buffer-&gt;target_node = target_node; if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 从用户空间拷贝数据到 binder_buffer if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; off_end = (void *)offp + tr-&gt;offsets_size; for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; // 为 flat_binder_object 赋值 fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); // 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; // 获取 binder_node 节点 struct binder_node *node = binder_get_node(proc, fp-&gt;binder); if (node == NULL) &#123; node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); if (node == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_binder_new_node_failed; &#125; node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK; node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS); &#125; if (fp-&gt;cookie != node-&gt;cookie) &#123; goto err_binder_get_ref_for_node_failed; &#125; // 获取 binder_ref 对象 ref = binder_get_ref_for_node(target_proc, node); // 转换类型 if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;handle = ref-&gt;desc; binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); &#125; break; case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; // 获取 binder_ref 对象 struct binder_ref*ref = binder_get_ref(proc, fp-&gt;handle); // 转换类型 if (ref-&gt;node-&gt;proc == target_proc) &#123; if (fp-&gt;type == BINDER_TYPE_HANDLE) fp-&gt;type = BINDER_TYPE_BINDER; else fp-&gt;type = BINDER_TYPE_WEAK_BINDER; fp-&gt;binder = ref-&gt;node-&gt;ptr; fp-&gt;cookie = ref-&gt;node-&gt;cookie; binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, NULL); &#125; else &#123; struct binder_ref *new_ref; new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); &#125; &#125; break; // 文件类型 case BINDER_TYPE_FD: &#123; int target_fd; struct file *file; // 获得文件对象 file = fget(fp-&gt;handle); // 分配一个新的文件描述符 target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC); task_fd_install(target_proc, target_fd, file); fp-&gt;handle = target_fd; &#125; break; default: return_error = BR_FAILED_REPLY; goto err_bad_object_type; &#125; &#125; if (reply) &#123; // BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象 binder_pop_transaction(target_thread, in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; // 同步状态(双向)需要设置回复 t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; thread-&gt;transaction_stack = t; &#125; else &#123; // 异步传输不需要设置回复 if (target_node-&gt;has_async_transaction) &#123; target_list = &amp;target_node-&gt;async_todo; target_wait = NULL; &#125; else target_node-&gt;has_async_transaction = 1; &#125; t-&gt;work.type = BINDER_WORK_TRANSACTION; list_add_tail(&amp;t-&gt;work.entry, target_list); tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); if (target_wait) // 唤醒目标线程 wake_up_interruptible(target_wait); return;&#125; 数据读取 - binder_thread_read() 函数 用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; if (*consumed == 0) &#123; // 第一次操作时向用户空间返回 BR_NOOP 命令 if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: // 获取将要处理的任务 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); if (wait_for_proc_work) &#123; if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; binder_user_error(\"binder: %d:%d ERROR: Thread waiting \" \"for process work before calling BC_REGISTER_\" \"LOOPER or BC_ENTER_LOOPER (state %x)\\n\", proc-&gt;pid, thread-&gt;pid, thread-&gt;looper); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); &#125; binder_set_nice(proc-&gt;default_priority); if (non_block) &#123; // 非阻塞且没有数据则返回 EAGAIN if (!binder_has_proc_work(proc, thread)) ret = -EAGAIN; &#125; else // 阻塞则进入睡眠状态，等待可操作的任务 ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); &#125; else &#123; if (non_block) &#123; if (!binder_has_thread_work(thread)) ret = -EAGAIN; &#125; else ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread)); &#125; binder_lock(__func__); if (wait_for_proc_work) proc-&gt;ready_threads--; thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; if (ret) return ret; while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 获取 binder_work 对象 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry); else &#123; if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; &#125; if (end - ptr &lt; sizeof(tr) + 4) break; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; // 获取 binder_transaction 对象 t = container_of(w, struct binder_transaction, work); &#125; break; case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // 返回 BR_TRANSACTION_COMPLETE 命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); binder_stat_br(proc, thread, cmd); // 从 work 链表中删除并释放内存 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; case BINDER_WORK_NODE: &#123; // 获得 binder_node 节点 struct binder_node *node = container_of(w, struct binder_node, work); uint32_t cmd = BR_NOOP; const char *cmd_name; // 根据节点类型，增加/获取、减少/释放节点索引 int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs; int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong; // 构造 BR_* 命令 if (weak &amp;&amp; !node-&gt;has_weak_ref) &#123; cmd = BR_INCREFS; cmd_name = \"BR_INCREFS\"; node-&gt;has_weak_ref = 1; node-&gt;pending_weak_ref = 1; node-&gt;local_weak_refs++; &#125; else if (strong &amp;&amp; !node-&gt;has_strong_ref) &#123; cmd = BR_ACQUIRE; cmd_name = \"BR_ACQUIRE\"; node-&gt;has_strong_ref = 1; node-&gt;pending_strong_ref = 1; node-&gt;local_strong_refs++; &#125; else if (!strong &amp;&amp; node-&gt;has_strong_ref) &#123; cmd = BR_RELEASE; cmd_name = \"BR_RELEASE\"; node-&gt;has_strong_ref = 0; &#125; else if (!weak &amp;&amp; node-&gt;has_weak_ref) &#123; cmd = BR_DECREFS; cmd_name = \"BR_DECREFS\"; node-&gt;has_weak_ref = 0; &#125; // 向用户空间返回命令 if (cmd != BR_NOOP) &#123; if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (put_user(node-&gt;ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); if (put_user(node-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); &#125; else &#123; list_del_init(&amp;w-&gt;entry); if (!weak &amp;&amp; !strong) &#123; rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); kfree(node); binder_stats_deleted(BINDER_STAT_NODE); &#125; &#125; &#125; break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; struct binder_ref_death *death; uint32_t cmd; // 获取 binder_ref_death 对象 death = container_of(w, struct binder_ref_death, work); // 构造返回命令 if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE; else cmd = BR_DEAD_BINDER; // 向用户空间返回命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 将 cookie 返回给用户空间 if (put_user(death-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123; list_del(&amp;w-&gt;entry); kfree(death); binder_stats_deleted(BINDER_STAT_DEATH); &#125; else list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death); if (cmd == BR_DEAD_BINDER) goto done; /* DEAD_BINDER notifications can cause transactions */ &#125; break; &#125; if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; // 获得 binder_node 节点 struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // 将数据封装到 binder_transaction_data 对象 tr.target.ptr = target_node-&gt;ptr; tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); // 设置返回的命令类型 cmd = BR_TRANSACTION; &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; &#125; tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; tr.sender_pid = 0; &#125; tr.data_size = t-&gt;buffer-&gt;data_size; tr.offsets_size = t-&gt;buffer-&gt;offsets_size; tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 拷贝 binder_transaction_data 对象到用户空间 if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_stat_br(proc, thread, cmd); // 移除 binder_transaction 并释放空间 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; &#125; else &#123; t-&gt;buffer-&gt;transaction = NULL; kfree(t); binder_stats_deleted(BINDER_STAT_TRANSACTION); &#125; break; &#125;&#125; 从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。 5. Binder 与系统服务5.1 Context.getSystemService()Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 服务) 主要有 WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager 我们可以通过 Context.getSystemService(String name) 来获取 服务)。 例如 可以通过如下方法从 xml 中插入新的视图 LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE); inflater.inflate(R.layout.view, root, true); 5.2 Context.getSystemService() 源码分析追踪 ContextImpl getSystemService() 源代码 1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 继续追踪 SystemServiceRegistry 源代码 1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 追踪 SYSTEM_SERVICE_FETCHERS 可以发现在 SystemServiceRegistry 静态区中注册了几乎所有的系统服务 1234567891011121314registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;);registerService(Context.LOCATION_SERVICE, LocationManager.class, new CachedServiceFetcher&lt;LocationManager&gt;() &#123; @Override public LocationManager createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE); return new LocationManager(ctx, ILocationManager.Stub.asInterface(b)); &#125;&#125;); 上面代码片断中，PhoneLayoutInflater 最终回到了 LayoutInflater。而 LocationManager 则是对 ILocationManager 的封装。可以发现，在 frameworks/base/location/java/android/location 包下含有大量的 AIDL 文件。 继续追踪 ServiceManager.getService(Context.LOCATION_SERVICE) 1234567891011121314151617181920212223242526272829private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125;/** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist */public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; 从上面代码片断可以看出，ServiceManager 会从 sCache 缓存或 IServiceManager 中查找服务并返回一个 IBinder 对象。这个 IBinder 就是一个远程对象，可以通过它与其他进程交互。 继续深入 getIServiceManager().getService(name) , 进入 ServiceManagerNative 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125;class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; &#125; private IBinder mRemote;&#125; 从上边代码片断可以看到，ServiceManager.getIServiceManager() 返回的是一个 ServiceManagerProxy, 而 ServiceManager.getService() 则是在 ServiceManagerProxy 中通过 ServiceManager 的远程 Binder 对象 mRemote，操作 Parcel 数据，调用 IBinder.transact(int code, Parcel data, Parcel reply, int flags) 方法来发送请求，并通过 reply.readStrongBinder() 返回了要查找的服务的远程对象。 可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。 6. 结论1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。 2. 上层的 android.os.Binder 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。 3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 transact 和 onTransact 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。 7. 参考Android Binder机制 Android进程间通信（IPC）机制Binder Android Binder Android Architecture Binder AIDL与Binder框架浅谈 Binder框架解析 Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013 Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video) Binder源码分析之驱动层（原） 深入分析Android Binder 驱动 构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解 Service与Android系统设计（7）— Binder驱动 Android Binder Binder机制，从Java到C （7. Native Service） 待补充的内容 1. 客户端 bindService() 流程及源码分析 2. Binder Native 层其他源码文件分析 3. 系统服务（SystemService）详细列表及在本地层的源码分析 4. SystemManager 源码分析 5. 完善 binder 驱动内容，补充关系图","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"https://yangxiaoge.github.io/tags/Binder/"}]},{"title":"Android O上手体验","slug":"Android-O上手体验","date":"2017-05-19T05:34:15.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2017/05/19/Android-O上手体验/","link":"","permalink":"https://yangxiaoge.github.io/2017/05/19/Android-O上手体验/","excerpt":"","text":"2017 Google IO 开发者大会, 于北京时间 5 月 18 日凌晨 1 点举办了，具体的内容请看 stormzhang （帅比张去了加州现场还开了个直播，终于看到了一个会动的帅比张，哈哈）。有几个重要的事件：Google AI，Android O，Kotlin，等等本文重点是 Android O 的上手视频，迫不及待的把测试机 Nexus 5X 刷成了 Android 0，Android O 系统映像文件下载，官网介绍特性：Android O 新特性介绍。 上手视频：","categories":[{"name":"Android O","slug":"Android-O","permalink":"https://yangxiaoge.github.io/categories/Android-O/"}],"tags":[{"name":"Android O","slug":"Android-O","permalink":"https://yangxiaoge.github.io/tags/Android-O/"}]},{"title":"Android输入法加密研究","slug":"Android输入法加密研究","date":"2017-05-09T01:51:03.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2017/05/09/Android输入法加密研究/","link":"","permalink":"https://yangxiaoge.github.io/2017/05/09/Android输入法加密研究/","excerpt":"","text":"近期接到一个微信，QQ 聊天时加密文字的需求。我当时的心情是这样的： 开源项目入手冷静下来，细细思考，要不开发一个输入法？我这是要挑战搜狗输入法一个团队吗，不现实呀！然后就找到了 Goolge 开源的 PinyinIME（Android 4.4.4）。毕竟输入法将输入的文字设置到编辑框要走 BaseInputConnection 中 commitText 方法，那么我就想在这个地方动手脚呗。嗯，说干就干，我就撸了一下 PinyinIME 项目中的代码，实现效果如下：(加密后的文字后面我加了一个 “中” 字) 哎呦，看着也还凑活哈。嗯，然后打开搜狗，百度输入法一看，用户就不乐意了，你家输入法真挫！一怒之下不用了。虽然这是个笑话，但是开发输入法代价太大了，毕竟要大量时间，人力。 源码分析入手所以啊，我想要不从系统层入手？（查了下 Api） frameworks/base/... 下有个类 InputMethodManager (输入法管理器，管理各部分的交互。它是一个客户端API，存在于各个应用程序的 context 中，用来沟通管理所有进程间交互的全局系统服务。) 中有个方法 showSoftInput (View view, int flags, ResultReceiver resultReceiver)。 注意到一个 view 参数，此参数就是输入框（微信，QQ，等输入框，webview除外）的 View，既然有了 view，那么我就可以 getText，setText 等等操作。我将 view 中的内容 Toast 出来效果如下： InputMethodService，每个输入法 App 应用都是继承自它！那么就可以对它的生命周期下手了。输入法显示的时候开启一个自定义的服务（有悬浮窗的），输入法关闭的时候结束服务并且释放相应的静态变量。重点就在于生命周期的研究！ 目的是，将 InputMethodManager 中的 编辑框 View 对象存起来，然后在 InputMethodService 中启动的服务 暂且叫做 MyFloatEncryService 中获取这个 View，之后就直接可以 get，set 加密了。 实现方案在开发中，后续补充~~~","categories":[{"name":"输入法","slug":"输入法","permalink":"https://yangxiaoge.github.io/categories/输入法/"}],"tags":[{"name":"输入法","slug":"输入法","permalink":"https://yangxiaoge.github.io/tags/输入法/"}]},{"title":"Android源码编译","slug":"Android源码编译","date":"2017-05-04T03:40:24.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2017/05/04/Android源码编译/","link":"","permalink":"https://yangxiaoge.github.io/2017/05/04/Android源码编译/","excerpt":"","text":"进入项目根目录 （begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/） source build/envsetup.sh lunch (我的项目中选了 79) make -j8（第一次编译耗时 2 小时，机器性能好的可以 j32 等等） Android 编译命令 make -j8 -k 2&gt;&amp;1 | tee build.log 解释: 其中 make 是编译命令，-j8 这里的 8 指的是线程数量，就是开启几个线程去编译这个工程，一般会是 CPU 核心数的 2 倍, 开多的话电脑会卡死。-k 2 是标准错误，&amp;1 是标准输出，2&gt;&amp;1 意思就是将标准错误输出到标准输出中。如果没有 2&gt;&amp;1，只会有标准输出，没有错误；tee 的作用同时输出到控制台和文件，make &gt; build.log 是将所有标准输出到这个文件中，并没有定义标准错误应该是定义到了标准输出，也就是说如果 make 执行出现错误，那么就不会写到 build.log 中，而是输出到屏幕上，2&gt;&amp;1 是错误和结果都重定向到 build.log 中！可以到根目录看到 build.log。 模块编译，节约时间(比方说我修改了 frameworks/base 下的某个文件直接编译这个模块就行) mmm frameworks/base （单独编译某个模块） make snod （重新打包 Android 系统镜像文件 system.img， 这个不要忘！） 编译源码等指令可以看老罗的 Android 系统源代码情景分析教程 刷机 刷机工具下载 安装下载的工具 打开 SP_Flash_Tool_exe_Windows_v5.1644.00.000\\flash_tool.exe 刷机开始 MTK 刷机（KONKAS6 代码）使用 Smart Phone Flash Tool 工具： 注意 KONKA 手机关机即可，首先选中 Scatter-loading File 这行的 choose ，然后右击计算机选择映射网络驱动器输入 \\\\192.168.20.220\\share（这个是 ubuntu 共享的文件夹），然后进入对于源码目录找到 KONKAS6\\alps\\out\\target\\product\\kon6753_66c_s6_m0\\MT6753_Android_scatter.txt 原生 AOSP 用 Nexus 刷机（AOSP-6.0.1_r17 代码）：注意手机关机进入 fastboot 界面，进入编译生成的目录下 begoit@BegoitPC:~/begoit/AOSP-6.0.1_r17/out/target/product/bullhead$，然后依次刷入如下命令： sudo fastboot flash system system.img sudo fastboot flash recovery recovery.img sudo fastboot flash vendor vendor.img sudo fastboot flash cache cache.img sudo fastboot flash userdata userdata.img sudo fastboot reboot 最后一步，重启手机。 刷机录像：注意，gif 最后点击 download 之后再用 usb 连接关机的 KONKA 手机 Attention： /home/begoit/temp/KONKAS6/alps/packages/apps/Provision/src/com/android/provision/DefaultActivity.java (注释 onCreate 中的部分代码，略去登录注册等功能) 打 Patch 包（将 A 项目的提交打 Patch 导入到 B 项目中） 2017-9-18 18:14:57 add git format-patch -1（-1 指最近一次 Git 提交） - A 项目根目录，生成 Patch 包 将生成的 0001-.patch 拷贝到 B 项目根目录下 git am 0001-.patch - B 项目根目录打入 Patch 包 源码代码提示的命令 2017-6-13 15:46:06 add运行 source build/envsetup.shmmm development/tools/idegen/sh ./development/tools/idegen/idegen.sh （三行全选运行），会在项目的更目录下会生成 android.ipr，用 andorid studio 打开这个文件，源码代码就有提示了! 内置 apk 2017-6-27 11:08:49 add KONKAS6/alps/device/konka/kon6753_66c_s6_m0/begoit 路径下将需要的 apk(TopActivity.apk) 安装包放进来 在上述路径下 Android.mk 文件中将 apk 信息加进来（这个模仿其他的内置apk） KONKAS6/alps/device/konka/kon6753_66c_s6_m0/full_kon6753_66c_s6_m0.mk 文件中增加 TopActivity \\ 如果 apk 中有 so 库那么需要加别的东西，目前没有用到，可自行 google 以上操作完成之后需要重新编译项目 加快编译速度 2017-6-30 17:46:53 addprebuilts/misc/linux-x86/ccache/ccache -M 50G 设置 cache 缓存为 50 G 如下是编译的录屏, 临时弄个 枪火 先占坑，视频抽空录制（视频太大暂不录制）。以下是哔哩哔哩的 html5 播放视频，参考文章：http://login926.github.io/2016/12/24/Bilibilihtml5Player/ 未完待续。。。","categories":[{"name":"Android源码","slug":"Android源码","permalink":"https://yangxiaoge.github.io/categories/Android源码/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://yangxiaoge.github.io/tags/源码/"}]},{"title":"《Android开发艺术探索》读书笔记 (1)","slug":"Android开发艺术notes1","date":"2017-03-03T05:14:14.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2017/03/03/Android开发艺术notes1/","link":"","permalink":"https://yangxiaoge.github.io/2017/03/03/Android开发艺术notes1/","excerpt":"重拾课本, 温故Android开发艺术探索! 本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。书中源码地址 Github 第1章 Activity的生命周期和启动模式1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析 通常, Activity从invisible(即onStop)到visible(即onStart)时, onRestart方法就会被调用。 点击home键或者打开新Activity时, onPause -&gt; onStop, 如果按Home键回来回掉是: onRestart -&gt; onStart -&gt; onResume ; 如果新Activity主题是透明的时, 只有onPause, 所以当用户返回原来的Activity时, 回掉过程是: onRestart -&gt; onStart -&gt; onResume (看Activity生命周期图就知道了)。","text":"重拾课本, 温故Android开发艺术探索! 本文是Android开发艺术读书笔记系列第一篇。内容结合书本/网络，自己概括而来。书中源码地址 Github 第1章 Activity的生命周期和启动模式1.1 Activity生命周期全面分析1.1.1 典型情况下生命周期分析 通常, Activity从invisible(即onStop)到visible(即onStart)时, onRestart方法就会被调用。 点击home键或者打开新Activity时, onPause -&gt; onStop, 如果按Home键回来回掉是: onRestart -&gt; onStart -&gt; onResume ; 如果新Activity主题是透明的时, 只有onPause, 所以当用户返回原来的Activity时, 回掉过程是: onRestart -&gt; onStart -&gt; onResume (看Activity生命周期图就知道了)。 分析生命周期图, 可知onStart和onStop对应(可见到不可见性), onPause和onResume对应(是否位于前台)。 1.1.2 异常生命周期分析 如果应用长时间处于stopped状态并且此时系统内存极为紧张的时候，系统就会回收Activity，此时系统在回收之前会回调onSaveInstanceState方法来保存应用的数据Bundle。当该Activity重新创建的时候，保存的Bundle数据就会传递到onRestoreSaveInstanceState方法和onCreate方法中，这就是onCreate方法中Bundle savedInstanceState参数的来源（onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原）。详情可以参考Android群英传_第八章 Activity和Activity调用栈分析 配置android:configChanges=”xxx”属性, 防止Activity随着orientation,local,keyboardHidden发生变化时重新创建。 1.2 Activity的启动模式应用内的Activity是被任务栈Task来管理的，一个Task中的Activity可以来自不同的应用，同一个应用的Activity也可能不在同一个Task中。默认情况下，任务栈依据栈的后进先出原则管理Activity，但是Activity可以设置一些“特权”打破默认的规则，主要是通过在AndroidManifest文件中的属性android:launchMode或者通过Intent的flag来设置。 standard：默认的启动模式，该模式下会生成一个新的Activity，同时将该Activity实例压入到栈中（不管该Activity是否已经存在在Task栈中，都是采用new操作）。例如： 栈中顺序是A B C D ，此时D通过Intent跳转到A，那么栈中结构就变成 A B C D A，点击返回按钮的 显示顺序是 D C B A，依次摧毁。 singleTop：在singleTop模式下，如果当前Activity D位于栈顶，此时通过Intent跳转到它本身的Activity（即D），那么不会重新创建一个新的D实例（走onNewIntent()），所以栈中的结构依旧为A B C D，如果跳转到B，那么由于B不处于栈顶，所以会新建一个B实例并压入到栈中，结构就变成了A B C D B。应用实例：三条推送，点进去都是一个activity。 singleTask：在singleTask模式下，Task栈中只能有一个对应Activity的实例。例如：现在栈的结构为A B C D，此时D通过Intent跳转到B（走onNewIntent()），则栈的结构变成了：A B。其中的C和D被栈弹出销毁了，也就是说位于B之上的实例都被销毁了。如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法。通常应用于首页，首页肯定得在栈底部，也只能在栈底部。 singleInstance：singleInstance模式下会将打开的Activity压入一个新建的任务栈中。例如：Task栈1中结构为：A B C，C通过Intent跳转到了D（D的启动模式为singleInstance），那么则会新建一个Task 栈2，栈1中结构依旧为A B C，栈2中结构为D，此时屏幕中显示D，之后D通过Intent跳转到D，栈2中不会压入新的D，所以2个栈中的情况没发生改变。如果D跳转到了C，那么就会根据C对应的启动模式在栈1中进行对应的操作，C如果为standard，那么D跳转到C，栈1的结构为A B C C，此时点击返回按钮，还是在C，栈1的结构变为A B C，而不会回到D。 1.3 Intent Flag启动模式 Intent.FLAG_ACTIVITY_NEW_TASK：使用一个新的task来启动Activity，一般用在service中启动Activity的场景，因为service中并不存在Activity栈。 Intent.FLAG_ACTIVITY_SINGLE_TOP：类似andoid:launchMode=&quot;singleTop&quot; Intent.FLAG_ACTIVITY_CLEAR_TOP：类似andoid:launchMode=&quot;singleTask&quot; Intent.FLAG_ACTIVITY_NO_HISTORY：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在task栈中。例如A B，在B中以这种模式启动C，C再启动D，则当前的task栈变成A B D。","categories":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://yangxiaoge.github.io/categories/Android开发艺术探索/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://yangxiaoge.github.io/tags/Android开发艺术探索/"}]},{"title":"深入浅出 OkHttp 源码","slug":"OkHttp源码分析","date":"2017-03-02T07:29:20.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2017/03/02/OkHttp源码分析/","link":"","permalink":"https://yangxiaoge.github.io/2017/03/02/OkHttp源码分析/","excerpt":"本文转载 JayFang-OkHttp源码分析 OkHttp3是Square出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的，还有著名的Retrofit也是基于OkHttp封装的。 OkHttp的基本使用","text":"本文转载 JayFang-OkHttp源码分析 OkHttp3是Square出品的高质量Http网络请求库，目前在GitHub上的star数超过17000。很多Android项目的网络组件都是基于OkHttp封装的，还有著名的Retrofit也是基于OkHttp封装的。 OkHttp的基本使用 123456789101112131415161718OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(ENDPOINT) .build();//同步请求 Response response = client.newCall(request).execute();//异步请求client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125;); 最基本的用法就是先创建一个OkHttpClient，然后build出一个Requset对象，最后发送请求，可以是同步请求，也可以是异步请求。使用起来很简单，但背后是怎么实现的，下面从源码层面来分析下。 OkHttp 调用流程OkHttp内部调用流程图 第一步: new OkHttpClient(Builder)12345678910111213141516//OkHttpClient.javapublic OkHttpClient() &#123; this(new Builder());&#125;OkHttpClient(Builder builder) &#123; this.dispatcher = builder.dispatcher; this.proxy = builder.proxy; this.protocols = builder.protocols; this.connectionSpecs = builder.connectionSpecs; this.interceptors = Util.immutableList(builder.interceptors); this.networkInterceptors = Util.immutableList(builder.networkInterceptors); ...... this.readTimeout = builder.readTimeout; this.writeTimeout = builder.writeTimeout; this.pingInterval = builder.pingInterval;&#125; 这里创建了一个默认的OkHttpCient.Builder，用于配置各种参数。 第二步:okhttpclient.newCall(request)123456789101112//OkHttpClient.java@Override public Call newCall(Request request) &#123;return new RealCall(this, request, false /* for web socket */);&#125;//RealCall.javaRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);&#125; 这里用request对象创建了一个RealCall对象，把一些参数传到RealCall。 第三步:execute() or enqueue()123456789101112131415161718//RealCall.java@Override public Response execute() throws IOException &#123;synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true;&#125;captureCallStackTrace();try &#123; client.dispatcher().executed(this); //核心的函数 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result;&#125; finally &#123; client.dispatcher().finished(this);&#125;&#125; 同步请求，很直接就调用到了最核心的函数getResponseWithInterceptorChain()。再看下异步请求。12345678910//RealCall.java @Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 而异步请求，将用户接口的responseCallback对象封装成一个AsyncCall对象提交给Dispather来处理，这里的AsyncCall是RealCall的一个内部类。再看下这个Dispather怎么处理这个AsyncCall的。123456789//Dispatcher.javasynchronized void enqueue(AsyncCall call) &#123;if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call);&#125; else &#123; readyAsyncCalls.add(call);&#125;&#125; Dispather管理了一些请求队列，如果正在执行的异步请求没有达到上限，就直接将这个请求提交给线程池，否则加入到等待队列中。而且这里直接把AsyncCall的对象给了线程池，其实这个AsyncCall就是一个Runnable的实现类。123456789101112131415161718192021222324252627282930313233//RealCall.javafinal class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super(\"OkHttp %s\", redactedUrl()); this.responseCallback = responseCallback; &#125; ...... @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125; AsyncCall父类的run()方法会调用抽象方法execute()，也就是将在Dispather里的线程池执行AsyncCall对象的时候，就会执行到execute()，在这个方法里同样调用了核心的网络请求方法getResponseWithInterceptorChain()。而且在execute()里会回调用户接口responseCallback的回调方法。注意:这里的回调是在非主线程直接回调的，也就是在Android里使用的话要注意这里面不能直接更新UI操作。至此，同步请求和异步请求最终都是调用的getResponseWithInterceptorChain();来发送网络请求，只是异步请求涉及到一些线程池操作，包括请求的队列管理、调度。 第四步:getResponseWithInterceptorChain()123456789101112131415161718//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException &#123;// Build a full stack of interceptors.List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();interceptors.addAll(client.interceptors());interceptors.add(retryAndFollowUpInterceptor);interceptors.add(new BridgeInterceptor(client.cookieJar()));interceptors.add(new CacheInterceptor(client.internalCache()));interceptors.add(new ConnectInterceptor(client));if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors());&#125;interceptors.add(new CallServerInterceptor(forWebSocket));Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest);return chain.proceed(originalRequest);&#125; 在这个方法里就是添加了一些拦截器，然后启动一个拦截器调用链，拦截器递归调用之后最后返回请求的响应Response。这里的拦截器分层的思想就是借鉴的网络里的分层模型的思想。请求从最上面一层到最下一层，响应从最下一层到最上一层，每一层只负责自己的任务，对请求或响应做自己负责的那块的修改。 Q1: 这里为什么每次都重新创建RealInterceptorChain对象，为什么不直接复用上一层的RealInterceptorChain对象？(文末给出答案) OkHttp拦截器分层结构12345678910111213//RealInterceptorChain.javapublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, Connection connection) throws IOException &#123;if (index &gt;= interceptors.size()) throw new AssertionError();calls++;......RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request);Interceptor interceptor = interceptors.get(index);Response response = interceptor.intercept(next);...return response;&#125; RealInterceptorChain的proceed()，每次重新创建一个RealInterceptorChain对象，然后调用下一层的拦截器的interceptor.intercept()方法。每一个拦截器的intercept()方法都是这样的模型123456789101112@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); // 1、该拦截器在Request阶段负责的事情 // 2、调用RealInterceptorChain.proceed()，其实是递归调用下一层拦截器的intercept方法 response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); //3、该拦截器在Response阶段负责的事情，然后返回到上一层拦截器的 response阶段 return response; &#125; &#125; 这差不多就是OkHttp的分层拦截器模型，借鉴了网络里的OSI七层模型的思想。最底层是CallServerInterceptor，类比网络里的物理层。OkHttp还支持用户自定义拦截器，插入到最顶层和CallServerInterceptor上一层的位置。比如官方写了一个Logging Interceptor，用于打印网络请求日志的拦截器。 BridgeInterceptor12345678910111213141516171819202122232425262728293031323334Request userRequest = chain.request();Request.Builder requestBuilder = userRequest.newBuilder();// Request阶段RequestBody body = userRequest.body();if (body != null) &#123; MediaType contentType = body.contentType(); ...... long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125;&#125; .....Response networkResponse = chain.proceed(requestBuilder.build());// Response阶段 .....if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));&#125; BridgeInterceptor拦截器在Request阶段，将用户的配置信息，重新创建Request.Builder对象，重新build出Request对象，并添加一些请求头，比如:host，content-length，keep-alive等。BridgeInterceptor在Response阶段做gzip解压操作。 CacheInterceptorCacheInterceptor拦截器在Request阶段判断该请求是否有缓存，是否需要重新请求，如果不需要重新请求，直接从缓存里取出内容，封装一个Response返回，不需要再调用下一层。CacheInterceptor拦截器在Response阶段，就是把下面一层的Response做缓存。 ConnectInterceptor123456789//ConnectInterceptor.javaRealInterceptorChain realChain = (RealInterceptorChain) chain;Request request = realChain.request();StreamAllocation streamAllocation = realChain.streamAllocation();// We need the network to satisfy this request. Possibly for validating a conditional GET.boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);RealConnection connection = streamAllocation.connection();return realChain.proceed(request, streamAllocation, httpCodec, connection); ConnectInterceptor拦截器只在Request阶段建立连接，Response阶段直接把下一层的Response返回给上一层。再看下建立连接的过程。1234567891011public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;....try &#123; RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); HttpCodec resultCodec = resultConnection.newCodec(client, this);......&#125; catch (IOException e) &#123; throw new RouteException(e);&#125;&#125; findHealthyConnection()函数寻找一条健康的网络连接，其内部主要调用了findConnection()。12345678910111213141516171819202122232425262728293031323334353637383940414243private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123;Route selectedRoute;synchronized (connectionPool) &#123; ..... // Attempt to get a connection from the pool. Internal.instance.get(connectionPool, address, this); if (connection != null) &#123; return connection; &#125; selectedRoute = route;&#125;// If we need a route, make one. This is a blocking operation.if (selectedRoute == null) &#123; selectedRoute = routeSelector.next();&#125;// Create a connection and assign it to this allocation immediately. This makes it possible for// an asynchronous cancel() to interrupt the handshake we're about to do.RealConnection result;synchronized (connectionPool) &#123; route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result); if (canceled) throw new IOException(\"Canceled\");&#125;// Do TCP + TLS handshakes. This is a blocking operation.result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);routeDatabase().connected(result.route());Socket socket = null;synchronized (connectionPool) &#123; // Pool the connection. Internal.instance.put(connectionPool, result); .....&#125;closeQuietly(socket);return result;&#125; 这里面大概就是从连接池里去找已有的网络连接，如果有，则复用，减少三次握手；没有的话，则创建一个RealConnection对象，三次握手，建立连接，然后将连接放到连接池。具体的内部connect过程，就不深入了。12345public ConnectionPool() &#123;this(5, 5, TimeUnit.MINUTES);&#125;public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) &#123;&#125; ConnectionPool最多支持保持5个地址的连接keep-alive，每个keep-alive 5分钟，并有异步线程循环清理无效的连接。 CallServerInterceptor1234567891011121314151617181920212223242526272829@Override public Response intercept(Chain chain) throws IOException &#123;...httpCodec.writeRequestHeaders(request);Response.Builder responseBuilder = null;if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; ...... if (responseBuilder == null) &#123; Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125;&#125;httpCodec.finishRequest();if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false);&#125;Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build();int code = response.code();.....return response;&#125; CallServerInterceptor 精简出来的代码就是writeRequestHeaders()，flushRequest()，finishRequest()，发送请求，然后readResponseHeaders，openResponseBody读取response。CallServerInterceptor底层的IO流读写依赖于Square自家的Okio项目，HttpCodec是封装的IO编码和解码的实现。 至此，OkHttp中几个核心的拦截器就到此为止了，OkHttp最精髓的部分也就体现在这个拦截器上。最后补充几个关于OkHttp的面试问题。 OkHttp是如何做链路复用？ OkHttp的Intereptor能不能取消一个request？这两个问题在分析源码之后应该很容易回答了。 回答上面留的一个问题:每次重新创建一个RealInterceptorChain对象，因为这里是递归调用，在调用下一层拦截器的interupter()方法的时候，本层的 response阶段还没有执行完成，如果复用RealInterceptorChain对象，必然导致下一层修改RealInterceptorChain，所以需要重新创建RealInterceptorChain对象。","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"OkHttp","slug":"OkHttp","permalink":"https://yangxiaoge.github.io/tags/OkHttp/"}]},{"title":"Java与Android知识点","slug":"Java与Android知识点","date":"2017-02-28T01:13:42.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2017/02/28/Java与Android知识点/","link":"","permalink":"https://yangxiaoge.github.io/2017/02/28/Java与Android知识点/","excerpt":"持续更行中 1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。String str = new String(“hello”);上面的语句中 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。 2. 重写equals方法时,为什么也需要重写hashCode方法。","text":"持续更行中 1. 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。String str = new String(“hello”);上面的语句中 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。 2. 重写equals方法时,为什么也需要重写hashCode方法。 1、重写equals方法时需要重写hashCode方法，主要是针对Map、Set等集合类型的使用； a: Map、Set等集合类型存放的对象必须是唯一的； b: 集合类判断两个对象是否相等，是先判断equals是否相等，如果equals返回TRUE，还要再判断HashCode返回值是否ture,只有两者都返回ture,才认为该两个对象是相等的。 2、由于Object的hashCode返回的是对象的hash值，所以即使equals返回TRUE，集合也可能判定两个对象不等，所以必须重写hashCode方法，以保证当equals返回TRUE时，hashCode也返回Ture，这样才能使得集合中存放的对象唯一。 3. Android 中的Dalvik和ART是什么，有啥区别？答: 在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率。在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。 4. Glide, Picasso原理?5. 事件传递机制?(参考郭霖事件分发博客)6. Okhttp原理解析,优点答: 总结: OkHttpClient 实现 Call.Factory，负责为 Request 创建 Call；RealCall 为具体的 Call 实现，其 enqueue() 异步接口通过 Dispatcher 利用 ExecutorService 实现，而最终进行网络请求时和同步 execute() 接口一致，都是通过 getResponseWithInterceptorChain() 函数实现；getResponseWithInterceptorChain() 中利用 Interceptor 链条，分层实现缓存、透明压缩、网络 IO 等功能； 7. 内存泄漏全解析8. 热修复有所了解?9. 路由了解吗?routerSDK10. foreach原理答: foreach语法最终被编译器转为了对Iterator.next()的调用。而作为使用者的我们，jdk并没用向我们暴露这些细节，我们甚至不需要知道Iterator的存在，认识到jdk的强大之处了吧。 11. EventBus 源码解析答: 总结: 底层也是回掉实现。优点：EventBus是很好地替代了回调的功能，松耦合，使用简单。缺点：只要用得一多，那消息类的数量必然是会爆炸性增长，调试的时候除非熟悉整块逻辑，不然不跑起来你是没办法了解Subscribe的方法的数据来源。 12. Android进程保活的套路 - 文中源码答: 1,开启一个像素的Activity(手Q) 2,前台服务 3,相互唤醒 4,JobSheduler 5,粘性服务&amp;与系统服务捆绑常被问的问题- Android 进程不死从3个层面入手, 腾讯Bugly保活文章 13. ButterKnife工作流程答:当你编译你的Android工程时，ButterKnife工程中 ButterKnifeProcessor 类的 process() 方法会执行以下操作： 开始它会扫描Java代码中所有的ButterKnife注解 @Bind 、 @OnClick 、 @OnItemClicked 等 当它发现一个类中含有任何一个注解时， ButterKnifeProcessor 会帮你生成一个Java类，名字类似 $$ViewBinder ，这个新生成的类实现了 ViewBinder 接口 这个 ViewBinder 类中包含了所有对应的代码，比如 @Bind 注解对应 findViewById() , @OnClick 对应了 view.setOnClickListener() 等等 最后当Activity启动 ButterKnife.bind(this) 执行时，ButterKnife会去加载对应的 ViewBinder 类调用它们的 bind() 方法 14. RxJava &amp; Retrofit结合的最佳实践- 封装的思想值得学习!!!, Retrofit","categories":[{"name":"知识点","slug":"知识点","permalink":"https://yangxiaoge.github.io/categories/知识点/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://yangxiaoge.github.io/tags/Java/"}]},{"title":"Eshop-RN 成功运行爬坑记录","slug":"Eshop-RN-成功运行爬坑记录","date":"2017-02-09T07:21:42.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2017/02/09/Eshop-RN-成功运行爬坑记录/","link":"","permalink":"https://yangxiaoge.github.io/2017/02/09/Eshop-RN-成功运行爬坑记录/","excerpt":"先上图片","text":"先上图片 问题总结(持续更新ing) npm install 要保证网络畅通 node版本尽量用官方推荐版本, 或者低版本(之前由于我用了v7.4.0版本,导致运行报错等各种奇葩问题。 降级到v6.9.5之后就解决了) Git拉去新工程之后最好先删除node_modules,再运行npm install more 附上RN学习思维导图 RN组件可用属性整理图片来源 给所有开发者的React Native详细入门指南（第一阶段）文中Demo地址 RN组件可用属性整理.xlsx","categories":[{"name":"React Native","slug":"React-Native","permalink":"https://yangxiaoge.github.io/categories/React-Native/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://yangxiaoge.github.io/tags/React-Native/"}]},{"title":"2016年终总结","slug":"2016年终总结","date":"2016-12-30T03:12:34.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/12/30/2016年终总结/","link":"","permalink":"https://yangxiaoge.github.io/2016/12/30/2016年终总结/","excerpt":"转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~ 掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活，但是相比之下我还是喜欢踏实的工作，花着自己辛苦挣来的工资，很开心！ 下面说说毕业后在软创学到的东西吧, 软创是我毕业来的第一家公司,主要学习的知识点方向有两个: Android, Birt(报表,涉及数据库的CRUD知识点)。 概括一下Android的学习，毕竟这是我个人爱好的！（当然，今年IT也面临了寒冬，不过也不用恐慌，做好自己！！！）","text":"转眼间，2016即将结束。本打算明天(12月31号)写年终总结的，不过明天放假O(∩_∩)O~~ 掐指一算已经工作近2年了，啊~~我又老了一岁￣へ￣。虽然怀念学校安逸的生活，但是相比之下我还是喜欢踏实的工作，花着自己辛苦挣来的工资，很开心！ 下面说说毕业后在软创学到的东西吧, 软创是我毕业来的第一家公司,主要学习的知识点方向有两个: Android, Birt(报表,涉及数据库的CRUD知识点)。 概括一下Android的学习，毕竟这是我个人爱好的！（当然，今年IT也面临了寒冬，不过也不用恐慌，做好自己！！！）在2016年里完成的项目： 1、My Busy 4G 2、MPT 4U 经历过第一个公司级别的项目My Busy 4G之后，最大收获就是：个人水平能力得到了很大的提升，尤其是同事们都很热心！还有一个收获就是：学习方法！举个栗子：新下来一个需求，首先要考虑的是项目中是否有可以复用的业务模块，组件等等（模块化开发的重要性！），其次就是要利用好搜索引擎（Google），Github，Stack Overflow，CSDN等。当然有时候我还需要自己造轮子（心平气和，不浮躁，孰能生巧）。在软创这一年里我的技术可以说是飞速提升，受益良多！ 在这一年里，我很庆幸，我养成了一个习惯：每天早上在公司班车上都要阅读几篇公众号的文章，然后看看新闻。 感谢有几位交心好友，祝前程似锦，愿友谊长存！ 最后，祝我的家人，亲朋在新的一年身体健康，工作顺利，鸡年大吉~ 2017 Fighting！","categories":[{"name":"个人总结","slug":"个人总结","permalink":"https://yangxiaoge.github.io/categories/个人总结/"}],"tags":[{"name":"个人总结","slug":"个人总结","permalink":"https://yangxiaoge.github.io/tags/个人总结/"}]},{"title":"JavaScript学习笔记","slug":"JavaScript学习笔记","date":"2016-12-29T01:34:01.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2016/12/29/JavaScript学习笔记/","link":"","permalink":"https://yangxiaoge.github.io/2016/12/29/JavaScript学习笔记/","excerpt":"廖雪峰 js教程 JavaScript教程 我的练习基本是按着教程敲了一遍. 用的Chrome调试窗口,很方便! 以下是笔记 javascript的五种基本数据类型基本数据类型: Undefined，Null，Boolean，Number和String; 此外还含有一种复杂数据类型—Object","text":"廖雪峰 js教程 JavaScript教程 我的练习基本是按着教程敲了一遍. 用的Chrome调试窗口,很方便! 以下是笔记 javascript的五种基本数据类型基本数据类型: Undefined，Null，Boolean，Number和String; 此外还含有一种复杂数据类型—Object if判断,传参传的非boolean类型12345var s = '123';if (s.length) &#123; // 条件计算结果为3 console.log(\"你好啊\"); //打印结果为你好啊&#125;原因: JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true。 Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。123456789var m = new Map([['Michael', 95], ['Bob', 75], ['Adam', 85]]);m.get('Michael'); // 95m.delete('Adam'); // 删除key 'Adam'var s = new Set();s.add(1); // Set &#123;1&#125;s.add(2); // Set &#123;1, 2&#125;s.add(3); // Set &#123;1, 2,3&#125;s.delete(3); // Set &#123;1, 2&#125; ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。12345678910111213141516// 更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：//forEach()方法是ES5.1标准引入的var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 alert(element);&#125;);或者://由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; alert(element);&#125;); JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：12345678910111213arguments，你可以获得调用者传入的所有参数实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125;要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 高阶函数, 高阶函数英文叫Higher-order function1234function string2int(s) &#123; return s.split(&apos;&apos;).map(strNum =&gt; strNum * 1).reduce((x, y) =&gt; x * 10 + y)&#125;string2int(&apos;12345&apos;) 细细理解 map(), reduce(), filter()的区别sort123456789101112131415161718192021222324252627如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 10, 20]var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;); // ['apple', 'Google', 'Microsoft']最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array： 闭包（Closure）12345678910111213141516171819202122232425我们来实现一个对Array的求和。通常情况下，求和的函数是这样定义的：function sum(arr) &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;);&#125;sum([1, 2, 3, 4, 5]); // 15如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125;当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()调用函数f时，才真正计算求和的结果：f(); // 15在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 箭头函数ES6标准新增了一种新的函数：Arrow Function（箭头函数）。1234567891011121314151617x =&gt; x * x上面的箭头函数相当于：function (x) &#123; return x * x;&#125;箭头函数有两种格式，一种像上面的，只包含一个表达式，连&#123; ... &#125;和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略&#123; ... &#125;和return：x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; generator123456789101112131415161718192021222324252627282930313233用generator改写如下：function* fib(max) &#123; var t, a = 0, b = 1, n = 1; while (n &lt; max) &#123; yield a; t = a + b; a = b; b = t; n ++; &#125; return a;&#125;直接调用试试：fib(5); // fib &#123;[[GeneratorStatus]]: \"suspended\", [[GeneratorReceiver]]: Window&#125;直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。调用generator对象有两个方法，一是不断地调用generator对象的next()方法：var f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: true&#125;next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象&#123;value: x, done: true/false&#125;，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 标准对象12345678910111213141516171819总结一下，有这么几条规则需要遵守：不要使用new Number()、new Boolean()、new String()创建包装对象；用parseInt()或parseFloat()来转换任意类型到number；用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) &#123;...&#125;；typeof操作符可以判断出number、boolean、string、function和undefined；判断Array要使用Array.isArray(arr)；判断null请使用myVar === null；判断某个全局变量是否存在用typeof window.myVar === 'undefined'；函数内部判断某个变量是否存在用typeof myVar === 'undefined'。 RegExp (正则表达式)1234567891011121314151617181920212223242526在正则表达式中，如果直接给出字符，就是精确匹配。用\\d可以匹配一个数字，\\w可以匹配一个字母或数字，所以：'00\\d'可以匹配'007'，但无法匹配'00A'；'\\d\\d\\d'可以匹配'010'；'\\w\\w'可以匹配'js'；.可以匹配任意字符，所以：'js.'可以匹配'jsp'、'jss'、'js!'等等。JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配：var s='zhuzhuyang, xiaoyang, feiyang';var reg = /[a-zA-Z]+yang/g;reg.exec(s); //['zhuzhuyang']reg.lastIndex; //10reg.exec(s); //['xiaoyang']reg.lastIndex; //20reg.exec(s); //['feiyang']reg.lastIndex; //29reg.exec(s); // null，直到结束仍没有匹配到 JSON12345678910在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：number：和JavaScript的number完全一致；boolean：就是JavaScript的true或false；string：就是JavaScript的string；null：就是JavaScript的null；array：就是JavaScript的Array表示方式——[]；object：就是JavaScript的&#123; ... &#125;表示方式。 序列化12345678910111213141516171819202122232425262728293031var xiaoming = &#123; name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']&#125;;JSON.stringify(xiaoming); // '&#123;\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]&#125;'要输出得好看一些，可以加上参数，按缩进输出：JSON.stringify(xiaoming, null, ' ');&#123; \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]&#125;更多JSON用法可以看廖雪峰教程 面向对象编程JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。12345678910111213141516171819var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;var xiaoming = &#123; name: '小明'&#125;;xiaoming.__proto__ = Student;注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：xiaoming.name; // '小明'xiaoming.run(); // 小明 is running...xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用： 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.proto去改变一个对象的原型，并且，低版本的IE也无法使用proto。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：1234567891011121314151617181920// 原型对象:var Student = &#123; name: 'Robot', height: 1.2, run: function () &#123; console.log(this.name + ' is running...'); &#125;&#125;;function createStudent(name) &#123; // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;&#125;var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yangxiaoge.github.io/categories/JavaScript/"}],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://yangxiaoge.github.io/tags/前端开发/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yangxiaoge.github.io/tags/JavaScript/"}]},{"title":"Flow.ci持续集成","slug":"flow.ci持续集成","date":"2016-12-07T06:19:05.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/12/07/flow.ci持续集成/","link":"","permalink":"https://yangxiaoge.github.io/2016/12/07/flow.ci持续集成/","excerpt":"好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来给自己定个长期目标， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。 言归正传其实获得FlowCi测试资格已经好几个月了， 一直没有去使用它， FlowCi功能非常强大。 之前我用的是daocloud持续集成博客, 不过今天发现持续集成失败了， 发现是daocloud升级了， 集成的配置文件需要修改， 我就乘此机会转投FlowCi的怀抱中了 O(∩_∩)O哈哈~那么 怎么使用 FlowCi 为 Hexo博客持续集成呢？","text":"好久没有写博客了o(╯□╰)o , 终于忙完Android项目了。接下来给自己定个长期目标， 每个月至少写一篇博文，可以是感想闲聊篇也可是技术篇， 哈哈看心情啦。 言归正传其实获得FlowCi测试资格已经好几个月了， 一直没有去使用它， FlowCi功能非常强大。 之前我用的是daocloud持续集成博客, 不过今天发现持续集成失败了， 发现是daocloud升级了， 集成的配置文件需要修改， 我就乘此机会转投FlowCi的怀抱中了 O(∩_∩)O哈哈~那么 怎么使用 FlowCi 为 Hexo博客持续集成呢？ PS: (2016-12-8 09:31:50 add) 强迫症的我还是把daocloud持续集成搞好了(^o^)/~, 不过我还是用FlowCi吧, 尝试新工具哈哈~~啪啪打脸~~ flowci hook push不及时, 有时候coding源码修改了,但是都不push消息给flowci,所以博客有时候并没有自动集成o(╯□╰)o 创建项目 选择代码仓库 这里取决于hexo博客源文件存放在哪里了 github, coding等… 创建新的工作流 之前有简单的步骤就省略了… 工作流选择, Nodejs(Hexo编译所需环境)，版本选择了最新的v6.6.0, 当然还有其他的, Python, Android, Php等。 后面我会尝试使用Android持续集成，也会写相应文章。 触发器(什么时候自动集成) 设置 触发器-push-正则匹配-master, 意思就是当 hexo博客git的master源文件改变时, 就会触发FlowCi的持续集成! 自定义脚本这里的 .daocloud文件夹(文件夹随便怎么命名)是用来存放id_rsa的 1234567891011121314# 安装Hexo命令行工具flow_cmd \"npm install hexo-cli -g\" --echo# 准备并安装私钥flow_cmd \"cp .daocloud/id_rsa .\" --echo flow_cmd \"chmod 600 ./id_rsa\" --echo flow_cmd \"eval $(ssh-agent)\" --echo flow_cmd \"ssh-add ./id_rsa\" --echo# 执行Hexo生成和发布flow_cmd \"hexo clean\" --echo flow_cmd \"hexo g\" --echo flow_cmd \"hexo d\" --echo 添加FlowCi的 RSA公匙到github以及coding(授予读写权限) 快去提交代码吧我是单独在coding建了一个新的仓库存放博客源文件,yangxiaoge-CI之后只要往yangxiaoge-CI仓库中提交或者增删改查时, FlowCi会自动集成并发布到yangxiaoge编译后的博客地址中!binggo!!!坐等集成好,登录网站查看变动吧！是不是很爽😏 , 跨PC更新博客也更方便啦~~~","categories":[{"name":"持续集成","slug":"持续集成","permalink":"https://yangxiaoge.github.io/categories/持续集成/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yangxiaoge.github.io/tags/Hexo/"},{"name":"持续集成","slug":"持续集成","permalink":"https://yangxiaoge.github.io/tags/持续集成/"}]},{"title":"mock数据","slug":"Fiddler拦截请求mock假数据","date":"2016-11-08T02:44:59.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2016/11/08/Fiddler拦截请求mock假数据/","link":"","permalink":"https://yangxiaoge.github.io/2016/11/08/Fiddler拦截请求mock假数据/","excerpt":"","text":"Fiddler抓包拦截 Easy Mock","categories":[{"name":"mock","slug":"mock","permalink":"https://yangxiaoge.github.io/categories/mock/"}],"tags":[{"name":"Fiddler","slug":"Fiddler","permalink":"https://yangxiaoge.github.io/tags/Fiddler/"},{"name":"mock","slug":"mock","permalink":"https://yangxiaoge.github.io/tags/mock/"}]},{"title":"Android内存泄漏总结","slug":"Android内存泄漏总结","date":"2016-10-10T05:29:20.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2016/10/10/Android内存泄漏总结/","link":"","permalink":"https://yangxiaoge.github.io/2016/10/10/Android内存泄漏总结/","excerpt":"内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。 我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。","text":"内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。 我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。 Java 内存分配策略Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区 ：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。 栈与堆的区别：在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举个例子: 1234567891011public class Sample &#123; int s1 = 0; Sample mSample1 = new Sample(); public void method() &#123; int s2 = 1; Sample mSample2 = new Sample(); &#125;&#125;Sample mSample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。 结论： 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。 了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。 Java是如何管理内存Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。 监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 什么是Java中的内存泄露在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。 在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。 通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。 因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。 同样给出一个 Java 内存泄漏的典型例子， 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 详细Java中的内存泄漏 1.Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。 2.Java内存泄漏引起的原因 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。j Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类： 1、静态集合类引起内存泄漏： 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 例如 1234567Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++)&#123;Object o = new Object();v.add(o);o = null;&#125; 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。 2、当集合里面的对象属性被修改后，再调用remove()方法时不起作用。 例如： 123456789101112131415161718192021public static void main(String[] args)&#123;Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();Person p1 = new Person(\"唐僧\",\"pwd1\",25);Person p2 = new Person(\"孙悟空\",\"pwd2\",26);Person p3 = new Person(\"猪八戒\",\"pwd3\",27);set.add(p1);set.add(p2);set.add(p3);System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:3 个元素!p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变set.remove(p3); //此时remove不掉，造成内存泄漏set.add(p3); //重新添加，居然添加成功System.out.println(\"总共有:\"+set.size()+\" 个元素!\"); //结果：总共有:4 个元素!for (Person person : set)&#123;System.out.println(person);&#125;&#125; 3、监听器 在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 4、各种连接 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。 5、内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：public void registerMsg(Object b);这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。 6、单例模式 不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子： 12345678910111213141516171819class A&#123;public A()&#123;B.getInstance().setA(this);&#125;....&#125;//B类采用单例模式class B&#123;private A a;private static B instance=new B();public B()&#123;&#125;public static B getInstance()&#123;return instance;&#125;public void setA(A a)&#123;this.a=a;&#125;//getter...&#125; 显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况 Android中常见的内存泄漏汇总 集合类泄漏集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。 单例造成的内存泄漏由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子， 12345678910111213public class AppManager &#123;private static AppManager instance;private Context context;private AppManager(Context context) &#123;this.context = context;&#125;public static AppManager getInstance(Context context) &#123;if (instance == null) &#123;instance = new AppManager(context);&#125;return instance;&#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 正确的方式应该改为下面这种方式： 12345678910111213public class AppManager &#123;private static AppManager instance;private Context context;private AppManager(Context context) &#123;this.context = context.getApplicationContext();// 使用Application 的context&#125;public static AppManager getInstance(Context context) &#123;if (instance == null) &#123;instance = new AppManager(context);&#125;return instance;&#125;&#125; 或者这样写，连 Context 都不用传进来了： 12345678910111213141516171819202122232425262728在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，...context = getApplicationContext();... /** * 获取全局的context * @return 返回全局context对象 */ public static Context getContext()&#123; return context; &#125;public class AppManager &#123;private static AppManager instance;private Context context;private AppManager() &#123;this.context = MyApplication.getContext();// 使用Application 的context&#125;public static AppManager getInstance() &#123;if (instance == null) &#123;instance = new AppManager();&#125;return instance;&#125;&#125; 匿名内部类/非静态内部类和异步线程非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： 123456789101112131415public class MainActivity extends AppCompatActivity &#123;private static TestResource mResource = null;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);if(mManager == null)&#123;mManager = new TestResource();&#125;//...&#125;class TestResource &#123;//...&#125;&#125; 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为： 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建 匿名内部类android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露 1234567891011public class MainActivity extends Activity &#123;...Runnable ref1 = new MyRunable();Runnable ref2 = new Runnable() &#123; @Override public void run() &#123; &#125;&#125;; ...&#125; ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存： 可以看到，ref1没什么特别的。 但ref2这个匿名类的实现对象里面多了一个引用： this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。 Handler 造成的内存泄漏Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。 由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。 举个例子： 1234567891011121314151617181920212223public class SampleActivity extends Activity &#123;private final Handler mLeakyHandler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123; // ...&#125;&#125;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);// Post a message and delay its execution for 10 minutes.mLeakyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125;&#125;, 1000 * 60 * 10);// Go back to the previous Activity.finish();&#125;&#125; 在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are \"static\". */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。 在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形： 首先定义一个HashMap，保存软引用对象。 1private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; (); 再来定义一个方法，保存Bitmap的软引用到HashMap。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。 下面几个方法都可以移除 Message： 123456789public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Object token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object); 尽量避免使用 static 成员变量如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。 这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi’wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。 这里修复的方法是： 不要在类初始时初始化静态成员。可以考虑lazy初始化。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 避免 override finalize()1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是： 虚拟机调用GC的时间不确定 Finalize daemon线程被调度到的时间不确定 2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是： 含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。 3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。 资源未关闭造成的内存泄漏对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 一些不良代码造成的内存压力有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。 比如： Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。 构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。 总结对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。 尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。 对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 将内部类改为静态内部类 静态内部类中使用弱引用来引用外部类的成员变量 Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable. 在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。 正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。 保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。 原文链接","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"内存泄漏","slug":"内存泄漏","permalink":"https://yangxiaoge.github.io/tags/内存泄漏/"}]},{"title":"有人向我反馈了一个bug","slug":"有人向我反馈了一个bug","date":"2016-09-23T04:55:26.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/09/23/有人向我反馈了一个bug/","link":"","permalink":"https://yangxiaoge.github.io/2016/09/23/有人向我反馈了一个bug/","excerpt":"本文原文地址 : Midaoi小站 前言 这篇文章非常有意思！ 英文原文 →","text":"本文原文地址 : Midaoi小站 前言 这篇文章非常有意思！ 英文原文 → //我是一个Android开发者，但我想这个故事对任何开发者都会引起共鸣的 有人向你反馈了一个 bug。 “26 楼会议室的灯亮着。它需要被熄灭。”bug 的备注里写道“你应该能在 5 分钟内搞定，只要按一下开关就好了。“ 你去了 26 楼的会议室。灯的确亮着，但房间里没有灯的开关。 所以，你准备安装一个。但设计师说，它会破坏房间的美感。另外，墙壁是混凝土。你需要合适的工具才能安装开关。但是，没有人会批准购买这些工具。如果没有合适的工具，安装开关将需要两天。他们希望你现在就能把灯关上，因为他们害怕 CEO 可能心血来潮决定去 26 楼逛逛，并恰好路过了会议室，问为什么灯是亮着的。 现在你不断地收到邮件，询问为什么会议室的灯还是亮着的。现在你不得不群发一封邮件说明情况，几人开始了一个恐慌的电子邮件链。 你知道，如果你期待着问题能够被邮件讨论解决（而不实际做点什么），这个问题永远也不会得到修复。bug 系统里，这个 bug 归你处理，而且它的最后期限就是今天。如果问题没有解决，会有麻烦的是你。所以，你设法进到了 26 楼走廊的天花板里，找到了会议室灯的电线，一刀切断。问题解决了。 为了平息在电子邮件链里的恐慌，你(再次群发邮件)说明了你是如何解决问题的。 邮箱安静了一阵。当它再次响个不停的时候，每个人都在担心，现在会议室的灯无法开启和关闭。如果 CEO 想在那里开会怎么办？因此，他们要求你“把灯的电线牵引到地下室去”。当有人需要开关灯时，他们会通知你到地下室去，连接或断开电线。 你抗议这个荒谬的解决方案。你的上司说，“是的，我知道这不理想。但它是现在唯一的解决方案。“ 这时，你面临着选择。你可以照着他们说的做，或者辞职以示抗议，另谋高就。但你知道，一旦你开始了新的工作，新的他们很可能也会要求你做这么白痴的事，如果不是更白痴的话。 你把 26 楼的电线牵引到了地下室。当你进入地下室后，发现已经有几十条电线挂在墙上，你知道你不是一个人，也知道了这个白痴想法是从哪来的。你调整好了电线，尽人事地贴上标记，默默地向下一个可能处理它的哥们道歉。 终于，你回到了你的办公桌，你收到了一个新的 report。 QA 重新开启了 bug。bug 描述里说“房间还是亮着。” 你回到 26 楼的会议室。灯是灭着的。你返回办公桌前，关闭了 bug，注明你已经亲自检查过了。 QA 再次重新开启了 bug。“房间还亮着”bug 描述里坚持。再次亲眼确认灯泡灭着后，你将情况汇报给了上司。他建议你去地下室检查电线。你抗议说你正直盯盯地看着灯，它就是灭着的。 “我知道，但去检查一下。这样一来你就可以告诉 QA 你确认了所有流程。” 你叹了口气，前往地下室。果然，电线没有连接，切口两端都好好地被包裹着。它们不可能以任何你能理解的方式导电。 你向 QA 反馈，你检查了电线，它们没有连接着，你正看着灯泡，它是熄灭的。 “我不是指灯泡，”QA 说。 “bug 里描述的是房间里的光。房间现在仍然不够暗。你应该拉下百叶窗。“你回应说百叶窗不归你管，bug 描述的是灯光。 QA 不相信你，发出一组电子邮件，询问 bug 是否包含百叶窗拉下的问题。 你很是等待了一会，邮箱又一次响起了。 “从理论上说，”他们问，“如果光太亮或太暗的话，在 26 楼会议室开会的人能自由拉上或拉下百叶窗吗？” 是的，他们可以，你回复。 “任何一个普通人都能做到吗？他们就不需要你做了吗？“是的，任何普通人。不，他们不会需要你。任何人都可以做到这一点。 “太好了。那么，灯光问题暂时到此为止。我会安排如何处理百叶窗的会议。“ bug 被关闭了。现在，CEO，可能从所有关于 26 楼会议室的讨论中感觉到了什么，希望在那里开会。你收到了几封希望开灯的惊慌失措的邮件。 你去了地下室，连上电线，并返回办公桌。你的收件箱多了 32 个新的消息。 “出问题了-灯还是熄灭的!”“有个问题-没有灯光!” “你收到我们发的邮件了吗？等等等等。 第 32 封邮件说道:“没事-灯亮了。” 这个(指 32 封邮件)过程，或多或少地，在开关灯时反复发生。 如果要说有什么好消息的话，那就是在会议结束后，大家甚至都忘记了 26 楼有个会议室，你也不需要对它做任何处理。","categories":[{"name":"bug小场景","slug":"bug小场景","permalink":"https://yangxiaoge.github.io/categories/bug小场景/"}],"tags":[{"name":"article","slug":"article","permalink":"https://yangxiaoge.github.io/tags/article/"}]},{"title":"Windows常用工具","slug":"Windows常用工具","date":"2016-09-21T07:24:00.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2016/09/21/Windows常用工具/","link":"","permalink":"https://yangxiaoge.github.io/2016/09/21/Windows常用工具/","excerpt":"首先申明本文转载， 本文由 Michael翔 创作， 基于原文有所改动 ! 总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯：","text":"首先申明本文转载， 本文由 Michael翔 创作， 基于原文有所改动 ! 总结一下自己常用的软件工具，有正版开源的，还是尽量不要去找破解版、绿色版的了，养成好的习惯： Windowns常用软件录制Gif工具LICEcap录制Gif工具ScreenToGif 工具相当不错，而且是绿色软件，真良心~~ 看图FastStoneImageViewer 免费软件，好用到爆！没广告！功能齐全！不光能看图，还能修图！Picasa3 Google的图片管理软件(已经停止服务了)Photos Google 相册照片服务 (本人iPhone6内存16G伤不起(；′⌒`), 果断备份到Google Photos了!!!) 文件搜索Listary 小众软件介绍，超级好用的文件搜索工具，按下快捷键，随时搜索Everything 也是传说中的文档搜索神器！其他功能有待开发…… 文件整理Q-Dir 有时候需要在文件夹之间移动文件，这时候，这个整理神器就能派上用场了！Clover 3 这款文件夹体验跟浏览器一样，不会有多窗口，不会杂乱无章 ! — 个人目前在用 pdf查看福昕pdf阅读正版2345看图王 你没看错，2345就是这么强大~ 视频播放PotPlayer 厌烦了暴风一打开就是广告，发现了这款播放器，没广告！能力出色！ 视频下载硕鼠 有的也不能下载了，比如优酷 视频下载神器！为了下载PC上的网易公开课发现的工具，很多视频网站都能下载！ 同步盘360云盘百度云这两款同步盘真是给我带来了很大的便利，安全性啥的也不用去较真，非得整啥Dropbox(需要梯子)，毕竟自己也没啥重要隐私文件…… 文件删除Unlocker下载 当你重命名或删除一个文件/文件夹时，Windows 弹出对话框提示你“无法删除 xxx:它正在被其它用户/程序使用!”，怎么办?其实腾讯电脑管家的 文件粉碎 功能也可以 — 个人在用 浏览器Chrome 很占内存，但启动速度、标签、扩展同步等真是做的棒！一个账号，走遍天下~安利下知乎上的总结的Chrome扩展 ~~需要更多的插件可以去知乎搜索下 笔记印象笔记 很棒！裁剪、搜索、标签等细节功能做的很到位！简洁大气的风格，很喜欢。— 目前在用为知笔记 国内良心笔记公司，做的也很棒！代码高亮、Markdown等等都一应俱全，还有丰富的插件~ 截图搜狗输入法 哈哈，没看错！就是它！安装截图扩展之后，快捷键就能截图，哪个电脑都ok，多方便！搜狗输入法技巧总结 邮箱这个就比较多了， 目前在用 Gmail，126，QQ等 小众软件Wgesture 用惯浏览器鼠标手势的同志，这个绝对是你们的福利！全局鼠标手势！！！ 加密工具Wise Folder Hider Free 隐私文件怎么保存？这个获奖无数的工具，免费版足够用啦！ Windows下的开发工具控制台cmder 如果厌倦了Windows下控制台丑陋不方便的样子，可以试试这个。 编辑器Sublime TextNotepad++Atom IDE说到IDE当然离不开 jetbrains全家桶 良心公司，学生党免费！前提是要有教育邮箱~jetbrains全家桶: IntelliJ IDEA，PhpStorm，WebStorm，Pycharm -python开发，Android Studio也是它家提供支持的，等等Redo python调试很方便，界面有点类似R-studio、PyScripter python开发 SS做完一个Coder，ss都懂的吧，学习工作专用，再配合Google搜索 (某度要慎重使用！)，效率大大提升~~ 未完待续~~","categories":[{"name":"工具","slug":"工具","permalink":"https://yangxiaoge.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://yangxiaoge.github.io/tags/工具/"}]},{"title":"daocloud持续集成个人博客","slug":"daocloud持续集成个人博客","date":"2016-09-20T05:46:54.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/09/20/daocloud持续集成个人博客/","link":"","permalink":"https://yangxiaoge.github.io/2016/09/20/daocloud持续集成个人博客/","excerpt":"","text":"详情见我基友littlefisher的文章: Hexo + DaoCloud 持续集成","categories":[{"name":"持续集成","slug":"持续集成","permalink":"https://yangxiaoge.github.io/categories/持续集成/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yangxiaoge.github.io/tags/Hexo/"},{"name":"持续集成","slug":"持续集成","permalink":"https://yangxiaoge.github.io/tags/持续集成/"}]},{"title":"我的演说","slug":"我的演说","date":"2016-09-20T01:16:59.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/09/20/我的演说/","link":"","permalink":"https://yangxiaoge.github.io/2016/09/20/我的演说/","excerpt":"","text":"此文是一个演示ppt的demo,只要打开网页就能随时随地展示! 使用的是黄玄开发的演说在线工具 Watch Fullscreen → 你可以通过扫描二维码在手机上观看 上一张ubuntu的图片","categories":[{"name":"在线PPT","slug":"在线PPT","permalink":"https://yangxiaoge.github.io/categories/在线PPT/"}],"tags":[{"name":"演说","slug":"演说","permalink":"https://yangxiaoge.github.io/tags/演说/"}]},{"title":"开源项目收集","slug":"开源项目收集","date":"2016-09-14T03:39:56.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/09/14/开源项目收集/","link":"","permalink":"https://yangxiaoge.github.io/2016/09/14/开源项目收集/","excerpt":"AndroidTVLauncher 猫桌面 - 中国首位 00 后 CEO 公然抄袭、复制我的开源作品, 原作者的项目都很棒！坚决抵制这种炒作抄袭行为！ Android最新源码汇总 Arsenal Trinea wanandroid_鸿洋维护 极客导航 osplus QQ上拉弹出键盘 AndroidKeyboardListener 各种下拉效果SpringView(美图,QQ网页下拉等等) 等等…","text":"AndroidTVLauncher 猫桌面 - 中国首位 00 后 CEO 公然抄袭、复制我的开源作品, 原作者的项目都很棒！坚决抵制这种炒作抄袭行为！ Android最新源码汇总 Arsenal Trinea wanandroid_鸿洋维护 极客导航 osplus QQ上拉弹出键盘 AndroidKeyboardListener 各种下拉效果SpringView(美图,QQ网页下拉等等) 等等… 印象笔记(目前不对外公布) 收集中(鸿洋,郭霖微信博客都可以关注下)… 滴滴滴~~~来不及解释了! 快上车! 不错的博客和工具网站 仿QQ6.0侧滑效果 Android动态生成验证码VerificationCode View Android开发人员不得不收集的代码(持续更新中) 清晰灵活简单易用的应用更新库 多语言切换库 mpt项目使用中 calligraphy(高效加载字体库) mpt项目使用中 material-dialogs QuickDevLib TakePhoto StatusBarUtil状态栏工具类 微笑下拉刷新 各种布局下拉刷新效果 多Fragment嵌套库, 仿知乎等 仿照网易云音乐(2.9.0)界面的练习项目 手势引导 高仿QQ附近的人雷达扫描图 SwipeMenuListView 高仿WeChat 《Android开发艺术探索》书中源代码 鸿洋okhttp的封装类 app指向性功能高亮的库_鸿洋写的 Material Design Bottom 知乎 Android 客户端启动页动画效果实现 仿flyme悬浮球 wuchangfeng/one 后台用python抓数据存储在LeanCloud - 对应的后端 合理的进程保活 打不死的小强,永不crash的Android Fragmentation一个强大的Android Fragment管理库,apk下载 - 2017年2月20日09:54:56 Android 直播播放器+弹幕使用总结 - 2017年2月16日16:02:06 《云阅》一个仿网易云音乐UI，使用Gank.Io及豆瓣Api开发的开源项目 高仿微信6.3.31 android各种流程源码解析 AndroidStudio——Freeline的使用—郭霖公众号 Android路由框架 毕业设计——okHttp封装+php+xampp+retrofit封装+rx+mvc+文档的成品app RapidFloatingActionButton sealtalk-android：基于融云开发的 Android 版即时通讯（IM）应用程序 - 嗨豹 - 鸿洋微信推荐 DropDownMenu开源库 SmartRefreshLayout - Android 智能下拉刷新框架-SmartRefreshLayout easy_mock_api - 给客户端（Android iOS）同学的模拟json接口的小工具 用nodejs（express+react）搭建的极简的服务器，给定一个url就返回一个特定的Json数据，提供给客户端开发同学用的模拟Json服务器接口的项目，项目尽可能的简单，核心代码只有100多行，简单而实用，方便扩展。 Spotlight-支持引导路径高亮的方案。 Matisse - 知乎图片选择47.TelegramGallery - 抽取 Telegram 相册功能 仿全民TV 高仿全民直播（全民TV） 高仿iOS 滚轮实现 省市区 城市选择三级联动 史上最简单侧滑菜单52.GankMM – 干货营 - 包含 泡网，天气，常用工具，换肤等52.Android 录音功能直接拿去用 - code小生53.Android 实现 dialog 的 3D 翻转54.360° 全景图片、全景视频工程55.Android-SVProgressHUD 精仿 iOS 的提示库","categories":[],"tags":[]},{"title":"Android Studio常用插件整理(大图预警!)","slug":"Android Studio常用插件整理(大图预警!)","date":"2016-08-31T01:51:51.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/08/31/Android Studio常用插件整理(大图预警!)/","link":"","permalink":"https://yangxiaoge.github.io/2016/08/31/Android Studio常用插件整理(大图预警!)/","excerpt":"","text":"详情见: 习惯沉默的Blog","categories":[{"name":"Android Studio插件","slug":"Android-Studio插件","permalink":"https://yangxiaoge.github.io/categories/Android-Studio插件/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://yangxiaoge.github.io/tags/Android-Studio/"}]},{"title":"bughd让bug无处遁形","slug":"bughd让bug无处遁形","date":"2016-08-17T01:21:05.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2016/08/17/bughd让bug无处遁形/","link":"","permalink":"https://yangxiaoge.github.io/2016/08/17/bughd让bug无处遁形/","excerpt":"BugHD 帮助 Android开发, 崩溃分析 &amp; 检测更新&amp; 开放 API。 如何在app中配置？ 详见官方文档 MumuXi项目中已经配置好了,可以供参考 集成到app中分为如下几步: General KeyGeneral Key 用来唯一标识您的应用，为防止别人滥用，请勿泄露，建立每个项目时将自动生成项目对应的 General Key，可在项目列表页查看每个项目对应的 General Key值","text":"BugHD 帮助 Android开发, 崩溃分析 &amp; 检测更新&amp; 开放 API。 如何在app中配置？ 详见官方文档 MumuXi项目中已经配置好了,可以供参考 集成到app中分为如下几步: General KeyGeneral Key 用来唯一标识您的应用，为防止别人滥用，请勿泄露，建立每个项目时将自动生成项目对应的 General Key，可在项目列表页查看每个项目对应的 General Key值 导入SDK –&gt;其一方法: 通过 Gradle 自动构建在项目的 build.gradle（Top-level build file，项目最外层的 build.gradle 文件）中添加这个 maven repositories，例如： 1234567891011121314151617181920buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() maven &#123; url \"http://maven.bughd.com/public\" &#125; &#125;&#125; 在要集成的项目中的 build.gradle 中添加依赖，如下： 123dependencies &#123; compile 'im.fir:fir-sdk:latest.integration@aar'&#125; 配置123456789101112131415&lt;manifest……&gt; &lt;!-- 必选 --&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"&gt;&lt;/uses-permission&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt; &lt;!-- 可选 --&gt; &lt;uses-permission android:name=\"android.permission.GET_TASKS\"&gt;&lt;/uses-permission&gt; &lt;application ……&gt; &lt;activity ……/&gt; &lt;meta-data android:value=\"你的GENERAL_KEY\" android:name=\"BUG_HD_SDK_GENERAL_KEY\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 调用SDK继承 Application，并在 onCreate() 方法中的第一行加入 FIR.init(this) 123456789public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); FIR.init(this); &#125;&#125; 修改 AndroidManifest.xml，在其中加入 android:name=&quot;xxxx&quot;，使用继承过的的 application 类,例如 12345678&lt;application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; ....&lt;/application&gt; 如上配置归纳,就是3步最后看下分析界面","categories":[{"name":"BugHD","slug":"BugHD","permalink":"https://yangxiaoge.github.io/categories/BugHD/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":"Git语法","slug":"Git语法","date":"2016-08-03T08:13:45.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2016/08/03/Git语法/","link":"","permalink":"https://yangxiaoge.github.io/2016/08/03/Git语法/","excerpt":"本文摘自我的小伙伴KevinJin 开源中国的 Pro Git（中文版） 1、Git基础1.1 分布式版本管理系统常用操作: 克隆远程仓库git clone &lt;/path/to/repository&gt; 查看工作区状态git status","text":"本文摘自我的小伙伴KevinJin 开源中国的 Pro Git（中文版） 1、Git基础1.1 分布式版本管理系统常用操作: 克隆远程仓库git clone &lt;/path/to/repository&gt; 查看工作区状态git status 添加更改到暂存区git add &lt;filename&gt;&nbsp;&nbsp;添加某个文件git add .&nbsp;&nbsp;添加当前目录及子目录所有文件git add -A &nbsp;&nbsp;添加所有改动 使用如下命令以实际提交改动git commit -m &quot;代码提交信息&quot; 分支操作git branch &lt;branch name&gt;&nbsp;&nbsp;新建分支git checkout &lt;branch name&gt;&nbsp;&nbsp;切换到某个分支git branch -d &lt;branch name&gt;&nbsp;&nbsp;删除分支 要合并其他分支（可以是任何远程分支或本地分支）到你的当前分支，执行：git merge &lt;branch&gt;&nbsp;&nbsp;//git merge devgit merge origin/dev 获取远程仓库改动git fetch &lt;remote&gt;&nbsp;&nbsp;//git fetch origin 获取远程仓库改动，同时合并（merge）到当前分支git pull &lt;remote&gt; &lt;branch&gt;&nbsp;&nbsp;//git pull origin dev&nbsp;&nbsp;获取远程仓库origin的dev分支，合并到当前分支 推送当前分支到远程仓库git push &lt;remote&gt; &lt;branch&gt;&nbsp;&nbsp;//git push origin dev&nbsp;&nbsp;推送当前分支到远程仓库origin的dev分支 1.2 Git初始化，创建一个新的本地仓库安装git后，配置自己的个人信息git config --global user.name &quot;KevinJin614&quot;git config --global user.email &quot;***@qq.com&quot;创建新文件夹，打开，然后执行git init git addgit commit以创建新的 git 仓库 1.3 Git暂存区你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是暂存区（Index）,它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。HEAD和分支都是引用。使用git status [-s] 查看工作区状态，添加-s参数以精简模式显示 当执行git reset HEAD命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。 当执行git rm --cached &lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行git checkout.或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行git checkout HEAD .或者git checkout HEAD &lt;file&gt;命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 1.4 git diff 工作区和暂存区比较git diff [--] [&lt;path&gt;…] 暂存区和某次提交（如HEAD）比较git diff --cached [&lt;commit&gt;] [--] [&lt;path&gt;…] 工作区和某次提交（如HEAD）比较git diff [&lt;commit&gt;] [--] [&lt;path&gt;…] 比较任意两次commit之间的改动git diff &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;] 所有的diff都可以用difftool替代 1.5 git reset重置暂存区git resetgit reset --hard HEAD^ 重置命令（git reset）是Git最常用的命令之一，也是最危险，最容易误用的命令。来看看git reset命令的用法。用法一：git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...用法二：git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 上面列出了两个用法，其中 都是可选项，可以使用引用或者提交ID，如果省略 则相当于使用了HEAD的指向作为提交ID。上面列出的两种用法的区别在于，第一种用法在命令中包含路径。为了避免路径和引用（或者提交ID）同名而冲突，可以在前用两个连续的短线（减号）作为分隔。 第一种用法（包含了路径的用法）不会重置引用，更不会改变工作区，而是用指定提交状态（）下的文件（）替换掉暂存区中的文件。例如命令git reset HEAD 相当于取消之前执行的git add 命令时改变的暂存区。 第二种用法（不使用路径的用法）则会重置引用。根据不同的选项，可以对暂存区或者工作区进行重置。参照下面的版本库模型图，来看一看不同的参数对第二种重置语法的影响。 命令格式: git reset [--soft | --mixed | --hard ] [&lt;commit&gt;] 使用参数–hard，如：git reset --hard &lt;commit&gt;会执行上图中的1、2、3全部的三个动作。即： 替换引用的指向。引用指向新的提交ID。 替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD所指向的目录树内容相同。 使用参数–soft，如:git reset --soft &lt;commit&gt;会执行上图中的操作1。即只更改引用的指向，不改变暂存区和工作区。 使用参数–mixed或者不使用参数（缺省即为–mixed），如:git reset &lt;commit&gt;会执行上图中的操作1和操作2。即更改引用的指向以及重置暂存区，但是不改变工作区。下面通过一些示例，看一下重置命令的不同用法。 命令：git reset仅用HEAD指向的目录树重置暂存区，工作区不会受到影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。 命令：git reset HEAD同上。 命令：git reset -- filename仅将文件filename撤出暂存区，暂存区中其他文件不改变。相当于对命令git add filename的反向操作。 命令：git reset HEAD filename同上。 命令：git reset --soft HEAD^工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或者提交的更改不满意时，撤销最新的提交以便重新提交。在之前曾经介绍过一个修补提交命令git commit --amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补提交命令实际上相当于执行了下面两条命令。（注：文件.git/COMMIT_EDITMSG保存了上次的提交日志）$ git reset --soft HEAD^$ git commit -e -F .git/COMMIT_EDITMSG 命令：git reset HEAD^工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。 命令：git reset --mixed HEAD^同上。 命令：git reset --hard HEAD^彻底撤销最近的提交。引用回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。 1.6 git checkout检出到工作区 检出命令（git checkout）是Git最常用的命令之一，同样也很危险，因为这条命令会重写工作区。用法一： git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...用法二： git checkout [&lt;branch&gt;]用法三： git checkout [-m] [[-b|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] 上面列出的第一种用法和第二种用法的区别在于，第一种用法在命令中包含路径&lt;paths&gt;。为了避免路径和引用（或者提交ID）同名而冲突，可以在&lt;paths&gt;前用两个连续的短线（减号）作为分隔。&gt; 第一种用法的&lt;commit&gt;是可选项，如果省略则相当于从暂存区（index）进行检出。这和上一章的重置命令大不相同：重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区（除非使用–hard参数，否则不重置工作区），而检出命令主要是覆盖工作区（如果&lt;commit&gt;不省略，也会替换暂存区中相应的文件）。 第一种用法（包含了路径&lt;paths&gt;的用法）不会改变HEAD头指针，主要是用于指定版本的文件覆盖工作区中对应的文件。如果省略&lt;commit&gt;，会拿暂存区的文件覆盖工作区的文件，否则用指定提交中的文件覆盖暂存区和工作区中对应的文件。 第二种用法（不使用路径&lt;paths&gt;的用法）则会改变HEAD头指针。之所以后面的参数写作&lt;branch&gt;，是因为只有HEAD切换到一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”的状态。在“分离头指针”状态下的提交不能被引用关联到而可能会丢失。所以用法二最主要的作用就是切换到分支。如果省略&lt;branch&gt;则相当于对工作区进行状态检查。 第三种用法主要是创建和切换到新的分支（&lt;new_branch&gt;），新的分支从&lt;start_point&gt;指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下的引用。关于分支和git checkout命令的这个用法会在后面的章节做具体的介绍。 1.7 文件忽略.gitignore 文件.gitignore的作用范围是其所处的目录及其子目录忽略只对未跟踪文件有效，对于已加入版本库的文件无效 Git的忽略文件的语法规则： 忽略文件中的空行或者以井号（#）开始的行被忽略。 可以使用通配符，参见Linux手册：glob(7)。例如：星号（*）代表任意多字符，问号（?）代表一个字符，方括号（[abc]）代表可选字符范围等。 如果名称的最前面是一个路径分隔符（/），表明要忽略的文件在此目录下，而非子目录的文件。 如果名称的最后面是一个路径分隔符（/），表明要忽略的是整个目录，同名文件不忽略，否则同名的文件和目录都忽略。 通过在名称的最前面添加一个感叹号（!），代表不忽略。 下面的文件忽略示例，包含了上述要点：# 这是注释行 —— 被忽略*.a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 忽略所有以.a 为扩展名的文件。!lib.a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 但是 lib.a 文件或者目录不要忽略，即使前面设置了对 .a 的忽略。/TODO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 只忽略根目录下的 TODO 文件，子目录的 TODO 文件不忽略。build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 忽略所有 build/ 目录下的文件。doc/.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 忽略文件如 doc/notes.txt，但是文件如 doc/server/arch.txt 不被忽略。 1.8 分支管理git branch 查看分支git branch -r 查看远程分支git branch &lt;branch name&gt;创建分支 创建一个叫做“feature_x”的分支，并切换过去：git checkout -b feature_x切换回主分支：git checkout master再把新建的分支删掉：git branch -d feature_x 2、远程版本库 克隆远程仓库git clone &lt;url&gt; 添加远程仓库git remote add &lt;name&gt; &lt;url&gt; 删除远程仓库git remote remove &lt;name&gt;git fetch [remote]git pull [remote [refspec]]= git fetch + git mergegit push [remote] [branch] 快进式推送 git push 强制非快进式推送 git push -f Tracking 从远程分支创建新分支，会直接添加对应的trackinggit checkout -b test origin/master 手动为分支添加trackinggit branch --set-upstream master origin/next git merge git merge &lt;branch&gt;[--no-ff ] Fast forward &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git允许执行快进式合并，添加–no-ff参数强制不使用快 3、最佳实践 保持Working directory clean 长期分支由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分 支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。许多使用 Git 的开发者都喜欢用这种方式来开展工作，比如仅在 master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名 为 develop 或 next 的平行分支，专门用于后续的开发，或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 master 里。这样，在确保这些已完成的特性分支（短期分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前。 特性分支特性分支从develop分支分出，最终必须合并回develop。特性分支（也叫主题分支）用于开发新特性。每个新特性开一个新分支，最终会合并回develop（当特性开发完毕的时候），或者放弃（如果最终决定不开发这 个特性）。特性分支只存在于开发者的仓库中。在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统 里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。我们可以创建特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换 — 因为你的工作分散在不同的分 支里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等 它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。现在我们来看一个实际的例子。请看图，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒 出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续 工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支 dumbidea 做些试验。现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之 作。所以接下来，我们准备抛弃原来的 iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成这样：请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的Git仓库中进行的—完全不涉及与服务器的交互。 提交做小 git保存用户名、密码1.在Windows中添加一个HOME环境变量，值为%USERPROFILE%，如下图：2.在“开始&gt;运行”中打开%Home%，新建一个名为“_netrc”的文件。3.用记事本打开_netrc文件，输入Git服务器名、用户名、密码，并保存。示例如下machine github.comlogin 用户名password 密码 配置git mergetool和git difftool通过git config命令配置difftool:git config --global diff.tool bcgit config --global difftool.bc.cmd &quot;\\&quot;c:/program files/beyond compare 3/bcomp.exe\\&quot; \\&quot;\\$LOCAL\\&quot; \\&quot;\\$REMOTE\\&quot;&quot;git config --global difftool.prompt false配置mergetool:git config --global merge.tool bcgit config --global mergetool.bc.cmd &quot;\\&quot;c:/program files/beyond compare 3/bcomp.exe\\&quot; \\&quot;\\$LOCAL\\&quot; \\&quot;\\$REMOTE\\&quot; \\&quot;\\$BASE\\&quot; \\&quot;\\$MERGED\\&quot;&quot;git config --global mergetool.bc.trustExitCode true不生成备份文件git config --global mergetool.keepBackup false直接修改%USERPROFILE%.gitconfig文件，完整文件如下：[user]&nbsp;&nbsp;&nbsp;&nbsp;name = 用户名&nbsp;&nbsp;&nbsp;&nbsp;email = 邮箱[diff]&nbsp;&nbsp;&nbsp;&nbsp;tool = bc[difftool &quot;bc&quot;]&nbsp;&nbsp;&nbsp;&nbsp;cmd = \\&quot;C:/bc4/BCompare.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot;[difftool]&nbsp;&nbsp;&nbsp;&nbsp;prompt = false[merge]&nbsp;&nbsp;&nbsp;&nbsp;tool = bc[mergetool &quot;bc&quot;]&nbsp;&nbsp;&nbsp;&nbsp;cmd = \\&quot;C:/bc4/BCompare.exe\\&quot; \\&quot;$LOCAL\\&quot; \\&quot;$REMOTE\\&quot; \\&quot;$BASE\\&quot; \\&quot;$MERGED\\&quot;&nbsp;&nbsp;&nbsp;&nbsp;trustExitCode = true[mergetool]&nbsp;&nbsp;&nbsp;&nbsp;keepBackup = false 4、其他特性 git rebase git stash detached head 分离的头指针 git reflog","categories":[{"name":"Git","slug":"Git","permalink":"https://yangxiaoge.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangxiaoge.github.io/tags/Git/"}]},{"title":"实现多行多列的RadioButton","slug":"实现多行多列的RadioButton","date":"2016-08-02T10:21:33.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/08/02/实现多行多列的RadioButton/","link":"","permalink":"https://yangxiaoge.github.io/2016/08/02/实现多行多列的RadioButton/","excerpt":"由于最近的项目中多处需要用到多行多列的RadioButton,而google原生的RadioGroup又不能实现!因此就要自己动手实现了~ 注意:这里所说的RadioButton都是在代码中动态添加的! 看下效果图:","text":"由于最近的项目中多处需要用到多行多列的RadioButton,而google原生的RadioGroup又不能实现!因此就要自己动手实现了~ 注意:这里所说的RadioButton都是在代码中动态添加的! 看下效果图: 开始造轮子: 分为四步重写RadioGroup–&gt;目的是使 RadioButton可以自动换行布局中引用MyRadioGroupAuto代码中根据数据动态添加RadioButton,然后MyRadioGroup通过addView把RadioButton加进去 这里需要讲下RadioButton的几个属性 radioButton.setPadding(20, 0, screenWidth / 6, 0);// 设置文字距离按钮图片四周的距离 radioButton.setButtonDrawable(R.drawable.transfer_radiobutton_drawable); //点击效果 radioButton.setTag(loanAndFeeList.get(i)); // 设置tag,可以存一些数据 radioButton.setTextSize(13); //默认单位是 sp radioButton.setHeight(50); //默认单位是px RadioButton clickRadioButton = (RadioButton) radioGroup.findViewById(checkedId); //通过RadioGroup对象获取点击的RadioButton组件 设置RadioGroup点击事件下面直接上代码: 三步自定义MyRadioGroupAuto12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Author: 0027008122 [yang.jianan@zte.com.cn] * Time: 2016-08-02 11:33 * Version: 1.0 * TaskId: * Description: */ public class MyRadioGroupAuto extends RadioGroup &#123; public MyRadioGroupAuto(Context context) &#123; super(context); &#125; public MyRadioGroupAuto(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //获取最大宽度 int maxWidth = MeasureSpec.getSize(widthMeasureSpec); //获取Group中的Child数量 int childCount = getChildCount(); //设置Group的左边距，下面也会使用x计算每行所占的宽度 int x = 0; //设置Group的上边距，下面也会使用y计算Group所占的高度 int y = 30; //设置Group的行数 int row = 0; for (int index = 0; index &lt; childCount; index++) &#123; final View child = getChildAt(index); if (child.getVisibility() != View.GONE) &#123; child.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED); //重新计算child的宽高 int width = child.getMeasuredWidth(); int height = child.getMeasuredHeight(); //添加到X中，(width+10) 设置child左边距 x += (width + 10); //行数*child高度+这次child高度=现在Group的高度,(height + 10)设置child上边距 y = row * (height + 10) + (height + 10); //当前行宽X大于Group的最大宽度时，进行换行 if (x &gt; maxWidth) &#123; //当index不为0时，进行row++，防止FirstChild出现大于maxWidth时,提前进行row++ if (index != 0) row++; //child的width大于maxWidth时，重新设置child的width为最大宽度 if (width &gt;= maxWidth) &#123; width = maxWidth - 30; &#125; //重新设置当前X x = (width + 20); //重新设置现在Group的高度 y = row * (height + 10) + (height + 10); &#125; &#125; &#125; // 设置容器所需的宽度和高度 setMeasuredDimension(maxWidth, y); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; final int childCount = getChildCount(); int maxWidth = r - l; int x = 10; int y = 0; int row = 0; for (int i = 0; i &lt; childCount; i++) &#123; final View child = this.getChildAt(i); if (child.getVisibility() != View.GONE) &#123; int width = child.getMeasuredWidth(); int height = child.getMeasuredHeight(); x += (width + 10); y = row * (height + 10) + (height + 10); if (x &gt; maxWidth) &#123; if (i != 0) row++; if (width &gt;= maxWidth) &#123; width = maxWidth - 30; &#125; x = (width + 20); y = row * (height + 10) + (height + 10); &#125; child.layout(x - width, y - height, x, y); &#125; &#125; &#125;&#125; 布局中引用MyRadioGroupAuto123456789&lt;com.ztesoft.zsmart.datamall.app.widget.MyRadioGroupAuto android:id=\"@+id/my_radio_group_auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"33dp\" android:layout_marginLeft=\"22dp\" android:layout_marginRight=\"22dp\" android:layout_marginTop=\"16dp\"&gt;&lt;/com.ztesoft.zsmart.datamall.app.widget.MyRadioGroupAuto&gt; 代码中动态添加RadioButton123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class CheckboxRadiobuttonDemo extends Activity &#123; /** * Called when the activity is first created. */ private RadioGroupAuto rgp; private RadioGroup yuansheng; private String[] loanList; private String[] loanFeeList; private List&lt;String&gt; loanAndFeeList; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); //获取屏幕信息 DisplayMetrics dm = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(dm); int screenWidth = dm.widthPixels; loanAndFeeList = new ArrayList&lt;&gt;(); loanList = \"800,1000,1600,200,300,500,700\".split(\",\"); loanFeeList = \"50,80,100,20,30,50,70\".split(\",\"); //求最大最小值 (为了保持RadioButton文字长度一致,跟最长的保持一致!) int max = Integer.parseInt(loanList[0]); int min = Integer.parseInt(loanList[0]); for (String i : loanList) &#123; int j = Integer.parseInt(i); max = max &gt; j ? max : j; min = min &lt; j ? min : j; &#125; String maxS = String.valueOf(max); int maxLen = maxS.length(); for (int i = 0; i &lt; loanList.length; i++) &#123; loanAndFeeList.add( loanList[i] + \",\" + loanFeeList[i]); &#125; rgp = (RadioGroupAuto) findViewById(R.id.RadioGroup01); int len = loanAndFeeList.size(); for (int j = 0; j &lt; len; j++) &#123; RadioButton radioButton = new RadioButton(this); radioButton.setPadding(20, 0, screenWidth / 6, 0); // 设置文字距离按钮四周的距离 radioButton.setButtonDrawable(R.drawable.transfer_radiobutton_drawable); String newLoanList = loanList[j]; if (loanList[j].length() &lt; maxLen) &#123; newLoanList = newLoanList + appendLength(maxLen - loanList[j].length()); // 实现 TextView同时显示两种风格文字 http://txlong-onz.iteye.com/blog/1142781 SpannableStringBuilder sb = new SpannableStringBuilder(newLoanList); final ForegroundColorSpan fcs = new ForegroundColorSpan(Color.WHITE); sb.setSpan(fcs, loanList[j].length(), maxLen, Spannable.SPAN_INCLUSIVE_INCLUSIVE); radioButton.setText(sb); &#125; else &#123; newLoanList = loanList[j]; radioButton.setText(newLoanList); &#125; radioButton.setId(j); //设置RadioButton的id radioButton.setTag(loanAndFeeList.get(j)); radioButton.setTextSize(13); //默认单位是 sp radioButton.setHeight(50); //默认单位是px rgp.addView(radioButton); //添加到RadioGroup中 &#125; rgp.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; RadioButton clickRadioButton = (RadioButton) group.findViewById(checkedId); String tipInfo = \"id: \" + clickRadioButton.getId() + \" text: \" + clickRadioButton.getText() + /*\"hint: \" + clickRadioButton.getHint() +*/ \" tag:\" + clickRadioButton.getTag(); System.out.println(tipInfo); Toast.makeText(CheckboxRadiobuttonDemo.this, tipInfo, Toast.LENGTH_SHORT).show(); &#125; &#125;); //根据这个来设置默认选中的项, 注意,这个要设置在监听之后!,否则默认点击监听不到!虽然有选中效果 //参考 http://blog.csdn.net/lzqjfly/article/details/16963645 //以及http://stackoverflow.com/questions/9175635/how-to-set-radio-button-checked-as-default-in-radiogroup-with-android rgp.check(0); &#125; /** * 补全长度,保持最长的长度 * * @param count 字符串长度 * @return 补全后的长度 * 这里长度不够的就用 \"s\" 占位, 赋值的时候将字体设置白色! */ public String appendLength(int count) &#123; String st = \"\"; if (count &lt; 0) &#123; count = 0; &#125; for (int i = 0; i &lt; count; i++) &#123; st = st + \"s\"; &#125; return st; &#125;&#125; 总结:碰到的问题: RadioGroup中RadioButton不能互斥解决方法: 需要用RadioGroup.check(id),来设置被默认选中的项，其中id为RadioButton的id，如果动态添加的RadioButton，需要设置好id参考:http://blog.csdn.net/lzqjfly/article/details/16963645 , http://stackoverflow.com/questions/9175635/how-to-set-radio-button-checked-as-default-in-radiogroup-with-android","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":" Android 踩过的坑","slug":"Android-踩过的坑","date":"2016-06-23T03:02:22.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/06/23/Android-踩过的坑/","link":"","permalink":"https://yangxiaoge.github.io/2016/06/23/Android-踩过的坑/","excerpt":"AlertDialog弹出框 按钮在高版本中看不见(其实是颜色为白色) (2016-8-16 18:24:05)在android 6.0中变成了下面这种实际的效果应该是如下的解决方法: 引用v7包下的AlertDialog (android.support.v7.app.AlertDialog)","text":"AlertDialog弹出框 按钮在高版本中看不见(其实是颜色为白色) (2016-8-16 18:24:05)在android 6.0中变成了下面这种实际的效果应该是如下的解决方法: 引用v7包下的AlertDialog (android.support.v7.app.AlertDialog) 最近被异步请求坑了好几次了！(2016-7-28 14:21:18)注意:网络请求是异步的,因此在 response 获取到数据时直接为组件,或者其他用处,直接调用,否则可能由于网络访问速度较慢,导致空指针!因此:在接口成功response之后执行最安全! RadioButton多行队列显示！！！(2016-8-2 18:06:47) 由于原生的RadioGroup只支持横向纵向排列RadioButton,所以只能自己造轮子!详情:见另一篇文章 –&gt; 实现多行多列的RadioButton 当前页面有多个EditText软键盘回车样式一直是Next,导致无法关闭软键盘!(2016-7-27 13:10:39) 可以修改EditText的回车样式，即是把EditText的ImeOptions属性设置成不同的值，Enter键上就会显示不同的文字或图案 1234567891011121314151617181920actionNone : 回车键，按下后光标到下一行actionGo ： Go，actionSearch ： 一个放大镜actionSend ： SendactionNext ： NextactionDone ： Done，隐藏软键盘，即使不是最后一个文本输入框例如:&lt;EditText android:id=\"@+id/transfer_other_edit\" android:layout_width=\"162dp\" android:layout_height=\"@dimen/height_33\" android:layout_marginLeft=\"22dp\" android:background=\"@drawable/card_edittxt_bg\" android:inputType=\"number\" android:paddingLeft=\"@dimen/padding_13\" android:singleLine=\"true\"-----------&gt;android:imeOptions=\"actionDone\" android:textColor=\"#3f3f3f\" android:textSize=\"13sp\"/&gt; 多次点击查询(迅速点击)，listView数据重复（2016-7-25 15:33:44） 单身狗的手速亲测!(；′⌒`) 例如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546RequestApi.qryReachargeHistory(Constants.PREFIX + msisdn, params, new StringCallback() &#123; // ① 只要查询方法执行,那么这里立刻执行。所以如果手速快，就算clear也没用! //rechargeList.clear(); 这里是没用的 @Override public void onResponse(String response) &#123; rechargeList.clear(); // ① 必须此处clear, rechargeList异步执行之前,同一个方法中clear才有效! Logger.json(response); JsonObject obj = new JsonParser().parse(response).getAsJsonObject(); if (!obj.get(\"rechargeList\").toString().equals(\"null\")) &#123; JsonArray jsonArray = obj.get(\"rechargeList\").getAsJsonArray(); for (int i = 0; i &lt; jsonArray.size(); i++) &#123; Map&lt;String, Object&gt; chargeInfo = new HashMap&lt;&gt;(); JsonObject job = (JsonObject) jsonArray.get(i); chargeInfo.put(\"accountNumber\", /*Constants.PREFIX +*/ accountNumber); chargeInfo.put(\"amount\", job.get(\"amount\").getAsString()); chargeInfo.put(\"tradeType\", job.get(\"tradeType\").getAsString()); chargeInfo.put(\"extendDays\", job.get(\"extendDays\").getAsString()); chargeInfo.put(\"tradeTime\", job.get(\"tradeTime\").getAsString()); chargeInfo.put(\"tradeMethod\", job.get(\"tradeMethod\").getAsString()); rechargeList.add(chargeInfo); // ②此处其实是异步的!! &#125; myTopUpHistoryListViewAdapter.notifyDataSetChanged(); if (rechargeList.size() &lt;= 0) &#123; nodataTipsView.setVisibility(View.VISIBLE); rechargeHistoryListview.setVisibility(View.GONE); &#125; else &#123; nodataTipsView.setVisibility(View.GONE); rechargeHistoryListview.setVisibility(View.VISIBLE); &#125; &#125; &#125; @Override public void onError(Request request, Exception e) &#123; if (e != null) &#123; Logger.e(e.getMessage()); &#125; else &#123; Logger.e(\"Exception is null\"); &#125; &#125; &#125;); &#125; 在activity的oncreate方法中使用popupwindow出现以下错误：android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running? 真是醉啦,研究了好久无头绪。 爬完坑后我自己写了个引导的Demo google了好多文章找到了原因，原文链接:http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0304/963.html错误的原因是：popupwindow要依附于一个activity，而activity的onCreate()还没执行完，哪来的popup让你弹出来嘛。解决方法:应把pop.showAtLocation(parent, Gravity.TOP,0, 0)这一句移出oncreate方法，在控件渲染完毕后再使用(按钮点击等时机执行)。 当然还有绝佳的解决方法(其实是不行的, 引导页面一直循环!!!)：123456789101112@Overridepublic void onWindowFocusChanged(boolean hasFocus) &#123; // TODO Auto-generated method stub super.onWindowFocusChanged(hasFocus); if(hasFocus)&#123; newbieGuide(); &#125;&#125;其中newbieGuide()是我自己定义的专门显示popupwindow的一个函数。当activity获得焦点之后，activity是加载完毕的了，这个方法的技巧性比较强，很难想到。`但是`,onWindowFocusChanged方法中这么执行会重复popup,具体要看需求,实在不行就用上面方法(按钮点击执行)!!~","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":"Android ORMLite 框架用法","slug":"Android-ORMLite-框架用法","date":"2016-06-21T06:02:55.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/06/21/Android-ORMLite-框架用法/","link":"","permalink":"https://yangxiaoge.github.io/2016/06/21/Android-ORMLite-框架用法/","excerpt":"本文摘自 鸿神博客,自己偷懒没写,鸿神的写的很详细,他的博客还有 ORMLite 框架最佳实践. 基于鸿神教程运用了ORMLite框架详见我的Github_QueryCityId 转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/39121377 大家在Android项目中或多或少的都会使用数据库，为了提高我们的开发效率，当然少不了数据库ORM框架了，尤其是某些数据库操作特别频繁的app；本篇博客将详细介绍ORMLite的简易用法。","text":"本文摘自 鸿神博客,自己偷懒没写,鸿神的写的很详细,他的博客还有 ORMLite 框架最佳实践. 基于鸿神教程运用了ORMLite框架详见我的Github_QueryCityId 转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/39121377 大家在Android项目中或多或少的都会使用数据库，为了提高我们的开发效率，当然少不了数据库ORM框架了，尤其是某些数据库操作特别频繁的app；本篇博客将详细介绍ORMLite的简易用法。下面开始介绍ORMLite的入门用法~ 下载 ORMLite Jar首先去ORMLite官网下载jar包，对于Android为：ormlite-android-4.48.jar 和 ormlite-core-4.48.jar ； ps:访问不了的朋友，文章末尾会把jar、源码、doc与本篇博客例子一起打包提供给大家下载。 配置Bean类有了jar,我们直接新建一个项目为：zhy_ormlite，然后把jar拷贝到libs下。 然后新建一个包：com.zhy.zhy_ormlite.bean专门用于存放项目中的Bean，首先新建一个User.Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhy.zhy_ormlite.bean;import com.j256.ormlite.field.DatabaseField;import com.j256.ormlite.table.DatabaseTable;@DatabaseTable(tableName = \"tb_user\")public class User&#123; @DatabaseField(generatedId = true) private int id; @DatabaseField(columnName = \"name\") private String name; @DatabaseField(columnName = \"desc\") private String desc; public User() &#123; &#125; public User(String name, String desc) &#123; this.name = name; this.desc = desc; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDesc() &#123; return desc; &#125; public void setDesc(String desc) &#123; this.desc = desc; &#125;&#125; 首先在User类上添加@DatabaseTable(tableName = “tb_user”)，标明这是数据库中的一张表，标明为tb_user然后分别在属性上添加@DatabaseField(columnName = “name”) ，columnName的值为该字段在数据中的列名@DatabaseField(generatedId = true) ，generatedId 表示id为主键且自动生成 编写DAO类原生的数据库操作，需要继承SQLiteOpenHelper，这里我们需要继承OrmLiteSqliteOpenHelper，看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.zhy.zhy_ormlite.db;import java.sql.SQLException;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;import com.j256.ormlite.dao.Dao;import com.j256.ormlite.support.ConnectionSource;import com.j256.ormlite.table.TableUtils;import com.zhy.zhy_ormlite.bean.User;public class DatabaseHelper extends OrmLiteSqliteOpenHelper&#123; private static final String TABLE_NAME = \"sqlite-test.db\"; /** * userDao ，每张表对于一个 */ private Dao&lt;User, Integer&gt; userDao; private DatabaseHelper(Context context) &#123; super(context, TABLE_NAME, null, 2); &#125; @Override public void onCreate(SQLiteDatabase database, ConnectionSource connectionSource) &#123; try &#123; TableUtils.createTable(connectionSource, User.class); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion) &#123; try &#123; TableUtils.dropTable(connectionSource, User.class, true); onCreate(database, connectionSource); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; private static DatabaseHelper instance; /** * 单例获取该Helper * * @param context * @return */ public static synchronized DatabaseHelper getHelper(Context context) &#123; if (instance == null) &#123; synchronized (DatabaseHelper.class) &#123; if (instance == null) instance = new DatabaseHelper(context); &#125; &#125; return instance; &#125; /** * 获得userDao * * @return * @throws SQLException */ public Dao&lt;User, Integer&gt; getUserDao() throws SQLException &#123; if (userDao == null) &#123; userDao = getDao(User.class); &#125; return userDao; &#125; /** * 释放资源 */ @Override public void close() &#123; super.close(); userDao = null; &#125;&#125; 这里我们需要继承OrmLiteSqliteOpenHelper，其实就是间接继承了SQLiteOpenHelper然后需要实现两个方法：1、onCreate(SQLiteDatabase database,ConnectionSource connectionSource)创建表，我们直接使用ormlite提供的TableUtils.createTable(connectionSource, User.class);进行创建~2、onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion)更新表，使用ormlite提供的TableUtils.dropTable(connectionSource, User.class, true);进行删除操作~删除完成后，别忘了，创建操作：onCreate(database, connectionSource); 然后使用单例公布出一个创建实例的方法，getHelper用于获取我们的help实例；最后我们可能会有很多表嘛，每个表一般我们都会单独写个Dao用于操作，这里为了简单我并没有抽取出来，直接写在helper中：比如UserDao的获取：1234567891011121314/** * 获得userDao * * @return * @throws SQLException */ public Dao&lt;User, Integer&gt; getUserDao() throws SQLException &#123; if (userDao == null) &#123; userDao = getDao(User.class); &#125; return userDao; &#125; 然后通过获取到的Dao就可以进行User的一些常用的操作了。 测试最后是测试，我们直接创建了一个测试类进行测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788```package com.zhy.zhy_ormlite.test;import java.sql.SQLException;import java.util.List;import com.zhy.zhy_ormlite.bean.User;import com.zhy.zhy_ormlite.db.DatabaseHelper;import android.test.AndroidTestCase;import android.util.Log;public class OrmLiteDbTest extends AndroidTestCase&#123; public void testAddUser() &#123; User u1 = new User(\"zhy\", \"2B青年\"); DatabaseHelper helper = DatabaseHelper.getHelper(getContext()); try &#123; helper.getUserDao().create(u1); u1 = new User(\"zhy2\", \"2B青年\"); helper.getUserDao().create(u1); u1 = new User(\"zhy3\", \"2B青年\"); helper.getUserDao().create(u1); u1 = new User(\"zhy4\", \"2B青年\"); helper.getUserDao().create(u1); u1 = new User(\"zhy5\", \"2B青年\"); helper.getUserDao().create(u1); u1 = new User(\"zhy6\", \"2B青年\"); helper.getUserDao().create(u1); testList(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void testDeleteUser() &#123; DatabaseHelper helper = DatabaseHelper.getHelper(getContext()); try &#123; helper.getUserDao().deleteById(2); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void testUpdateUser() &#123; DatabaseHelper helper = DatabaseHelper.getHelper(getContext()); try &#123; User u1 = new User(\"zhy-android\", \"2B青年\"); u1.setId(3); helper.getUserDao().update(u1); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public void testList() &#123; DatabaseHelper helper = DatabaseHelper.getHelper(getContext()); try &#123; User u1 = new User(\"zhy-android\", \"2B青年\"); u1.setId(2); List&lt;User&gt; users = helper.getUserDao().queryForAll(); Log.e(\"TAG\", users.toString()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125;````简单测试`了下CURD，使用`AndroidTestCase`记得配置下环境 用起来是不是还是非常方便的，不过还是建议大家例如User的数据库操作，单独抽取出来为UserDao，如下：12345678910111213141516171819202122232425262728package com.zhy.zhy_ormlite.db;import java.sql.SQLException;import android.content.Context;import com.zhy.zhy_ormlite.bean.User;public class UserDao&#123; private Context context; public UserDao(Context context) &#123; this.context = context; &#125; public void add(User user) &#123; try &#123; DatabaseHelper.getHelper(context).getUserDao().create(user); &#125; catch (SQLException e) &#123; &#125; &#125;//......&#125; 注：ORMLite还提供了一些基类ORMLiteBaseActivity，ORMLiteBaseService之类的，便于数据库操作的，这里不做考虑，毕竟项目中很大可能自己也需要继承自己的BaseActvity之类的。 上面简单介绍了如何使用ORMLite框架，Android 快速开发系列 ORMLite 框架的使用 将对其用法进行深入的介绍。 #源码点击下载","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"ORMLite","slug":"ORMLite","permalink":"https://yangxiaoge.github.io/tags/ORMLite/"}]},{"title":"Android shape","slug":"Android-shape","date":"2016-06-20T03:25:51.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/06/20/Android-shape/","link":"","permalink":"https://yangxiaoge.github.io/2016/06/20/Android-shape/","excerpt":"使用shape可以自定义形状，可以定义下面四种类型的形状，通过android:shape 属性指定： rectangle: 矩形，默认的形状，可以画出直角矩形、圆角矩形、弧形等 oval: 椭圆形，用得比较多的是画正圆 line: 线形，可以画实线和虚线 ring: 环形，可以画环形进度条 gradient代表渐变，可以按照如下的使用：","text":"使用shape可以自定义形状，可以定义下面四种类型的形状，通过android:shape 属性指定： rectangle: 矩形，默认的形状，可以画出直角矩形、圆角矩形、弧形等 oval: 椭圆形，用得比较多的是画正圆 line: 线形，可以画实线和虚线 ring: 环形，可以画环形进度条 gradient代表渐变，可以按照如下的使用：12345&lt;gradient android:angle=\"0\" android:centerColor=\"#ff0f00\" android:endColor=\"#ff00ff\" android:startColor=\"#00ff00\" /&gt; solid代表实心，可以按照如下的使用：12345&lt;stroke android:width=\"10dp\" android:color=\"#00FFFF\" android:dashGap=\"5dp\" android:dashWidth=\"5dp\" /&gt; corners代表圆角，可以按照如下的使用：1&lt;corners android:radius=\"5dp\" /&gt; 看下完整的shape(drawable/…xml)文件:123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" 四种类型 &gt; &lt;!-- 渐变 --&gt; &lt;gradient android:angle=\"0\" android:centerColor=\"#ff0f00\" android:endColor=\"#ff00ff\" android:startColor=\"#00ff00\" /&gt; &lt;!-- 实心 --&gt; &lt;solid android:color=\"#F0FFFF\" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=\"10dp\" android:color=\"#00FFFF\" android:dashGap=\"5dp\" android:dashWidth=\"5dp\" /&gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=\"100dp\" /&gt;&lt;/shape&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":"AthenaMI项目启动","slug":"Athena项目启动","date":"2016-06-03T08:49:28.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2016/06/03/Athena项目启动/","link":"","permalink":"https://yangxiaoge.github.io/2016/06/03/Athena项目启动/","excerpt":"今日已完成工作 (2016-06-03 16:49:28) 登录界面( 国际化 ) 首页底部Tab设计完成 侧滑Drawerlayout( Google官方Demo满足需求 ) 公司项目 不能上截图 (～￣▽￣)～","text":"今日已完成工作 (2016-06-03 16:49:28) 登录界面( 国际化 ) 首页底部Tab设计完成 侧滑Drawerlayout( Google官方Demo满足需求 ) 公司项目 不能上截图 (～￣▽￣)～ 提取公共部分(2016-06-04 15:02:17) 样式 字体 drawable(EditText虚线框等等) 正在马不停蹄的coding... 项目开发完再来补充","categories":[{"name":"APP开发记","slug":"APP开发记","permalink":"https://yangxiaoge.github.io/categories/APP开发记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"MI","slug":"MI","permalink":"https://yangxiaoge.github.io/tags/MI/"}]},{"title":"high起来","slug":"网易music-2016-5-22","date":"2016-05-22T03:28:07.000Z","updated":"2017-05-27T09:28:57.000Z","comments":true,"path":"2016/05/22/网易music-2016-5-22/","link":"","permalink":"https://yangxiaoge.github.io/2016/05/22/网易music-2016-5-22/","excerpt":"","text":"","categories":[{"name":"Music","slug":"Music","permalink":"https://yangxiaoge.github.io/categories/Music/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://yangxiaoge.github.io/tags/Music/"}]},{"title":"使用gradle命令打包apk","slug":"使用gradle命令打包apk","date":"2016-05-16T11:04:04.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2016/05/16/使用gradle命令打包apk/","link":"","permalink":"https://yangxiaoge.github.io/2016/05/16/使用gradle命令打包apk/","excerpt":"前言系统环境：Windows7 Android Studio版本：2.1.1 Gradle版本：2.8 整个过程默认翻墙！ 本文参考了Android Studio系列教程五–Gradle命令详解与导入第三方包，gradle项目构建这两篇博客以及Gradle官网上关于Gradle使用说明。 随着学习的深入，对Gradle的了解也多了些，今天我们就来聊聊如何用Gradle打测试包和正式包（debug与release）。Gradle官网上对Windows平台的Gradle也有描述。感觉学东西还是得多去官网上看看，毕竟上面都讲的非常详细。","text":"前言系统环境：Windows7 Android Studio版本：2.1.1 Gradle版本：2.8 整个过程默认翻墙！ 本文参考了Android Studio系列教程五–Gradle命令详解与导入第三方包，gradle项目构建这两篇博客以及Gradle官网上关于Gradle使用说明。 随着学习的深入，对Gradle的了解也多了些，今天我们就来聊聊如何用Gradle打测试包和正式包（debug与release）。Gradle官网上对Windows平台的Gradle也有描述。感觉学东西还是得多去官网上看看，毕竟上面都讲的非常详细。 下载Gradle与生成APK在Android Studio中的Terminal窗口下输入：gradlew -v 。来查看下项目所用的Gradle版本。如果你是第一次执行会去下载Gradle下载成功后会出现如下信息： 接着输入：gradlew clean。 执行这个命令会去下载Gradle的一些依赖 最后执行：gradlew build。 这个命令会直接编译并生成相应的apk文件，如果看到如下字样就代表build成功了 APK签名关于签名，有两种方法，第一种是在Android Studio菜单栏里中build目录下的Generate signed APK这种图形界面实现。第二种是直接在gradle.build里面通过代码实现;不过两种方法都差不多。在这里我只介绍一下第一种方法。 先执行：gradlew clean 命令，将APK文件清除。 然后执行：radlew build 命令，这个时候注意看Project目录下将出现如下图所示的测试版和未签名的正式版 生成Keystore文件点击Android Studio菜单栏上的build——&gt;Generate signed APK 将出现下图所示的对话框。由于第一次使用还没有创建Keystore文件，所以需要创建一个。 接下来出现如下的对话框，按要求填好信息后，点击OK（注意：请牢记自己设置的密码，等会要用到） 接下来将设置Keystore的存放路径及命名文件名称，该文件后缀默认为jks。点击OK。 生成带签名的正式版APK填写之前设置的密码，点击Next 选择build Type为release，点击finish 接下来你将看到Project目录下多了一个带签名的正式版 点击Android Studio中右上角的这个路径提示 大功告成！！ 带签名的正式版以及测试版都在这个文件夹里了。 Gradle常用命令更详细的请Google下 gradlew代表 gradle wrapper，意思是gradle的一层包装，大家可以理解为在这个项目本地就封装了gradle，即gradle wrapper。下面列举了几个常见的命令： gradlew -v：版本号 gradlew clean：把之前打包所产生的所有文件全部清除(注意：和第一次下载Gradle时候的命令相同，但作用不同) gradlew build：检查依赖并编译打包(注意：和第一次下载Gradle时候的命令相同，但作用不同) 这里注意的是 gradlew build命令把debug、release环境的包都打出来，如果正式发布只需要打Release的包，可以使用下面的这两个命令： gradlew assembleDebug 编译并打Debug包 gradlew assembleRelease 编译并打Release的包","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://yangxiaoge.github.io/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangxiaoge.github.io/tags/Gradle/"}]},{"title":"Android中使用Gson解析稍复杂的JSON数据","slug":"Android中使用Gson解析稍复杂的JSON数据","date":"2016-05-05T11:23:35.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/05/05/Android中使用Gson解析稍复杂的JSON数据/","link":"","permalink":"https://yangxiaoge.github.io/2016/05/05/Android中使用Gson解析稍复杂的JSON数据/","excerpt":"摘抄自 http://www.jianshu.com/p/3b8ef7162e69 一、Json简介JSON官网(中文版)：http://www.json.org/json-zh.html JSON(JavaScript Object Notation)是一种轻量级(轻量级？简单、易操作、快捷)的数据交换格式。主要目的就是给出一套通用的数据格式，大家按照这种格式定义自己的数据，方便数据的交换。特点是(相对来说) 易于人阅读和编写，易于机器解析和生成 。","text":"摘抄自 http://www.jianshu.com/p/3b8ef7162e69 一、Json简介JSON官网(中文版)：http://www.json.org/json-zh.html JSON(JavaScript Object Notation)是一种轻量级(轻量级？简单、易操作、快捷)的数据交换格式。主要目的就是给出一套通用的数据格式，大家按照这种格式定义自己的数据，方便数据的交换。特点是(相对来说) 易于人阅读和编写，易于机器解析和生成 。Rules： “名/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 JSON可以有以下格式： 1.对象是一个无序的“ ‘名称/值’ 对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。 2.数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。 以上是最基本的json知识，想深入了解的，请移步官网。 下面举个栗子给大家尝尝：123456789101112131415161718192021&#123; \"type\": \"forecast1d\", \"weatherinfo\": [ &#123; \"city\": \"北京\", \"cityid\": \"1\", \"temp1\": \"22℃\", \"temp2\": \"10℃\", \"weather\": \"晴\", \"ptime\": \"11:00\" &#125;, &#123; \"city\": \"上海\", \"cityid\": \"2\", \"temp1\": \"24℃\", \"temp2\": \"12℃\", \"weather\": \"晴\", \"ptime\": \"11:00\" &#125; ]&#125; 栗子好难看，上截图(截图太小看不清…戳这里看大图)： NOTE：左侧为JSON字符串，右侧为解析结构，方便查看。福利：截图是我在一个在线JSON Editor上截的，体验一下–&gt;JSON Editor，很好用推荐给大家。 二、使用Gson在Android中解析Json认清了JSON，就要解析它。 你可以使用的JSON库： JSONObject(源自Android官方)、Gson(源自Google)、Jackson(第三方开源库)、FastJSON(第三方开源库)、等。。。 本篇文章使用Gson解析JSON，Gson地址：http://code.google.com/p/google-gson/ 无法下载？百度云分享一下http://pan.baidu.com/s/1kTur5xd,提取密码:5oae 根据JSON串的结构定义一个类(这里我们把这个类叫Result)，我们直接把得到的JSON串解析成这个类。class Result定义如下：12345678910111213141516171819202122232425import java.util.List;public class Result &#123; public String type; public List&lt;Info&gt; weatherinfo; public static class Info &#123; public String city; public String cityid; public String temp1; public String temp2; public String weather; public String ptime; &#125;&#125; 定义好了待解析成的class之后，接下来使用Gson解析JSON串就可以了： Gson gson = new Gson();Result r = gson.fromJson(jsonData, Result.class); So easy!难点：如果是Android Studio开发的,用GsonFormat插件可以自动生成JavaBean 如何定义这个待解析成的类？其实很简单，看到JSON结构里面有{ }你就定义一个类，看到[ ]你就定义一个List即可，最后只剩下最简单的如String、int等基本类型直接定义就好。 内部嵌套的类，请使用public static class className { }。 类内部的属性名，必须与JSON串里面的Key名称保持一致。这三点请自行对照我们上面举的Result的栗子，都有对应。","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Json","slug":"Json","permalink":"https://yangxiaoge.github.io/tags/Json/"}]},{"title":"Android常用方法摘记以及收集","slug":"Android-常用方法摘记","date":"2016-01-08T02:50:55.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2016/01/08/Android-常用方法摘记/","link":"","permalink":"https://yangxiaoge.github.io/2016/01/08/Android-常用方法摘记/","excerpt":"获取当前页面 activity 实例 （随便什么地方都可以获取）123456789101112131415161718192021222324//获取当前页面 activity 实例 public static Activity getGlobleActivity() &#123; try &#123; Class activityThreadClass = Class.forName(\"android.app.ActivityThread\"); Object activityThread = activityThreadClass.getMethod(\"currentActivityThread\").invoke(null); Field activitiesField = activityThreadClass.getDeclaredField(\"mActivities\"); activitiesField.setAccessible(true); Map activities = (Map) activitiesField.get(activityThread); for (Object activityRecord : activities.values()) &#123; Class activityRecordClass = activityRecord.getClass(); Field pausedField = activityRecordClass.getDeclaredField(\"paused\"); pausedField.setAccessible(true); if (!pausedField.getBoolean(activityRecord)) &#123; Field activityField = activityRecordClass.getDeclaredField(\"activity\"); activityField.setAccessible(true); Activity activity = (Activity) activityField.get(activityRecord); return activity; &#125; &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; 返回键 app切换至后台12345678910111213@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (mBinding.drawerLayout.isDrawerOpen(GravityCompat.START)) &#123; mBinding.drawerLayout.closeDrawer(GravityCompat.START); &#125; else &#123; // 不退出程序，进入后台 moveTaskToBack(true); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; 调用系统方法弹出, 分享文本图片等(2016-12-06 19:16:43)1234567891011121314151617181920212223242526272829303132/** * Created by _SOLID * Date:2016/4/22 * Time:12:45 * https://github.com/burgessjp/GanHuoIO/blob/master/app/src/main/java/ren/solid/ganhuoio/utils/ShakePictureUtils.java */public class SystemShareUtils &#123; public static void shareText(Context ctx, String text) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.putExtra(Intent.EXTRA_TEXT, text); sendIntent.setType(\"text/plain\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125; public static void shareImage(Context ctx, Uri uri) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.putExtra(Intent.EXTRA_STREAM, uri); sendIntent.setType(\"image/jpeg\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125; public static void shareImageList(Context ctx, ArrayList&lt;Uri&gt; uris) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND_MULTIPLE); sendIntent.putExtra(Intent.EXTRA_STREAM, uris); sendIntent.setType(\"image/*\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125;&#125;","text":"获取当前页面 activity 实例 （随便什么地方都可以获取）123456789101112131415161718192021222324//获取当前页面 activity 实例 public static Activity getGlobleActivity() &#123; try &#123; Class activityThreadClass = Class.forName(\"android.app.ActivityThread\"); Object activityThread = activityThreadClass.getMethod(\"currentActivityThread\").invoke(null); Field activitiesField = activityThreadClass.getDeclaredField(\"mActivities\"); activitiesField.setAccessible(true); Map activities = (Map) activitiesField.get(activityThread); for (Object activityRecord : activities.values()) &#123; Class activityRecordClass = activityRecord.getClass(); Field pausedField = activityRecordClass.getDeclaredField(\"paused\"); pausedField.setAccessible(true); if (!pausedField.getBoolean(activityRecord)) &#123; Field activityField = activityRecordClass.getDeclaredField(\"activity\"); activityField.setAccessible(true); Activity activity = (Activity) activityField.get(activityRecord); return activity; &#125; &#125; &#125; catch (Exception e) &#123; &#125; return null; &#125; 返回键 app切换至后台12345678910111213@Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (mBinding.drawerLayout.isDrawerOpen(GravityCompat.START)) &#123; mBinding.drawerLayout.closeDrawer(GravityCompat.START); &#125; else &#123; // 不退出程序，进入后台 moveTaskToBack(true); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; 调用系统方法弹出, 分享文本图片等(2016-12-06 19:16:43)1234567891011121314151617181920212223242526272829303132/** * Created by _SOLID * Date:2016/4/22 * Time:12:45 * https://github.com/burgessjp/GanHuoIO/blob/master/app/src/main/java/ren/solid/ganhuoio/utils/ShakePictureUtils.java */public class SystemShareUtils &#123; public static void shareText(Context ctx, String text) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.putExtra(Intent.EXTRA_TEXT, text); sendIntent.setType(\"text/plain\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125; public static void shareImage(Context ctx, Uri uri) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.putExtra(Intent.EXTRA_STREAM, uri); sendIntent.setType(\"image/jpeg\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125; public static void shareImageList(Context ctx, ArrayList&lt;Uri&gt; uris) &#123; Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND_MULTIPLE); sendIntent.putExtra(Intent.EXTRA_STREAM, uris); sendIntent.setType(\"image/*\"); ctx.startActivity(Intent.createChooser(sendIntent, \"分享至\")); &#125;&#125; Android调用微信扫一扫和支付宝扫一扫(2016-9-20 19:01:47)摘自:习惯沉默的Blog 现在微信不能直接跳转到微信扫一扫:详见 Android调用微信扫一扫_CSDN Gson构造JsonArray(2016-8-23 16:11:25)最近项目中请求参数传参用到了 JsonArray对象构造方法如下: 123456789Object[] object = new Object[]&#123;\"111\", \"222\", \"24G\"&#125;;JsonArray jsonArr = new JsonArray();for (Object anObject : object) &#123; JsonObject jo = new JsonObject(); //构造json jo.addProperty(\"offerCode\", (String) anObject); jsonArr.add(jo);&#125;Toast.makeText(this, \"jsonArr: \" + jsonArr.toString(), Toast.LENGTH_SHORT).show();System.out.println(\"jsonArr: \" + jsonArr.toString()); 访问或者下载单个github文件(2016-9-20 18:43:37)用途:可以用来存一些配置文件,图片等.url固定格式: https://raw.githubusercontent.com/username/repository/branch/filename例如: https://raw.githubusercontent.com/yangxiaoge/MumuXi/master/README.md 参考stackoverflow:Download single files from GitHub LICEcap录制Gif工具(2016-8-2 18:57:50)官网地址 读取Assets( 下面 cityId查询天气 中的是另一种读取方法)目录下文件(2016-06-12)例如: 简书:http://www.jianshu.com/p/b87fee2f7a23 1234567InputStreamReader isr = new InputStreamReader(this.getClass() .getClassLoader() .getResourceAsStream(\"assets/\" + \"student.json\") ,\"utf-8\" );//从assets获取json文件BufferedReader bfr = new BufferedReader(isr); cityId查询天气(2016-6-20 19:00:35) citycode.txt是cityid文件(数据 101190101=南京 ) 下面代码是 逐行根据”=”分隔符,读写城市id跟name,可以写到文件中 123456789101112131415161718192021222324252627/** * 根据城市名找到对应的id如果没有则说明在中国气象网不存在该城市 * * @param cityname * @return */ private String findId(String cityname) &#123; if (null == cityname || \"\".equals(cityname)) return null; try &#123; InputStreamReader inputReader = new InputStreamReader(getResources().getAssets().open(\"citycode.txt\")); BufferedReader bufReader = new BufferedReader(inputReader); String line = \"\"; String[] str = new String[2]; while ((line = bufReader.readLine()) != null) &#123; str = line.split(\"=\"); if (str.length == 2 &amp;&amp; null != str[1] &amp;&amp; !\"\".equals(str[1]) &amp;&amp; cityname.equals(str[1])) &#123; //返回对应city编号 return str[0]; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; return null; &#125; 双击两次返回键退出 (2秒内退出)1234567891011121314151617181920212223private long exitTime = 0; // 返回键 退出时间 /** * 返回键 (2秒内退出) * @param keyCode 返回键code * @param event keyEvent * @return true */ @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; //两秒之内按返回键就会退出 if (System.currentTimeMillis() - exitTime &gt; 2000) &#123; Toast.makeText(this, \"再按一次退出\", Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); &#125; return true; // 不要忘记 return true &#125; return super.onKeyDown(keyCode, event);&#125; 下面是点击返回键 关闭DrawerLayout等等12345678910111213141516171819202122232425262728293031323334/** * 系统返回键监听,事件处理 * @return */ @Override public void onBackPressed() &#123; HomeViewPagerFragment homeFragment = null; boolean isDrawerOpen = false; boolean isPopFragment = false; String currentTabTag = mTabHost.getCurrentTabTag(); String homeName = getResources().getString(MainTab.HOME.getResName()); String bundleName = getResources().getString(MainTab.BUNDLES.getResName()); String billName = getResources().getString(MainTab.BILL.getResName()); if (currentTabTag.equals(bundleName)) &#123; isPopFragment = ((BaseContainerFragment)getSupportFragmentManager().findFragmentByTag(bundleName)).popFragment(); &#125; else if (currentTabTag.equals(billName)) &#123; isPopFragment = ((BaseContainerFragment)getSupportFragmentManager().findFragmentByTag(billName)).popFragment(); &#125; if(currentTabTag.equals(homeName))&#123; homeFragment= ((HomeViewPagerFragment)getSupportFragmentManager().findFragmentByTag(homeName)); isDrawerOpen = homeFragment.isDrawerOpen(); &#125; if(isDrawerOpen)&#123; homeFragment.closeDrawer(); &#125;else if(!isPopFragment)&#123; finish(); &#125;&#125; RadioButton 点击事件 (2016-06-08) 借助ButterKnife快速实现 123456@OnCheckedChanged(&#123;R.id.searchRb1, R.id.searchRb2, R.id.searchRb3, R.id.searchRb4&#125;)void onTagChecked(RadioButton searchRb, boolean checked) &#123; if (checked) &#123; //实现代码... &#125;&#125; 夜神 模拟器连接(2016-6-22 13:44:46)流畅度杠杆的!1adb connect 127.0.0.1:62001 Fiddler抓包设置: 具体参考👉trinea分享1)2)(实验证明已经不需要这一步了,只要设置好代理服务器主机名就行了!! add 2016-8-16 16:09:01) 模拟器浏览器打开: http://10.45.16.34:8888/(10.45.16.34就是本机地址, 所有模拟器都是这么访问) 海马玩 模拟器连接(2016-06-14) http://www.jianshu.com/p/c2e6a4e7e9c4/comments/2742091#comment-27420911adb connect 127.0.0.1:26944 抓包设置: 代理服务器主机名: 10.0.3.2 (genymotion也是这个), 夜神的是电脑ip app启动页面(AlphaAnimation渐变) (2016-06-14)效果图: 完整代码如下↓↓↓↓↓↓ 1234567891011121314151617181920212223242526272829303132333435public class StartActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); final View view = View.inflate(this, R.layout.activity_start, null); setContentView(view); // 渐变展示启动屏 , 0.0-1.0 透明到不透明 AlphaAnimation aa = new AlphaAnimation(0.1f, 1.0f); aa.setDuration(3000); view.startAnimation(aa); aa.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationEnd(Animation animation) &#123; // 动画结束跳转登陆界面 redirectTo(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationStart(Animation animation) &#123; &#125; &#125;); &#125; private void redirectTo() &#123; Intent intent = new Intent(this, LoginActivity.class); startActivity(intent); finish(); &#125;&#125; adapter中setTag()的使用可以用来当前方法中传数据 1234567891011121314151617181920@Override public View getView(final int position, View convertView, ViewGroup parent) &#123; final ViewHolder holder; if (convertView == null) &#123; holder = new ViewHolder(); convertView = LayoutInflater.from(context).inflate(R.layout.temp, parent, false); holder.nameTv = (TextView) convertView.findViewById(R.id.name); holder.group = (RadioGroup) convertView.findViewById(R.id.group); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; HashMap&lt;String, Object&gt; map = getItem(position); map.put(\"position\", position);---&gt; holder.group.setTag(map); // 通过group视图设置setTag(map) ... ... ...---&gt; HashMap&lt;String, Object&gt; radioMap = (HashMap&lt;String, Object&gt;) group.getTag(); // getTag() Gson把JsonArray的字符串转成bean实体类123456String offerItemGroupStr;JsonArray array = (JsonArray) new JsonParser().parse(offerItemGroupStr); List&lt;OfferItemGroup&gt; offerDepGroupsList = new Gson().fromJson(array.toString(), new TypeToken&lt;List&lt;OfferItemGroup&gt;&gt;() &#123; &#125;.getType()); 圆形进度条(2016-7-1 13:20:24) week开源啦!! alibaba-week入口 保存图片到本地文件(2016-7-11 12:35:51)参考: Mumuxi代码 123456789101112131415161718192021222324252627282930313233343536373839/** * Created by allen on 2016/6/19. * * Here reference is https://github.com/gaolonglong/GankGirl/blob/master/app/src/main/java/com/app/gaolonglong/gankgirl/util/ImageUtil.java */public class ImgSaveUtil &#123; public static Uri saveImage(Context context, String url, Bitmap bitmap, ImageView imageView, String tag)&#123; //妹纸保存路径 String imgDir = Environment.getExternalStorageDirectory().getPath() + \"/GankGirl\"; //图片名称处理 String[] fileNameArr = url.substring(url.lastIndexOf(\"/\") + 1).split(\"\\\\.\"); String fileName = fileNameArr[0] + \".png\"; //创建文件路径 File fileDir = new File(imgDir); if (!fileDir.exists())&#123; fileDir.mkdir(); &#125; //创建文件 File imageFile = new File(fileDir,fileName); try &#123; FileOutputStream fos = new FileOutputStream(imageFile); boolean compress = bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos); Snackbar.make(imageView,\"妹纸已经躺在你的图库里啦.. ( ＞ω＜)\", Snackbar.LENGTH_SHORT).show(); fos.flush(); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Uri uri = Uri.fromFile(imageFile); //发送广播，通知图库更新 context.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri)); return uri; &#125;&#125; 样式统一设置 (2016-7-12 15:06:40) 例如: 123456789101112131415&lt;!--全边框 输入框样式--&gt; &lt;style name=\"edittext_style\"&gt; &lt;item name=\"android:layout_width\"&gt;match_parent&lt;/item&gt; &lt;item name=\"android:layout_height\"&gt;wrap_content&lt;/item&gt; &lt;item name=\"android:layout_marginLeft\"&gt;@dimen/space_20&lt;/item&gt; &lt;item name=\"android:layout_marginRight\"&gt;@dimen/space_20&lt;/item&gt; &lt;item name=\"android:layout_marginTop\"&gt;@dimen/space_10&lt;/item&gt; &lt;item name=\"android:background\"&gt;@drawable/input_bg&lt;/item&gt; &lt;item name=\"android:singleLine\"&gt;true&lt;/item&gt; &lt;/style&gt; &lt;!--只有底边边框 输入框样式--&gt; &lt;style name=\"edittext_style1\" parent=\"edittext_style\"&gt; &lt;item name=\"android:background\"&gt;?attr/editTextBackground&lt;/item&gt; &lt;/style&gt; touch事件监听之tab页再次点击刷新数据 (2016-7-15 14:23:06) 具体可以看 开源中国源码: MainActivity中 1234567891011121314151617181920@Override public boolean onTouch(View v, MotionEvent event) &#123; super.onTouchEvent(event); boolean consumed = false; // use getTabHost().getCurrentTabView to decide if the current tab is // touched again if (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; v.equals(mTabHost.getCurrentTabView())) &#123; // use getTabHost().getCurrentView() to get a handle to the view // which is displayed in the tab - and to get this views context Fragment currentFragment = getCurrentFragment(); if (currentFragment != null &amp;&amp; currentFragment instanceof OnTabReselectListener) &#123; OnTabReselectListener listener = (OnTabReselectListener) currentFragment; listener.onTabReselect(); consumed = true; &#125; &#125; return consumed; &#125; ProgressDialog使用:例如登录等待时 (2016-7-15 14:55:24)下面的代码可以参考 Afrimax或者MPT的[BaseActivity](https://coding.net/u/yangxiaoge/p/AfrimaxMI/git/blob/master/app/src/main/java/com/ztesoft/zsmart/datamall/app/base/BaseActivity.java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// =======================DIALOG_CONTROL_INTERFACE START======================== // dialog 是否处于可见状态 private boolean _isVisible; private ProgressDialog _waitDialog; @Override public void hideWaitDialog() &#123; if (_isVisible &amp;&amp; _waitDialog != null) &#123; try &#123; _waitDialog.dismiss(); _waitDialog = null; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; @Override public ProgressDialog showWaitDialog() &#123; return showWaitDialog(R.string.loading); &#125; @Override public ProgressDialog showWaitDialog(int resid) &#123; return showWaitDialog(getString(resid)); &#125; /** * 显示耗时操作等待弹出框 * * @param message 提示消息 * @return ProgressDialog */ @Override public ProgressDialog showWaitDialog(String message) &#123; if (_isVisible) &#123; if (_waitDialog == null) &#123; _waitDialog = DialogHelp.getWaitDialog(this, message); &#125; else if (_waitDialog != null) &#123; _waitDialog.setMessage(message); &#125; _waitDialog.show(); return _waitDialog; &#125; return null; &#125; // =======================DIALOG_CONTROL_INTERFACE END========================== 远程调试App或者WiFi调试(2016-7-19 19:34:09) http://www.jianshu.com/p/e9c243b5060b ScrollView初始化数据时不置顶(2016-7-20 16:36:01) ScrollView布局设置一个属性即可!如果不设置,那么默认显示位置在ListView(等等..)底部具体可以参考: ScrollView嵌套ListView不置顶显示1mScrollView.smoothScrollTo(0, 0); 使用BroadCast发送广播,通知home页刷新数据(2016-7-29 13:05:32)1234567891011121314151617181920212223242526272829 //----------------发送广播 , intent传值--------------// private void sendRefreshAccountBroadcast() &#123; Intent intent = new Intent(Constants.REFRESH_HOME_ACCOUNT_LIST); intent.putExtra(Constants.REFRESH_HOME_ACCOUNT_LIST, true); getBaseContext().sendBroadcast(intent); &#125; //----------------------接收广播 start------------------// private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getBooleanExtra(Constants.REFRESH_HOME_ACCOUNT_LIST, false)) &#123; // 刷新数据 initExpendListViewData(); &#125; &#125; &#125;; @Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注册广播监听 IntentFilter filter = new IntentFilter(Constants.REFRESH_HOME_ACCOUNT_LIST); getActivity().registerReceiver(mReceiver, filter); &#125;//-------------------接收广播 end------------------------// EditText数据监听!登录模块,动态搜索模块等(2016-7-30 14:29:58)12345678910111213141516171819202122232425262728293031323334353637etUsertel.addTextChangedListener(new TextChange()); etPassword.addTextChangedListener(new TextChange());// EditText监听器 class TextChange implements TextWatcher &#123; @Override public void afterTextChanged(Editable arg0) &#123; &#125; @Override public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) &#123; &#125; @Override public void onTextChanged(CharSequence cs, int start, int before, int count) &#123; boolean Sign2 = et_usertel.getText().length() &gt; 0; boolean Sign3 = et_password.getText().length() &gt; 0; // 设置登录按钮的颜色,以及是否可点击! if (Sign2 &amp; Sign3) &#123; btnLogin.setTextColor(0xFFFFFFFF); btnLogin.setEnabled(true); &#125; // 在layout文件中，对Button的text属性应预先设置默认值，否则刚打开程序的时候Button是无显示的 else &#123; btnLogin.setTextColor(0xFFD0EFC6); btnLogin.setEnabled(false); &#125; &#125; &#125; AS快捷键(2016-8-2 18:58:02)","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":"Birt级联参数设置","slug":"Birt级联参数设置","date":"2015-09-06T08:05:45.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2015/09/06/Birt级联参数设置/","link":"","permalink":"https://yangxiaoge.github.io/2015/09/06/Birt级联参数设置/","excerpt":"级联查询步骤: 1, 创建级联参数 2, 设置相关联的参数","text":"级联查询步骤: 1, 创建级联参数 2, 设置相关联的参数 3, 每一个参数都要单独设置 display type 4, 数据集设计 __详情有道云笔记","categories":[{"name":"Birt","slug":"Birt","permalink":"https://yangxiaoge.github.io/categories/Birt/"}],"tags":[{"name":"Birt","slug":"Birt","permalink":"https://yangxiaoge.github.io/tags/Birt/"}]},{"title":"Birt多选参数设置","slug":"Birt多选参数设置","date":"2015-09-06T07:38:39.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2015/09/06/Birt多选参数设置/","link":"","permalink":"https://yangxiaoge.github.io/2015/09/06/Birt多选参数设置/","excerpt":"网上相关的资料少之又少,某度搜的博客更是不能信(互相抄)!不扯了,直接看多选参数设置 效果图: 具体实现步骤:","text":"网上相关的资料少之又少,某度搜的博客更是不能信(互相抄)!不扯了,直接看多选参数设置 效果图: 具体实现步骤: 1. 勾选 Allow Multiple Values 并设置默认值 2. 脚本中注意要判断取值( toString() 之后)更多Birt报表知识点详见个人笔记: 有道云笔记Birt总结文档","categories":[{"name":"Birt","slug":"Birt","permalink":"https://yangxiaoge.github.io/categories/Birt/"}],"tags":[{"name":"Birt","slug":"Birt","permalink":"https://yangxiaoge.github.io/tags/Birt/"}]},{"title":"Git使用","slug":"Git使用","date":"2015-06-24T05:12:52.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2015/06/24/Git使用/","link":"","permalink":"https://yangxiaoge.github.io/2015/06/24/Git使用/","excerpt":"git回滚到指定版本方法(2016-01-08 14:55:44)1234git reset --hard &lt;commit ID号&gt;例如: git reset --hard dc972ec版本号查看方法: 打开github项目，点击commits就能看到提交记录以及版本号","text":"git回滚到指定版本方法(2016-01-08 14:55:44)1234git reset --hard &lt;commit ID号&gt;例如: git reset --hard dc972ec版本号查看方法: 打开github项目，点击commits就能看到提交记录以及版本号 提交本地项目(未受控)到远程Git仓库12345git initgit add .git commit -m \"first commit\"git remote add origin https://git.coding.net/yangxiaoge/Gank.gitgit push -u origin master git add .: add后面有空格","categories":[{"name":"Git","slug":"Git","permalink":"https://yangxiaoge.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yangxiaoge.github.io/tags/Git/"}]},{"title":"MumuXi安卓版开发","slug":"MumuXi安卓版开发","date":"2015-05-23T03:37:37.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2015/05/23/MumuXi安卓版开发/","link":"","permalink":"https://yangxiaoge.github.io/2015/05/23/MumuXi安卓版开发/","excerpt":"这也是自己第一个算是正式的练手App项目 MumuXi 目的: 督促自己不断积累知识经验。下面进入正文 准备工作 Android Studio Gank Api (gank.io/api 由 代码家维护的开源Api) N多依赖jar包 学习CaMnter/EasyGank完成的项目 开发准备 框架搭建 界面原型设计 主要功能","text":"这也是自己第一个算是正式的练手App项目 MumuXi 目的: 督促自己不断积累知识经验。下面进入正文 准备工作 Android Studio Gank Api (gank.io/api 由 代码家维护的开源Api) N多依赖jar包 学习CaMnter/EasyGank完成的项目 开发准备 框架搭建 界面原型设计 主要功能 完成功能: 知乎专栏-作者文章-文章detail 妹子福利 about_me-换头像 about_app-app开发目的,以及使用的框架 for_what-是目标功能(有的还没实现) 所有的loading动画用的是开源框架- 布局放在了EasyRecyclerView的 layout_empty ,layout_progress,error中,具体根据实际来放 上拉,下拉刷新用的开源框架EasyRecyclerView-侧滑Drawer功能还没加,后面考虑加些其他功能~~~ 项目详细 注解 以及功能在github提交的message和代码注解中 经过一个星期的折腾,终于完成了第一个版本,并且试着上架了应用商城! O(∩_∩)O~~ 下载 add google analytics谷歌分析 ( 2016-9-5 11:58:26 ) google-services.json文件下载 官方集成文档: https://developers.google.com/analytics/devguides/collection/android/v4/app?configured=true 分析用户使用情况的平台: https://analytics.google.com/analytics/web/#realtime/rt-app-overview/a83624565w124744507p129062318/ 说明下:(add in 2016-9-28 14:08:13 ) 以下说明摘自小米开放平台Google为APK定义了两个属性：VersionCode和VersionName，他们有不同的用途。VersionCode：对消费者不可见，仅用于应用市场、程序内部识别版本，判断新旧等用途。VersionName：展示给消费者，消费者会通过它认知自己安装的版本。","categories":[{"name":"APP开发记","slug":"APP开发记","permalink":"https://yangxiaoge.github.io/categories/APP开发记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Gank","slug":"Gank","permalink":"https://yangxiaoge.github.io/tags/Gank/"}]},{"title":"Android Studio常用的引用jar整理 for 自用","slug":"Android-studio常用的引用jar整理-for-自用","date":"2015-05-10T07:29:50.000Z","updated":"2017-09-20T01:41:45.592Z","comments":true,"path":"2015/05/10/Android-studio常用的引用jar整理-for-自用/","link":"","permalink":"https://yangxiaoge.github.io/2015/05/10/Android-studio常用的引用jar整理-for-自用/","excerpt":"1. orhanobut/logger123456789101112allprojects &#123; repositories &#123; jcenter() // 项目gradle中添加 jitpack仓库 maven &#123; url \"https://jitpack.io\" &#125; &#125;&#125;dependencies &#123; // moudle/gradle中添加 compile 'com.github.orhanobut:logger:1.12'&#125;","text":"1. orhanobut/logger123456789101112allprojects &#123; repositories &#123; jcenter() // 项目gradle中添加 jitpack仓库 maven &#123; url \"https://jitpack.io\" &#125; &#125;&#125;dependencies &#123; // moudle/gradle中添加 compile 'com.github.orhanobut:logger:1.12'&#125; 注意: Logger.init(YOUR_TAG)为初始化入口 2. orhanobut/dialogplus1compile 'com.orhanobut:dialogplus:1.11@aar' 例如: 123456789101112131415161718 private DialogPlus generateDialog(String tag) &#123; View contentView = this.getActivity().getLayoutInflater().inflate(R.layout.bundle_filelter_pop, null); bundleFilterList = (ListView) contentView.findViewById(R.id.bundle_filter_list); cancelBundleFilterBtn = (TextView) contentView.findViewById(R.id.bundle_selfilter_cancel_btn); if (catalogs != null &amp;&amp; !catalogs.isEmpty()) &#123; ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;&gt;(this.getActivity(), R.layout.simple_list_item_1_center, catalogs); bundleFilterList.setAdapter(adapter); &#125; DialogPlus dialog = DialogPlus.newDialog(this.getActivity()) .setContentHolder(new ViewHolder(contentView)) .create(); return dialog;&#125; 效果图如下: 3. 懒人框架 1compile 'com.jakewharton:butterknife:7.0.0' 4. http封装-hongyang1compile 'com.zhy:okhttputils:2.4.1' 5. Gson1compile 'com.google.code.gson:gson:2.2.4'","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"https://yangxiaoge.github.io/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangxiaoge.github.io/tags/Gradle/"}]},{"title":"Android沉浸式状态栏","slug":"Android沉浸式状态栏-md","date":"2015-05-03T01:43:30.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2015/05/03/Android沉浸式状态栏-md/","link":"","permalink":"https://yangxiaoge.github.io/2015/05/03/Android沉浸式状态栏-md/","excerpt":"GitHubDemo 源码 1. 首先看下状态栏与导航栏结构图 主要设置以下两个颜色一致 colorPrimary colorPrimaryDark","text":"GitHubDemo 源码 1. 首先看下状态栏与导航栏结构图 主要设置以下两个颜色一致 colorPrimary colorPrimaryDark 2. 引用库 SystemBarTint, 并在module / build.gradle里添加以下依赖: compile ‘com.readystatesoftware.systembartint:systembartint:1.0.3’ 3. 写一个公共的BaseActivity, 只要继承BaseActivity即可实现沉浸式效果1234567891011121314151617181920212223242526272829303132333435363738package androidautolayout.yjn.com.statusbar;import android.annotation.TargetApi;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.Window;import android.view.WindowManager;import com.readystatesoftware.systembartint.SystemBarTintManager;public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setTranslucentStatus(true); &#125; SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setStatusBarTintResource(R.color.colorPrimary); &#125; @TargetApi(Build.VERSION_CODES.KITKAT) private void setTranslucentStatus(boolean on) &#123; Window win = getWindow(); WindowManager.LayoutParams winParams = win.getAttributes(); final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS; if (on) &#123; winParams.flags |= bits; &#125; else &#123; winParams.flags &amp;= ~bits; &#125; win.setAttributes(winParams); &#125;&#125; Avtivity直接 extends BaseActivity 123456789public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 4.注册清单设置 AndroidManifest.xml","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"}]},{"title":"酷炫的android dialog弹出框","slug":"酷炫的android-dialog弹出框","date":"2015-04-29T05:52:49.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2015/04/29/酷炫的android-dialog弹出框/","link":"","permalink":"https://yangxiaoge.github.io/2015/04/29/酷炫的android-dialog弹出框/","excerpt":"基于github开源框架基础上运用在自己的项目中,效果如下:","text":"基于github开源框架基础上运用在自己的项目中,效果如下:本演示项目 基于Android Studio开发,在对应moudle下的gradle.build中添加以下依赖12compile 'com.nineoldandroids:library:2.4.0' compile 'com.github.sd6352051.niftydialogeffects:niftydialogeffects:1.0.0@aar' 核心代码列出: effect是样式(具体要根据需求来) 12345678910111213141516171819String []type = &#123;\"Fadein\", \"Slideleft\", \"Slidetop\", \"SlideBottom\", \"Slideright\", \"Fall\", \"Newspager\", \"Fliph\", \"Flipv\", \"RotateBottom\", \"RotateLeft\", \"Slit\", \"Shake\", \"Sidefill\"&#125;; int i= (int) (type.length*Math.random()); Effectstype effect = null; switch (i)&#123; case 0:effect=Effectstype.Fadein;break; case 1:effect=Effectstype.Slideright;break; case 2:effect=Effectstype.Slideleft;break; case 3:effect=Effectstype.Slidetop;break; case 4:effect=Effectstype.SlideBottom;break; case 5:effect=Effectstype.Newspager;break; case 6:effect=Effectstype.Fall;break; case 7:effect=Effectstype.Sidefill;break; case 8:effect=Effectstype.Fliph;break; case 9:effect=Effectstype.Flipv;break; case 10:effect=Effectstype.RotateBottom;break; case 11:effect=Effectstype.RotateLeft;break; case 12:effect=Effectstype.Slit;break; case 13:effect=Effectstype.Shake;break; &#125; 弹出框核心如下 12345678910111213141516171819202122232425262728293031323334353637final NiftyDialogBuilder dialogBuilder = NiftyDialogBuilder.getInstance(this); dialogBuilder // 重点设置 .withEffect(effect) //设置对话框弹出样式 //.setCustomView(R.layout.custom, MainActivity.this) // 设置自定义对话框的布局 .withDuration(700) //动画显现的时间（时间长就类似放慢动作） // 基本设置 .withTitle(\"Info\") //设置对话框标题 .withTitleColor(\"#FFFFFF\") //设置标题字体颜色 .withDividerColor(\"#11000000\") //设置分隔线的颜色 .withMessage(\"Are you sure logout?\")//设置对话框显示内容 .withMessageColor(\"#FFFFFFFF\") //设置消息字体的颜色 .withDialogColor(\"#FFE74C3C\") //设置对话框背景的颜色 //.withIcon(getResources().getDrawable(R.drawable.logo)) //设置标题的图标 // 设置是否模态，默认false，表示模态， //要求必须采取行动才能继续进行剩下的操作 | isCancelable(true) .isCancelableOnTouchOutside(true) .withButton1Text(\"Yes\") //设置按钮1的文本 .withButton2Text(\"No\") //设置按钮2的文本 .setButton1Click(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(v.getContext(), \"I am btnYes\", Toast.LENGTH_SHORT).show(); dialogBuilder.dismiss(); &#125; &#125;) .setButton2Click(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(v.getContext(), \"I am btnNo\", Toast.LENGTH_SHORT).show(); dialogBuilder.dismiss(); &#125; &#125;) .show(); app demo下载地址: http://fir.im/NiftyDialog","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://yangxiaoge.github.io/tags/Gradle/"}]},{"title":"自定义Button(图文居中)","slug":"自定义Button(图文居中)","date":"2015-04-29T05:39:56.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2015/04/29/自定义Button(图文居中)/","link":"","permalink":"https://yangxiaoge.github.io/2015/04/29/自定义Button(图文居中)/","excerpt":"首先看下 效果 核心代码:","text":"首先看下 效果 核心代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ztesoft.zsmart.datamall.app.widget;import android.content.Context;import android.graphics.Canvas;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.widget.Button;/** * Description: 自定义Button(图文居中) * Author: 0027008122 [yang.jianan@zte.com.cn] * Time: 2016/1/26 14:21 * Version: 1.0 */public class DrawableCenterButton extends Button&#123; public DrawableCenterButton(Context context) &#123; super(context); // TODO Auto-generated constructor stub &#125; public DrawableCenterButton(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public DrawableCenterButton(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; Drawable[] drawables = getCompoundDrawables(); if (drawables != null) &#123; Drawable drawableLeft = drawables[2]; if (drawableLeft != null) &#123; float textWidth = getPaint().measureText(getText().toString()); int drawablePadding = getCompoundDrawablePadding(); int drawableWidth = 0; drawableWidth = drawableLeft.getIntrinsicWidth(); // 20 是偏移量,不加,长文本会折行 float bodyWidth = textWidth + 20 + drawableWidth + drawablePadding; setPadding(0, 0, (int)(getWidth() - bodyWidth), 0); canvas.translate((getWidth() - bodyWidth) / 2, 0); &#125; &#125; super.onDraw(canvas); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://yangxiaoge.github.io/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"https://yangxiaoge.github.io/tags/自定义View/"}]},{"title":"技术文档收集","slug":"技术文档收集","date":"2015-04-15T04:39:08.000Z","updated":"2017-09-20T01:41:45.604Z","comments":true,"path":"2015/04/15/技术文档收集/","link":"","permalink":"https://yangxiaoge.github.io/2015/04/15/技术文档收集/","excerpt":"","text":"给 Android 开发者的 RxJava 详解 by 扔物线 印象笔记 collecting… 友情链接也有许多大神 使用CheckStyle检查代码(http://gudong.name/2016/04/07/checkstyle.html) Android 名企面试题及涉及知识点整理 Android进阶-吹牛专用_stormzhang大神所写,哈哈 Android官方培训课程中文版","categories":[{"name":"技术文档","slug":"技术文档","permalink":"https://yangxiaoge.github.io/categories/技术文档/"}],"tags":[{"name":"文档","slug":"文档","permalink":"https://yangxiaoge.github.io/tags/文档/"}]},{"title":"Hexo个人博客搭建","slug":"Hexo个人博客搭建","date":"2015-04-12T02:39:08.000Z","updated":"2017-09-20T01:41:45.596Z","comments":true,"path":"2015/04/12/Hexo个人博客搭建/","link":"","permalink":"https://yangxiaoge.github.io/2015/04/12/Hexo个人博客搭建/","excerpt":"前言一直想要一个自己的独立博客，今天偶然发现Hexo这个优秀的静态博客框架，于是乎，便开始着手搭建个人博客。当然要搭配现在流行的gitHub(国内的coding也是相当不错的)，简直是完美写博客的黄金搭档（免费+方便），毕竟咱就是体验下而已，并不需要去买域名(当然,阿里云有的域名很便宜,我买了个第一年4元的,续费就也就几十块,不需要就用github默认域名就OK)！搭建过程也是磕磕碰碰，主要参考如下！供需要的小伙伴借鉴！ 主要参考如下两个博客:嘟嘟独立博客CrazyMilkLogin926 - Material主题的优化","text":"前言一直想要一个自己的独立博客，今天偶然发现Hexo这个优秀的静态博客框架，于是乎，便开始着手搭建个人博客。当然要搭配现在流行的gitHub(国内的coding也是相当不错的)，简直是完美写博客的黄金搭档（免费+方便），毕竟咱就是体验下而已，并不需要去买域名(当然,阿里云有的域名很便宜,我买了个第一年4元的,续费就也就几十块,不需要就用github默认域名就OK)！搭建过程也是磕磕碰碰，主要参考如下！供需要的小伙伴借鉴！ 主要参考如下两个博客:嘟嘟独立博客CrazyMilkLogin926 - Material主题的优化 Next主题相关配置: 详见官方文档 主要的配置项: 直接跳转博客内静态 html 网站,详情→在开头加上 12layout: false--- 即如下写法:123456789101112layout: false---&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;我的演说 - @演说.io&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ..... &lt;/body&gt;&lt;/html&gt; 站内搜索 (add 2016-9-30 14:38:13) 安装 hexo-generator-search，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-search --save 编辑 站点配置文件，新增以下内容到任意位置： 123search: path: search.xml field: post dashboard持续集成ci-hexo-coding hexo提交搜索引擎（百度+谷歌）(百度,谷歌就能搜索到个人网站) 参考: http://tengj.top/2016/03/14/hexo6seo/我的访问连接:http://yangxiaoge.coding.me/sitemap.xmlhttp://yangxiaoge.coding.me/baidusitemap.xml注意: 需要修改站点配置文件``_config.yml中url这个属性值 (这个url决定了生成的sitemap.xlm,baidusitemap.xml中文章路径) 如何新增导航Menu? hexo new page &quot;link&quot; (创建一个link目录,并且默认生成index.md) 主题配置文件_config.xml中 menu节点下增加 link: /link,menu_icons节点(FontAwesome头像)增加 link: chain \\themes\\next\\languages目录下语言配置文件zh-Hans.yml中 menu节点增加 link: 链接 如何关闭新建页面的评论功能？ 12345---title: \"About\"layout: \"page\"comments: false--- 添加背景以及点击爱心效果(2016-9-21 11:47:32)http://michaelxiang.me/2015/11/30/hexo-next-optimize/注意: 目前只有将主题下_config.xml配置文件中的Schemes设置成Pisces (如果设置成Mist,那么手机端的背景动画会布满屏幕,实在太难看~~~) 打赏 文章阅读数使用的是leancloud(leancloud很强大,可以作为后端云供等app调用) 代码高亮↓↓↓ 添加多说评论 导航图标↓↓↓ 评论头像旋转–&gt;设置方法 添加Fork me on Github ribbon详见 站点访问量不蒜子 : 只需两行代码就可以完成 置顶功能,跟小伙伴LittleFish学习的请戳 👉 LittleFish 文本、图片居中参考: http://theme-next.iissnan.com/tag-plugins.html 百度统计网站统计 （账号：yangxiaoge 密码：**）https://tongji.baidu.com/web","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yangxiaoge.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yangxiaoge.github.io/tags/Hexo/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2015-04-11T06:06:10.000Z","updated":"2017-09-20T01:41:45.600Z","comments":true,"path":"2015/04/11/Markdown语法/","link":"","permalink":"https://yangxiaoge.github.io/2015/04/11/Markdown语法/","excerpt":"","text":"欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式(有的编辑器有用,有的无效!)可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#115;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"Markdown语法","slug":"Markdown语法","permalink":"https://yangxiaoge.github.io/categories/Markdown语法/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://yangxiaoge.github.io/tags/Markdown/"}]}]}